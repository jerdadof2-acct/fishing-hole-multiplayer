<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- SEO Meta Tags -->
    <title>Kitty Creek Fishing Club - Purrfect Cat Fishing Tournaments & Mayhem! üê±üé£</title>
    <meta name="description" content="Kitty Creek Fishing Club - Where cats become legendary anglers! üê±üé£ Join real-time fishing tournaments, compete with hilarious bot cats like 'Sly Sylvester' and 'Whiskers McFluff', catch rare fish, unlock epic gear, and prove you're the purrfect fisher-cat. Free multiplayer mayhem that'll have you hooked!">
    <meta name="keywords" content="Kitty Creek Fishing Club, cat fishing game, multiplayer fishing, online fishing tournament, kitty creek, cat fishing, free fishing game, competitive fishing, cat game, fishing tournaments, legendary fish, purrfect fishing, fisher cats, fishing mayhem">
    <meta name="author" content="Kitty Creek Fishing Club">
    <meta name="robots" content="index, follow">
    
    <!-- Open Graph Meta Tags for Social Media -->
    <meta property="og:title" content="Kitty Creek Fishing Club - Purrfect Cat Fishing Tournaments & Mayhem! üê±üé£">
    <meta property="og:description" content="Kitty Creek Fishing Club - The most pawsome fishing tournament game ever! üê±üé£ Battle against legendary fisher-cats like Tommy the Stray and Captain Claw in real-time competitions. Catch legendary fish, unlock purrfect gear, and become the champion of the creek. It's fishing chaos with cats - what's not to love?">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://fishing-hole-multiplayer-production.up.railway.app/">
    <meta property="og:image" content="https://fishing-hole-multiplayer-production.up.railway.app/fishing-game.jpg">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Kitty Creek Fishing Club - Purrfect Cat Fishing Tournaments & Mayhem! üê±üé£">
    <meta name="twitter:description" content="Kitty Creek Fishing Club - Where cats dominate the fishing world! üê±üé£ Real-time tournaments, hilarious bot competitors, legendary catches, and purrfect gear. It's fishing mayhem with cats and it's absolutely pawsome!">
    
    <!-- Additional SEO -->
    <link rel="canonical" href="https://fishing-hole-multiplayer-production.up.railway.app/">
    <meta name="theme-color" content="#2196f3">
    
    <!-- Favicon and PWA -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='grad' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%2342a5f5;stop-opacity:1' /%3E%3Cstop offset='100%25' style='stop-color:%232196f3;stop-opacity:1' /%3E%3C/linearGradient%3E%3C/defs%3E%3Ccircle cx='50' cy='50' r='48' fill='url(%23grad)'/%3E%3Cpath d='M30 25 L45 45 L40 50 L25 30 Z' fill='white' stroke='%230a1628' stroke-width='2'/%3E%3Ccircle cx='45' cy='50' r='12' fill='none' stroke='white' stroke-width='3'/%3E%3Cline x1='45' y1='62' x2='45' y2='75' stroke='white' stroke-width='3' stroke-linecap='round'/%3E%3C/svg%3E">
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='grad' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%2342a5f5;stop-opacity:1' /%3E%3Cstop offset='100%25' style='stop-color:%232196f3;stop-opacity:1' /%3E%3C/linearGradient%3E%3C/defs%3E%3Ccircle cx='50' cy='50' r='48' fill='url(%23grad)'/%3E%3Cpath d='M30 25 L45 45 L40 50 L25 30 Z' fill='white' stroke='%230a1628' stroke-width='2'/%3E%3Ccircle cx='45' cy='50' r='12' fill='none' stroke='white' stroke-width='3'/%3E%3Cline x1='45' y1='62' x2='45' y2='75' stroke='white' stroke-width='3' stroke-linecap='round'/%3E%3C/svg%3E">
    <link rel="manifest" href="/manifest.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Kitty Creek">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #0a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .main-area {
            display: flex;
            flex-direction: column;
            background: rgba(15, 25, 40, 0.95);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 200, 255, 0.2);
        }

        .game-layout {
            display: flex;
            flex: 1;
            gap: 10px;
        }

        .left-sidebar, .right-sidebar {
            width: 250px;
            background: rgba(20, 30, 50, 0.8);
            border-radius: 12px;
            border: 1px solid rgba(100, 200, 255, 0.15);
            padding: 15px;
            overflow-y: auto;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .desktop-tab-btn {
            flex: 1;
            min-width: 70px;
            padding: 6px 8px;
            background: rgba(15, 25, 40, 0.9);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 6px;
            color: #64b5f6;
            cursor: pointer;
            font-size: 10px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .desktop-tab-btn:hover {
            background: rgba(25, 35, 55, 0.9);
        }

        .desktop-tab-btn.active {
            background: linear-gradient(135deg, #42a5f5 0%, #2196f3 100%);
            color: #000;
            border-color: #42a5f5;
        }

        .desktop-tab-content {
            display: none;
        }

        .desktop-tab-content.active {
            display: block;
        }

        .center-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .chat-section {
            background: rgba(20, 30, 50, 0.95);
            border-top: 2px solid rgba(100, 200, 255, 0.4);
            box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.3);
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 100;
            transition: height 0.3s ease;
            overflow: hidden;
        }

        .chat-section.collapsed {
            height: 40px;
        }

        .chat-section.expanded {
            height: 180px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 8px 15px;
        }

        .chat-toggle {
            width: 100%;
            height: 40px;
            background: rgba(20, 30, 50, 0.95);
            border: none;
            border-top: 2px solid rgba(100, 200, 255, 0.4);
            color: rgba(100, 200, 255, 0.9);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            padding: 0 15px;
        }

        .chat-toggle:hover {
            background: rgba(30, 40, 60, 0.95);
            color: rgba(100, 200, 255, 1);
        }

        .chat-toggle-icon {
            font-size: 18px;
            transition: transform 0.3s ease;
        }

        .chat-section.expanded .chat-toggle-icon {
            transform: rotate(180deg);
        }

        .chat-content {
            display: none;
            flex: 1;
            flex-direction: column;
            gap: 6px;
            overflow: hidden;
        }

        .chat-section.expanded .chat-content {
            display: flex;
        }

        @media (min-width: 769px) {
            .game-layout {
                padding-bottom: 40px; /* Space for collapsed chat toggle */
            }
        }

        /* Tablet: Adjust layout when chat is expanded */
        @media (min-width: 769px) and (max-width: 1024px) {
            .chat-section.expanded {
                height: 180px;
            }
            
            .chat-section.expanded ~ .game-layout {
                padding-bottom: 190px; /* Extra space for expanded chat on tablet */
            }
            
            /* Ensure chat doesn't cover critical elements */
            .chat-section {
                z-index: 150; /* Above most content but below modals */
            }
        }

        .header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 15px;
            text-align: center;
            border-bottom: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 12px 12px 0 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .header h1 {
            color: #ffffff;
            font-size: 1.8rem;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            font-weight: 700;
            letter-spacing: 1px;
        }

        .login-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .login-box {
            background: linear-gradient(135deg, rgba(30, 60, 114, 0.95) 0%, rgba(42, 82, 152, 0.95) 100%);
            border: 2px solid rgba(100, 200, 255, 0.4);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5), 0 0 30px rgba(100, 200, 255, 0.2);
            backdrop-filter: blur(10px);
        }

        .login-box h2 {
            color: #ffffff;
            margin-bottom: 25px;
            font-weight: 700;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        }

        .login-input {
            background: rgba(15, 25, 40, 0.9);
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 10px;
            color: #e0e0e0;
            padding: 12px 15px;
            margin: 10px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 16px;
            transition: all 0.3s ease;
            width: 90%;
            max-width: 300px;
        }

        .login-input:focus {
            outline: none;
            border-color: rgba(100, 200, 255, 0.6);
            box-shadow: 0 0 15px rgba(100, 200, 255, 0.3);
        }

        .login-input::placeholder {
            color: rgba(200, 200, 200, 0.5);
        }

        .login-btn {
            background: linear-gradient(135deg, #64b5f6 0%, #42a5f5 100%);
            border: none;
            border-radius: 12px;
            color: #ffffff;
            padding: 14px 30px;
            margin: 15px 10px;
            cursor: pointer;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 16px;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(100, 181, 246, 0.4);
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .login-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(100, 181, 246, 0.6);
            background: linear-gradient(135deg, #90caf9 0%, #64b5f6 100%);
        }

        .login-btn:active {
            transform: translateY(0);
        }

        .character-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 10px 0;
        }

        .character-option {
            font-size: 40px;
            padding: 12px;
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(15, 25, 40, 0.8);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .character-option:hover {
            border-color: rgba(100, 200, 255, 0.6);
            background: rgba(30, 50, 80, 0.9);
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(100, 200, 255, 0.4);
        }

        .character-option.selected {
            border-color: rgba(100, 200, 255, 0.8);
            background: rgba(42, 82, 152, 0.6);
            box-shadow: 0 0 20px rgba(100, 200, 255, 0.6);
        }

        .character-selector-small {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            margin: 5px 0;
        }

        .char-part-option {
            font-size: 24px;
            padding: 5px 8px;
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(15, 25, 40, 0.9);
            font-size: 18px;
        }

        .char-part-option:hover {
            border-color: rgba(100, 200, 255, 0.5);
            background: rgba(20, 30, 50, 0.8);
            transform: scale(1.1);
        }

        .char-part-option.selected {
            border-color: rgba(100, 200, 255, 0.5);
            background: rgba(42, 82, 152, 0.6);
            box-shadow: 0 0 15px rgba(100, 200, 255, 0.4);
        }

        .char-option-btn {
            padding: 6px 12px;
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(15, 25, 40, 0.9);
            color: #64b5f6;
            font-size: 11px;
            font-weight: bold;
        }

        .char-option-btn:hover {
            border-color: rgba(100, 200, 255, 0.5);
            background: rgba(20, 30, 50, 0.8);
            transform: scale(1.05);
        }

        .char-option-btn[data-selected="true"] {
            border-color: rgba(100, 200, 255, 0.5);
            background: rgba(42, 82, 152, 0.6);
            box-shadow: 0 0 12px rgba(100, 200, 255, 0.4);
        }

        .fishing-area {
            flex: 1;
            position: relative;
            background: linear-gradient(135deg, #0a1a2e 0%, #16213e 30%, #0f3460 70%, #1a1a2e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 30px;
            min-height: 0;
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.5);
        }
        
        /* Side-by-side layout: cat on left, lake on right */
        .fishing-game-layout {
            display: flex;
            flex-direction: row;
            gap: 15px;
            align-items: flex-start;
            width: 100%;
            max-width: 1400px;
        }
        
        .player-cat-side {
            flex-shrink: 0;
            width: 120px; /* Fixed width for cat container */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .lake-side {
            flex: 1;
            min-width: 0; /* Allow lake to shrink if needed */
        }

        .fisherman-row {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 100%;
            margin-bottom: 0;
            padding: 0 20px;
            flex-shrink: 0;
            align-items: flex-end;
        }

        .fishing-lake {
            width: calc(100% - 0px); /* Removed extra padding since in lake-side container */
            max-width: calc(100vw - 600px);
            height: calc(100vh - 350px); /* Reduced height to make room for cat */
            min-height: 350px;
            max-height: 550px;
            border: 3px solid rgba(100, 181, 246, 0.6);
            border-radius: 20px;
            position: relative;
            overflow: visible;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                0 0 60px rgba(33, 150, 243, 0.5),
                inset 0 0 100px rgba(0, 100, 200, 0.7),
                inset 0 15px 150px rgba(100, 181, 246, 0.5),
                0 0 40px rgba(66, 165, 245, 0.4);
        }

        /* Water background layer with distortion */
        .fishing-lake::before {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: 17px; /* Slightly smaller to account for border */
            background: 
                /* Deep beautiful water - vibrant blues */
                radial-gradient(ellipse at center, #1e88e5 0%, #1565c0 30%, #0d47a1 60%, #01579b 100%),
                /* Surface sparkle and light */
                linear-gradient(
                    180deg,
                    rgba(144, 202, 249, 0.4) 0%,
                    rgba(100, 181, 246, 0.3) 8%,
                    rgba(66, 165, 245, 0.2) 15%,
                    rgba(33, 150, 243, 0.15) 25%,
                    transparent 50%
                ),
                /* Animated wave pattern */
                repeating-linear-gradient(
                    0deg,
                    rgba(144, 202, 249, 0.25) 0px,
                    rgba(144, 202, 249, 0.25) 8px,
                    rgba(66, 165, 245, 0.2) 8px,
                    rgba(66, 165, 245, 0.2) 16px
                ),
                /* Depth highlights and light rays */
                radial-gradient(ellipse at 25% 35%, rgba(100, 181, 246, 0.3) 0%, transparent 40%),
                radial-gradient(ellipse at 75% 65%, rgba(66, 165, 245, 0.25) 0%, transparent 45%),
                radial-gradient(ellipse at 50% 80%, rgba(33, 150, 243, 0.2) 0%, transparent 50%);
            animation: waterShimmer 4s ease-in-out infinite;
            filter: url(#water-distort);
            z-index: 1;
        }

        /* Respect reduced motion */
        @media (prefers-reduced-motion: reduce) {
            .fishing-lake::before { filter: none !important; }
        }
        
        /* Low performance mode - disable water distortion */
        .fishing-lake.low-performance::before {
            filter: none !important;
        }

        @keyframes waterShimmer {
            0%, 100% {
                background-position: 0% 0%, 0 0, 0 0;
            }
            50% {
                background-position: 0% 0%, 0 20px, 20px 10px;
            }
        }

        /* Caustics overlay */
        #caustics-layer, #mobile-caustics-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
            mix-blend-mode: screen;
            opacity: 0.22;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="256" height="256"><filter id="c"><feTurbulence type="turbulence" baseFrequency="0.9" numOctaves="1" seed="11"/><feColorMatrix type="saturate" values="0"/></filter><rect width="100%" height="100%" filter="url(%23c)"/></svg>');
            background-size: 260px 260px;
            will-change: transform, opacity;
            transform: translate3d(0,0,0);
            animation: causticsDrift 8s ease-in-out infinite;
        }

        @keyframes causticsDrift {
            0%, 100% { transform: translate3d(0, 0, 0) rotate(0deg); }
            25% { transform: translate3d(8px, 6px, 0) rotate(0.6deg); }
            50% { transform: translate3d(-6px, 8px, 0) rotate(-0.4deg); }
            75% { transform: translate3d(6px, -4px, 0) rotate(0.3deg); }
        }

        /* Splash canvas overlay */
        #splash-canvas, #mobile-splash-canvas {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 7; /* above water surface & ripples; below HUD if needed */
        }

        /* Hide mobile overlays on desktop to avoid double compositing */
        @media (min-width: 769px) {
            #mobile-caustics-layer, #mobile-splash-canvas {
                display: none;
            }
        }

        /* Hide desktop overlays on mobile */
        @media (max-width: 768px) {
            #caustics-layer, #splash-canvas {
                display: none;
            }
        }

        /* Cat rig sizing inside fisherman frame */
        .cat-rig { 
            width: 46px; 
            height: 46px; 
            position: relative; 
        }

        /* SVG fills via CSS variables (we can recolor from JS) */
        .cat-rig svg { 
            width: 100%; 
            height: 100%; 
            display: block; 
        }

        /* Micro-animations */
        @keyframes cat-breathe { 
            0%,100% { transform: translateY(0) } 
            50% { transform: translateY(-0.6px) } 
        }
        @keyframes cat-blink   { 
            0%,92%,100% { transform: scaleY(1) } 
            93% { transform: scaleY(0.05) } 
            96% { transform: scaleY(1) } 
        }
        @keyframes ear-twitch  { 
            0%,96% { transform: rotate(0deg) } 
            97% { transform: rotate(-6deg) } 
            100% { transform: rotate(0deg) } 
        }
        @keyframes tail-sway   { 
            0%,100% { transform: rotate(8deg) } 
            50% { transform: rotate(-6deg) } 
        }

        .cat-body { 
            animation: cat-breathe 2.3s ease-in-out infinite; 
            transform-origin: 50% 60%; 
        }
        .cat-eyes { 
            transform-origin: 50% 45%; 
            animation: cat-blink 5.5s infinite; 
        }
        .cat-earL { 
            transform-origin: 32% 22%; 
            animation: ear-twitch 8s infinite; 
        }
        .cat-earR { 
            transform-origin: 68% 22%; 
            animation: ear-twitch 9.5s infinite; 
        }
        .cat-tail { 
            transform-origin: 90% 70%; 
            animation: tail-sway 3.8s ease-in-out infinite; 
        }

        /* Emote bubble */
        .cat-emote {
            position: absolute; 
            right: -6px; 
            top: -8px; 
            padding: 2px 4px;
            background: rgba(0,0,0,.85); 
            border: 1px solid rgba(100,200,255,.4);
            border-radius: 6px; 
            font-size: 10px; 
            color: #fff; 
            pointer-events: none; 
            opacity: 0;
            transform: translateY(6px); 
            transition: opacity .15s ease, transform .15s ease;
        }
        .cat-emote.show { 
            opacity: 1; 
            transform: translateY(0); 
        }

        /* Gear slots (hidden if empty) */
        .cat-gear { 
            position: absolute; 
            inset: 0; 
            pointer-events: none; 
        }
        .cat-hat, .cat-glasses, .cat-vest { 
            position: absolute; 
            inset: 0; 
            display: none; 
        }
        .cat-hat.show, .cat-glasses.show, .cat-vest.show { 
            display: block; 
        }

        /* 3D Cat containers - Make 3D host visible and predictable */
        .cat3d { 
            width: 96px; 
            height: 96px; 
            display: block;
            position: relative; 
            z-index: 9; /* Above water overlays (z-index 5-7) */
            border-radius: 8px;
            overflow: visible; /* Changed from hidden to visible during camera framing testing */
        }
        
        .cat3d canvas { 
            display: block; 
            width: 100%; 
            height: 100%; 
        }
        
        @media (max-width: 768px) { 
            .cat3d { 
                width: 80px; 
                height: 80px; 
            } 
        }

        /* Generic ripple elements */
        .water-ripple, .water-ripple-invert {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            pointer-events: none;
            left: 0;
            top: 0;
            transform: translate(-50%, -50%) scale(1);
            opacity: 0.55;
            box-shadow: 0 0 0 2px rgba(255,255,255,0.55) inset;
            animation: rippleOut 1000ms ease-out forwards;
            mix-blend-mode: overlay;
        }

        .water-ripple-invert {
            opacity: 0.4;
            box-shadow: 0 0 0 2px rgba(255,255,255,0.0) inset;
            outline: 2px solid rgba(255,255,255,0.5);
            animation: rippleIn 700ms ease-out forwards;
        }

        @keyframes rippleOut {
            to { 
                transform: translate(-50%, -50%) scale(16); 
                opacity: 0; 
                box-shadow: 0 0 0 1px rgba(255,255,255,0.0) inset; 
            }
        }

        @keyframes rippleIn {
            40% { 
                transform: translate(-50%, -50%) scale(0.8); 
                opacity: 0.55; 
            }
            to { 
                transform: translate(-50%, -50%) scale(8); 
                opacity: 0; 
            }
        }

        /* Traveling wave ripples */
        .wave-ripple {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent 0%, rgba(144, 202, 249, 0.3) 40%, rgba(144, 202, 249, 0.3) 60%, transparent 100%);
            animation: waveTravel 3s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes waveTravel {
            0% {
                left: -100%;
                opacity: 0;
            }
            50% {
                opacity: 1;
            }
            100% {
                left: 100%;
                opacity: 0;
            }
        }

        /* Fish shadows swimming under water */
        .fish-shadow {
            position: absolute;
            width: 40px;
            height: 20px;
            background: radial-gradient(ellipse, rgba(0, 0, 0, 0.3) 0%, rgba(0, 0, 0, 0.1) 50%, transparent 100%);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0.4;
            transform-origin: center;
        }

        .fish-shadow::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 75%;
            width: 8px;
            height: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .fisherman {
            width: 60px;
            height: 80px;
            border-radius: 50%;
            border: 2px solid rgba(100, 200, 255, 0.4);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            font-weight: bold;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 50%, #2c3e50 100%);
            color: #64b5f6;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 
                0 4px 20px rgba(33, 150, 243, 0.5),
                0 0 30px rgba(100, 181, 246, 0.4),
                inset 0 0 15px rgba(0, 0, 0, 0.4);
            overflow: visible;
        }
        
        .fisherman-character {
            font-size: 48px;
            line-height: 1;
            margin-bottom: 5px;
        }

        .fisherman-initial {
            display: none; /* Hide initials to show character instead */
        }

        .fisherman-name {
            font-size: 9px;
            margin-top: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 50px;
            position: relative;
            z-index: 10;
            background: rgba(0, 0, 0, 0.95);
            padding: 2px 4px;
            border-radius: 3px;
            border: 1px solid rgba(100, 200, 255, 0.3);
            color: #64b5f6;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(100, 181, 246, 0.8);
            box-shadow: 0 0 8px rgba(100, 181, 246, 0.5);
        }

        .fisherman.you {
            background: linear-gradient(135deg, #64b5f6 0%, #42a5f5 50%, #2196f3 100%);
            color: #000;
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 
                0 0 20px rgba(100, 181, 246, 0.6),
                inset 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .fisherman.other {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 50%, #2c3e50 100%);
            color: #64b5f6;
            border-color: rgba(100, 200, 255, 0.5);
        }

        .fisherman.fishing {
            animation: fishingBob 2s ease-in-out infinite;
        }

        @keyframes fishingBob {
            0%, 100% { 
                transform: scale(1) translateY(0px);
            }
            25% { 
                transform: scale(1.05) translateY(-2px);
            }
            50% { 
                transform: scale(1.1) translateY(-3px);
            }
            75% { 
                transform: scale(1.05) translateY(-2px);
            }
        }

        .fishing-line {
            position: absolute;
            width: 2px;
            background: #ffffff;
            z-index: 10;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        .fishing-line.casting {
            animation: lineCast 2s ease-in-out infinite;
        }

        @keyframes lineCast {
            0% { 
                transform: translateX(-50%) rotate(-0.5deg);
                transform-origin: top center;
            }
            50% { 
                transform: translateX(-50%) rotate(0.5deg);
                transform-origin: top center;
            }
            100% { 
                transform: translateX(-50%) rotate(-0.5deg);
                transform-origin: top center;
            }
        }
        
        @keyframes fishBite {
            0%, 100% { 
                transform: translateX(-50%) scale(1) translateY(0);
            }
            25% { 
                transform: translateX(-50%) scale(1.3) translateY(-8px);
            }
            50% { 
                transform: translateX(-50%) scale(1.15) translateY(-5px);
            }
            75% { 
                transform: translateX(-50%) scale(1.3) translateY(-8px);
            }
        }

        .fish-bite-splash {
            position: absolute;
            width: 80px;
            height: 80px;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 7;
        }

        .fish-bite-splash::before,
        .fish-bite-splash::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            background: radial-gradient(circle, rgba(200, 220, 255, 0.8) 0%, rgba(150, 200, 255, 0.4) 40%, rgba(100, 180, 255, 0) 100%);
            animation: biteSplash 1.5s ease-out;
        }

        .fish-bite-splash::before {
            width: 40px;
            height: 40px;
            animation-delay: 0s;
        }

        .fish-bite-splash::after {
            width: 60px;
            height: 60px;
            animation-delay: 0.1s;
        }

        @keyframes biteSplash {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(0);
            }
            50% {
                opacity: 0.8;
                transform: translate(-50%, -50%) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1.5);
            }
        }

        @keyframes fishStrike {
            0%, 100% { 
                transform: scale(1.2) translateY(0px);
            }
            25% { 
                transform: scale(1.4) translateY(-3px);
            }
            50% { 
                transform: scale(1.3) translateY(-6px);
            }
            75% { 
                transform: scale(1.4) translateY(-3px);
            }
        }

        @keyframes splashExpand {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(0);
            }
            50% {
                opacity: 0.8;
                transform: translate(-50%, -50%) scale(1.5);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(3);
            }
        }

        @keyframes fishStrikeIntense {
            0%, 100% { 
                transform: translateX(-50%) scale(1.3) translateY(0px) rotate(0deg);
            }
            15% { 
                transform: translateX(-50%) scale(1.5) translateY(-8px) rotate(-5deg);
            }
            30% { 
                transform: translateX(-50%) scale(1.4) translateY(-12px) rotate(5deg);
            }
            45% { 
                transform: translateX(-50%) scale(1.6) translateY(-6px) rotate(-3deg);
            }
            60% { 
                transform: translateX(-50%) scale(1.3) translateY(-10px) rotate(3deg);
            }
            75% { 
                transform: translateX(-50%) scale(1.5) translateY(-4px) rotate(-2deg);
            }
        }

        @keyframes lineTensionSubtle {
            0%, 100% { 
                transform: translateX(-50%) rotate(-0.2deg);
                opacity: 1;
            }
            50% { 
                transform: translateX(-50%) rotate(0.2deg);
                opacity: 0.95;
            }
        }

        @keyframes lineTension {
            0%, 100% { 
                transform: translateX(-50%) rotate(-1deg);
                opacity: 1;
            }
            25% { 
                transform: translateX(-50%) rotate(2deg);
                opacity: 0.9;
            }
            50% { 
                transform: translateX(-50%) rotate(-2deg);
                opacity: 0.8;
            }
            75% { 
                transform: translateX(-50%) rotate(1deg);
                opacity: 0.9;
            }
        }

        @keyframes splashExpandIntense {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(0) rotate(0deg);
            }
            30% {
                opacity: 0.9;
                transform: translate(-50%, -50%) scale(1.2) rotate(180deg);
            }
            60% {
                opacity: 0.6;
                transform: translate(-50%, -50%) scale(2) rotate(360deg);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(3.5) rotate(540deg);
            }
        }

        @keyframes rippleExpand {
            0% {
                opacity: 0.8;
                transform: translate(-50%, -50%) scale(0.5);
                border-width: 3px;
            }
            50% {
                opacity: 0.4;
                transform: translate(-50%, -50%) scale(1.5);
                border-width: 1px;
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(3);
                border-width: 0px;
            }
        }

        @keyframes reelIn {
            0% {
                height: var(--original-height);
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
            100% {
                height: 0px;
                opacity: 0;
            }
        }
        
        @keyframes fishCaught {
            0% {
                transform: scale(0.5) rotate(-10deg);
                opacity: 0;
            }
            50% {
                transform: scale(1.2) rotate(5deg);
                opacity: 1;
            }
            100% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        .hook {
            position: absolute;
            top: calc(100% - 18px);
            left: 50%;
            width: 18px;
            height: 22px;
            transform: translateX(-50%);
            
            /* Realistic red and white bobber */
            border-radius: 50%;
            border: 2px solid rgba(0, 0, 0, 0.1);
            
            /* Red top, white bottom with realistic shading */
            background: 
                radial-gradient(circle at 40% 35%, rgba(255, 255, 255, 0.6) 0%, transparent 50%),
                linear-gradient(to bottom,
                    #ff3333 0%,
                    #ff3333 20%,
                    #ff0000 25%,
                    #ff0000 45%,
                    #ffffff 45%,
                    #ffffff 55%,
                    #ff0000 55%,
                    #ff0000 100%
                );
            
            box-shadow: 
                0 3px 8px rgba(0, 0, 0, 0.4),
                inset 0 3px 6px rgba(255, 255, 255, 0.4),
                inset 0 -6px 8px rgba(0, 0, 0, 0.2),
                0 0 8px rgba(255, 0, 0, 0.2);
            z-index: 10;
        }
        
        .hook::before {
            content: '';
            position: absolute;
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 8px;
            background: linear-gradient(to bottom, #ffffff 0%, #e0e0e0 100%);
            border-radius: 2px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .fishing-line {
            position: absolute;
            width: 2px;
            background: #ffffff;
            z-index: 10;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        .fishing-line.casting {
            animation: lineCast 2s ease-in-out infinite;
        }

        .fishing-line.reeling {
            animation: lineBob 2s ease-in-out infinite;
        }

        @keyframes lineBob {
            0%, 100% { transform: translateX(-50%) rotate(-0.3deg); }
            50% { transform: translateX(-50%) rotate(0.3deg); }
        }

        /* Hook styling is defined in mobile section and first hook definition */

        .hook-splash {
            position: absolute;
            width: 30px;
            height: 30px;
            pointer-events: none;
            transform: translateX(-50%);
            z-index: 5;
        }

        .hook-splash::before,
        .hook-splash::after {
            content: '';
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(135, 206, 250, 0.6) 0%, rgba(135, 206, 250, 0) 70%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation: splashRipple 1.2s infinite ease-out;
        }

        .hook-splash::before {
            width: 15px;
            height: 15px;
            animation-delay: 0s;
        }

        .hook-splash::after {
            width: 25px;
            height: 25px;
            animation-delay: 0.2s;
        }

        .hook-landing-splash {
            position: absolute;
            width: 60px;
            height: 60px;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 6;
        }

        .hook-landing-splash::before,
        .hook-landing-splash::after {
            content: '';
            position: absolute;
            border-radius: 50%;
            border: 3px solid rgba(200, 230, 255, 0.7);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation: landingSplash 1.2s ease-out forwards;
            box-shadow: 0 0 20px rgba(200, 230, 255, 0.5);
        }

        .hook-landing-splash::before {
            width: 30px;
            height: 30px;
            animation-delay: 0s;
        }

        .hook-landing-splash::after {
            width: 50px;
            height: 50px;
            animation-delay: 0.15s;
        }

        .hook-landing-splash .splash-wave {
            position: absolute;
            border-radius: 50%;
            border: 2px solid rgba(200, 230, 255, 0.7);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation: landingSplash 1.2s ease-out forwards;
            box-shadow: 0 0 20px rgba(200, 230, 255, 0.5);
            width: 70px;
            height: 70px;
            animation-delay: 0.3s;
        }

        @keyframes landingSplash {
            0% {
                width: 10px;
                height: 10px;
                opacity: 1;
                border-width: 3px;
            }
            50% {
                opacity: 0.7;
                border-width: 2px;
            }
            100% {
                width: 80px;
                height: 80px;
                opacity: 0;
                border-width: 0px;
            }
        }

        @keyframes splashRipple {
            0% {
                width: 8px;
                height: 8px;
                opacity: 0.8;
            }
            30% {
                opacity: 0.6;
            }
            100% {
                width: 35px;
                height: 35px;
                opacity: 0;
            }
        }

        .ripples {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 5;
        }

        .ripple {
            position: absolute;
            border: 2px solid rgba(135, 206, 250, 0.4);
            border-radius: 50%;
            animation: ripple 4s ease-in-out infinite;
            box-shadow: 0 0 10px rgba(135, 206, 250, 0.3);
        }

        .mouse-ripple {
            position: absolute;
            border: 3px solid rgba(200, 230, 255, 0.6);
            border-radius: 50%;
            pointer-events: none;
            animation: mouseRipple 1.5s ease-out forwards;
            box-shadow: 0 0 15px rgba(200, 230, 255, 0.5);
        }

        @keyframes ripple {
            0% {
                transform: scale(0);
                opacity: 0.8;
                border-width: 2px;
            }
            50% {
                opacity: 0.4;
                border-width: 1px;
            }
            100% {
                transform: scale(2.5);
                opacity: 0;
                border-width: 0px;
            }
        }

        @keyframes mouseRipple {
            0% {
                transform: scale(0);
                opacity: 0.8;
                border-width: 3px;
            }
            50% {
                opacity: 0.5;
                border-width: 2px;
            }
            100% {
                transform: scale(3);
                opacity: 0;
                border-width: 0px;
            }
        }

        .controls {
            background: rgba(20, 30, 50, 0.8);
            padding: 15px;
            text-align: center;
            border-top: 2px solid rgba(100, 200, 255, 0.4);
            flex-shrink: 0; /* Prevent controls from shrinking */
            z-index: 10; /* Ensure controls stay visible */
        }

        .btn {
            background: linear-gradient(135deg, #42a5f5 0%, #2196f3 100%);
            border: none;
            border-radius: 8px;
            color: #ffffff;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            font-weight: 600;
            box-shadow: 0 3px 10px rgba(33, 150, 243, 0.3);
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(33, 150, 243, 0.5);
            background: linear-gradient(135deg, #64b5f6 0%, #42a5f5 100%);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn.casting {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }


        .section {
            margin-bottom: 20px;
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            background: rgba(15, 25, 40, 0.6);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .section h3 {
            color: #ffffff;
            margin-bottom: 12px;
            text-align: center;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .player-info {
            font-size: 16px;
            background: linear-gradient(135deg, rgba(30, 60, 114, 0.9) 0%, rgba(42, 82, 152, 0.9) 100%);
            padding: 18px;
            border: 2px solid rgba(100, 200, 255, 0.4);
            border-radius: 12px;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), 0 0 20px rgba(100, 200, 255, 0.2);
        }

        .stat-line {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 8px 0;
            border-bottom: 1px solid rgba(100, 200, 255, 0.2);
            font-weight: 600;
            color: #e0e0e0;
        }

        .stat-line:last-child {
            border-bottom: none;
        }

        .stat-line span {
            color: #ffffff;
            font-weight: 700;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 50%;
        }

        .player-stats {
            background: linear-gradient(135deg, rgba(30, 60, 114, 0.9) 0%, rgba(42, 82, 152, 0.9) 100%);
            padding: 18px;
            border: 2px solid rgba(100, 200, 255, 0.4);
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            margin-bottom: 15px;
            box-shadow: 0 0 10px rgba(100, 181, 246, 0.3);
        }

        .player-stats .stat-line {
            margin: 6px 0;
            padding: 4px 0;
        }

        .player-stats .stat-line span {
            color: #ffff00;
            font-weight: bold;
        }

        .achievements {
            background: rgba(20, 30, 50, 0.8);
            padding: 10px;
            border: 2px solid rgba(100, 200, 255, 0.4);
            border-radius: 8px;
            margin-bottom: 15px;
            box-shadow: 0 0 10px rgba(100, 181, 246, 0.3);
            max-height: 200px;
            overflow-y: auto;
        }

        .achievement-item {
            margin: 5px 0;
            padding: 10px;
            background: rgba(30, 60, 114, 0.6);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            font-size: 12px;
            color: #e0e0e0;
            transition: all 0.3s ease;
        }

        .achievement-item.locked {
            opacity: 0.4;
            color: #888;
            filter: grayscale(50%);
        }

        .leaderboard {
            background: rgba(20, 30, 50, 0.8);
            padding: 15px;
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 12px;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .leaderboard-category {
            margin-bottom: 12px;
        }

        .leaderboard-category:last-child {
            margin-bottom: 0;
        }

        .leaderboard-category h4 {
            color: #ffffff;
            margin: 0 0 10px 0;
            font-size: 14px;
            text-align: center;
            border-bottom: 2px solid rgba(100, 200, 255, 0.3);
            padding-bottom: 8px;
            font-weight: 700;
        }

        .leaderboard-list {
            min-height: 60px;
            /* No max-height - let it size dynamically based on content */
            overflow-y: visible;
        }

        .leaderboard-item {
            margin: 4px 0;
            padding: 8px 12px;
            border-bottom: 1px solid rgba(100, 200, 255, 0.15);
            font-size: 12px;
            background: rgba(15, 25, 40, 0.6);
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
            overflow: hidden;
            min-width: 0;
        }
        
        .leaderboard-item .player-name {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
            min-width: 0;
        }
        
        .leaderboard-item .weight {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex-shrink: 0;
            margin-left: 5px;
        }

        .leaderboard-item:hover {
            background: rgba(30, 50, 80, 0.8);
            transform: translateX(3px);
        }

        .leaderboard-item:first-child {
            color: #ffd700;
            font-weight: bold;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 193, 7, 0.2) 100%);
            border: 1px solid rgba(255, 215, 0, 0.4);
        }

        .leaderboard-item:nth-child(2) {
            color: #c0c0c0;
        }

        .leaderboard-item:nth-child(3) {
            color: #cd7f32;
        }

        .leaderboard-item .rank {
            background: linear-gradient(135deg, #42a5f5 0%, #2196f3 100%);
            color: #000;
            padding: 1px 4px;
            border-radius: 2px;
            font-weight: bold;
            font-size: 9px;
            margin-right: 6px;
        }

        .leaderboard-item .player-name {
            flex: 1;
            color: #64b5f6;
        }

        .leaderboard-item .weight {
            color: #ffff00;
            font-weight: bold;
        }

        .tournament-info {
            background: rgba(20, 30, 50, 0.8);
            padding: 15px;
            border: 2px solid rgba(100, 200, 255, 0.4);
            border-radius: 8px;
            margin-bottom: 10px;
            margin-top: 10px;
            min-height: 80px;
            box-shadow: 0 0 10px rgba(100, 181, 246, 0.3);
        }

        .inventory-tabs {
            display: flex;
            margin-bottom: 20px;
        }

        .inventory-tabs .tab-btn {
            flex: 1;
            padding: 10px;
            background: rgba(30, 50, 80, 0.8);
            border: 1px solid rgba(100, 200, 255, 0.3);
            color: #64b5f6;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }

        .inventory-tabs .tab-btn:first-child {
            border-radius: 4px 0 0 4px;
        }

        .inventory-tabs .tab-btn:last-child {
            border-radius: 0 4px 4px 0;
        }

        .inventory-tabs .tab-btn.active {
            background: linear-gradient(135deg, #42a5f5 0%, #2196f3 100%);
            color: #000;
        }

        .catch-item {
            background: rgba(30, 50, 80, 0.8);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            padding: 10px;
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .fish-name {
            font-weight: bold;
            color: #64b5f6;
            font-size: 16px;
        }

        .fish-details {
            display: flex;
            gap: 15px;
            font-size: 12px;
        }

        .fish-details span {
            color: #64b5f6;
        }

        .weight {
            color: #ffff00 !important;
        }

        .value {
            color: #64b5f6 !important;
        }

        .location {
            color: #00ffff !important;
        }

        .time {
            color: #888 !important;
        }

        .rank {
            background: linear-gradient(135deg, #42a5f5 0%, #2196f3 100%);
            color: #000;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
            margin-right: 10px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .stat-item {
            background: rgba(30, 50, 80, 0.8);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            padding: 15px;
            text-align: center;
        }

        .stat-label {
            color: #64b5f6;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #64b5f6;
            font-size: 18px;
            font-weight: bold;
        }

        .no-data {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 20px;
        }

        .game-status {
            background: rgba(20, 30, 50, 0.8);
            padding: 15px;
            border: 2px solid rgba(100, 200, 255, 0.4);
            border-radius: 8px;
            margin-bottom: 15px;
            box-shadow: 0 0 10px rgba(100, 181, 246, 0.3);
        }

        .status-item {
            margin: 6px 0;
            padding: 4px 0;
            border-bottom: 1px solid rgba(100, 181, 246, 0.2);
            font-size: 12px;
        }

        .status-item span {
            color: #64b5f6;
            font-weight: bold;
        }

        .online-players {
            max-height: 150px;
            overflow-y: auto;
        }

        .player-item {
            padding: 2px 5px;
            margin: 2px 0;
            background: rgba(20, 30, 50, 0.8);
            border-left: 3px solid rgba(100, 200, 255, 0.5);
        }

        .player-item.fishing {
            border-left-color: rgba(100, 181, 246, 0.6);
        }

        .chat-area {
            height: 100px;
            overflow-y: auto;
            background: rgba(15, 25, 40, 0.8);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 10px;
            padding: 8px;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
            flex-shrink: 0;
        }

        .chat-message {
            margin: 3px 0;
            overflow: hidden;
            text-overflow: ellipsis;
            word-wrap: break-word;
            max-width: 100%;
            padding: 4px 8px;
            font-size: 11px;
            line-height: 1.3;
            border-radius: 6px;
            background: rgba(20, 30, 50, 0.5);
        }

        .chat-message.system {
            color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
        }

        .chat-message.own {
            color: #64b5f6;
            background: rgba(100, 181, 246, 0.15);
        }

        .chat-message.other {
            color: #81c784;
            background: rgba(129, 199, 132, 0.1);
        }

        .chat-message.legendary {
            color: #ff00ff;
            font-weight: bold;
            text-shadow: 0 0 5px #ff00ff;
            animation: legendaryGlow 2s infinite;
        }

        .chat-message.rare {
            color: #64b5f6;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(100, 181, 246, 0.8);
        }

        .chat-message.huge {
            color: #ffff00;
            font-weight: bold;
            text-shadow: 0 0 5px #ffff00;
        }

        @keyframes legendaryGlow {
            0%, 100% { text-shadow: 0 0 5px #ff00ff; }
            50% { text-shadow: 0 0 15px #ff00ff, 0 0 25px #ff00ff; }
        }

        .chat-input-container {
            flex-shrink: 0;
            margin-top: auto;
        }

        .chat-input {
            width: 100%;
            background: rgba(15, 25, 40, 0.9);
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            color: #e0e0e0;
            padding: 8px 12px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .chat-input:focus {
            outline: none;
            border-color: rgba(100, 200, 255, 0.6);
            box-shadow: 0 0 10px rgba(100, 200, 255, 0.3);
        }

        .tournament-info {
            background: rgba(20, 30, 50, 0.8);
            border: 1px solid #ffff00;
            padding: 10px;
            margin-bottom: 10px;
        }

        .tournament-info h4 {
            color: #ffff00;
            text-align: center;
            margin-bottom: 5px;
        }

        .tournament-timer {
            text-align: center;
            font-size: 14px;
            color: #ffff00;
        }

        .leaderboard {
            max-height: 200px;
            overflow-y: auto;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 5px;
            margin: 1px 0;
            background: rgba(20, 30, 50, 0.8);
        }

        .leaderboard-item.current {
            background: rgba(15, 25, 40, 0.6);
        }

        .catch-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 25, 40, 0.95);
            border: 2px solid rgba(100, 200, 255, 0.4);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            z-index: 10000;
            display: none;
            box-shadow: 0 0 30px rgba(100, 200, 255, 0.6), 0 8px 32px rgba(0, 0, 0, 0.5);
            color: #ffffff;
            font-weight: 700;
            font-size: 18px;
            pointer-events: none;
        }

        .catch-message.show {
            display: block !important;
            animation: flash 0.5s ease-out;
        }

        @keyframes flash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .hidden {
            display: none;
        }


        .location-selector {
            position: absolute;
            top: 10px;
            right: 10px;
        }

        .location-btn {
            background: rgba(15, 25, 40, 0.9);
            border: 1px solid rgba(100, 200, 255, 0.3);
            color: #64b5f6;
            padding: 5px 10px;
            margin: 2px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 10px;
        }

        .location-btn:hover {
            background: linear-gradient(135deg, #42a5f5 0%, #2196f3 100%);
            color: #000;
        }

        .location-btn.active {
            background: linear-gradient(135deg, #42a5f5 0%, #2196f3 100%);
            color: #000;
        }

        .location-btn.locked {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        .location-dropdown {
            margin: 15px 0;
            padding: 10px;
            background: rgba(20, 30, 50, 0.8);
            border: 2px solid rgba(100, 200, 255, 0.4);
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(100, 181, 246, 0.3);
        }

        .location-dropdown select {
            width: 100%;
            padding: 12px;
            background: rgba(15, 25, 40, 0.9);
            color: #64b5f6;
            border: 2px solid rgba(100, 200, 255, 0.4);
            border-radius: 4px;
            font-size: 16px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            text-align: center;
        }

        .location-dropdown select:hover {
            background: rgba(20, 30, 50, 0.8);
            box-shadow: 0 0 10px rgba(100, 181, 246, 0.5);
        }

        .location-dropdown select option {
            background: rgba(20, 30, 50, 0.8);
            color: #64b5f6;
            padding: 8px;
            font-size: 14px;
        }

        .location-dropdown select option:disabled {
            color: #666;
            background: #222;
            font-style: italic;
        }

        /* Tackle Shop Modal */
        .modal {
            display: none;
            position: fixed !important;
            z-index: 99999 !important; /* Highest priority - always on top */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
        }

        .modal-content {
            background: linear-gradient(135deg, rgba(30, 60, 114, 0.98) 0%, rgba(42, 82, 152, 0.98) 100%);
            margin: 5% auto;
            padding: 0;
            border: 2px solid rgba(100, 200, 255, 0.4);
            border-radius: 16px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6);
            position: relative;
            z-index: 10002; /* Higher than modal background */
        }

        .modal-header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 20px;
            border-bottom: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 16px 16px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            margin: 0;
            color: #ffffff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-weight: 700;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        }

        .close-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: #ffffff;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .modal-body {
            padding: 20px;
        }

        .shop-tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid rgba(100, 200, 255, 0.3);
        }

        .tab-btn {
            background: rgba(20, 30, 50, 0.6);
            color: #e0e0e0;
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            padding: 12px 24px;
            cursor: pointer;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-right: 5px;
        }

        .tab-btn:hover {
            background: rgba(30, 50, 80, 0.8);
            color: #ffffff;
        }

        .tab-btn.active {
            background: linear-gradient(135deg, #42a5f5 0%, #2196f3 100%);
            color: #ffffff;
            border-color: rgba(100, 200, 255, 0.6);
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.4);
        }

        .shop-content {
            min-height: 300px;
        }

        .tackle-item {
            background: rgba(20, 30, 50, 0.8);
            border: 2px solid rgba(100, 200, 255, 0.3);
            margin: 12px 0;
            padding: 18px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tackle-item.equipped {
            border-color: #ffff00;
            background: rgba(30, 50, 80, 0.8);
        }

        .tackle-item.locked {
            border-color: #666;
            background: #333;
            color: #666;
        }

        .tackle-info {
            flex: 1;
        }

        .tackle-name {
            font-weight: bold;
            color: #64b5f6;
            margin-bottom: 5px;
        }

        .tackle-item.locked .tackle-name {
            color: #666;
        }

        .tackle-stats {
            font-size: 12px;
            color: #ccc;
            margin-bottom: 5px;
        }

        .tackle-description {
            font-size: 11px;
            color: #999;
            font-style: italic;
        }

        .tackle-actions {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .tackle-btn {
            background: linear-gradient(135deg, #42a5f5 0%, #2196f3 100%);
            color: #000;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
        }

        .tackle-btn:hover {
            background: #ffff00;
        }

        .tackle-btn:disabled {
            background: #666;
            color: #999;
            cursor: not-allowed;
        }

        .tackle-btn.equip {
            background: #ffff00;
            color: #000;
        }

        .tackle-btn.buy {
            background: linear-gradient(135deg, #42a5f5 0%, #2196f3 100%);
            color: #000;
        }

        /* Banner Ad Containers */
        .ad-container {
            background: rgba(20, 30, 50, 0.8);
            border: 2px solid rgba(100, 200, 255, 0.4);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            color: rgba(200, 200, 200, 0.8);
            font-size: 12px;
            min-height: 90px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .ad-container:hover {
            background: rgba(30, 50, 80, 0.9);
            border-color: rgba(100, 200, 255, 0.6);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(100, 200, 255, 0.3);
        }

        .mock-ad {
            width: 100%;
            height: 100%;
        }
        
        .ad-container-desktop {
            width: 100%;
            max-width: 728px;
            margin: 10px auto;
            min-height: 90px;
        }
        
        .ad-container-mobile {
            width: 100%;
            height: 50px;
            min-height: 50px;
            max-height: 50px;
            margin: 8px 0;
            display: flex;
            align-items: center;
            overflow: hidden;
        }

        /* Help Modal */
        .help-content {
            padding: 20px;
            line-height: 1.6;
            color: #e0e0e0;
        }
        
        .help-content h3 {
            color: #64b5f6;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 18px;
        }
        
        .help-content h4 {
            color: #90caf9;
            margin-top: 15px;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .help-content ul, .help-content ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }
        
        .help-content li {
            margin: 5px 0;
        }
        
        .help-content code {
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #90caf9;
        }
        
        .help-shortcuts {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        
        .shortcut-item {
            background: rgba(15, 25, 40, 0.6);
            padding: 10px;
            border-radius: 6px;
            border-left: 3px solid rgba(100, 200, 255, 0.5);
        }
        
        .shortcut-key {
            font-weight: bold;
            color: #90caf9;
            font-family: 'Courier New', monospace;
        }

        /* Responsive Design */
        @media (max-width: 1400px) {
            .fishing-lake {
                max-width: calc(100vw - 550px);
            }
        }

        @media (max-width: 1200px) {
            .left-sidebar, .right-sidebar {
                width: 200px;
            }
            
            .fishing-lake {
                max-width: calc(100vw - 450px);
            }
        }

        /* Tablet Layout - RESPONSIVE TO BOTH WIDTH AND HEIGHT */
        /* Common tablets: 
           iPad Portrait: 768x1024, iPad Landscape: 1024x768
           Android Portrait: 800x1280, Android Landscape: 1280x800
           iPad Pro Portrait: 1024x1366, iPad Pro Landscape: 1366x1024 */
        
        /* TABLET PORTRAIT - Tall (height > width) */
        @media (min-width: 769px) and (max-width: 1024px) and (min-height: 769px) {
            /* TABLET PORTRAIT MODE (768x1024, 800x1280) - Tall and narrow */
            /* GOAL: Everything must fit on screen without horizontal scroll */
            /* Available space: ~1024px height - 768px typical portrait height */
            
            body {
                overflow-y: auto;
                overflow-x: hidden;
            }
            
            .game-container {
                height: 100vh;
                overflow-y: auto;
            }
            
            .main-area {
                min-height: 100vh;
            }
            
            /* Compact header - 40px */
            .header {
                padding: 8px 15px;
                flex-shrink: 0;
            }
            
            .header h1 {
                font-size: 18px;
            }
            
            /* Layout: Column stack */
            .game-layout {
                flex-direction: column;
                padding-bottom: 0;
            }
            
            /* Sidebars: Horizontal scrollable tabs - 80px */
            .left-sidebar, .right-sidebar {
                width: 100%;
                height: 80px;
                overflow-x: auto;
                overflow-y: hidden;
                padding: 4px;
                display: flex;
                flex-direction: row;
                gap: 6px;
                background: rgba(15, 25, 40, 0.95);
                border-bottom: 2px solid rgba(100, 200, 255, 0.3);
                flex-shrink: 0;
            }
            
            .left-sidebar .section,
            .right-sidebar .section {
                min-width: 160px;
                max-width: 200px;
                padding: 4px;
                margin-bottom: 0;
                flex-shrink: 0;
                background: rgba(20, 30, 50, 0.8);
                border-radius: 4px;
            }
            
            .section h3 {
                font-size: 10px;
                margin-bottom: 2px;
                white-space: nowrap;
            }
            
            .stat-line {
                font-size: 9px;
                margin: 1px 0;
                padding: 0;
                white-space: nowrap;
            }
            
            .player-info {
                padding: 4px;
                font-size: 9px;
            }
            
            /* Lake: Flexible - takes remaining space */
            .fishing-area {
                flex: 1;
                min-height: 300px;
                display: flex;
                flex-direction: column;
                padding-bottom: 220px; /* Space for controls (60) + ad (90) + chat (40) + margin (30) */
            }
            
            .fishing-lake {
                width: calc(100% - 40px);
                flex: 1;
                min-height: 250px;
            }
            
            /* Controls: Fixed bottom - 60px */
            .controls {
                position: fixed;
                bottom: 130px; /* Above chat (40) + ad (90) */
                left: 0;
                right: 0;
                display: flex;
                flex-wrap: wrap;
                gap: 4px;
                padding: 6px;
                background: rgba(20, 30, 50, 0.95);
                border-top: 2px solid rgba(100, 200, 255, 0.3);
                z-index: 140;
                flex-shrink: 0;
            }
            
            .control-btn {
                font-size: 10px;
                padding: 6px 10px;
                min-width: 80px;
                flex: 1;
                max-width: 120px;
            }
            
            /* Chat: Fixed bottom - 40px */
            .chat-section {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                z-index: 150;
            }
            
            .chat-section.expanded {
                height: 150px;
            }
            
            .chat-section.collapsed {
                height: 40px;
            }
            
            /* Ad: Fixed above chat - 90px */
            #desktop-ad-bottom {
                position: fixed;
                bottom: 40px; /* Above collapsed chat */
                left: 0;
                right: 0;
                max-width: 100%;
                margin: 0;
                min-height: 90px;
                z-index: 145;
                background: rgba(20, 30, 50, 0.95);
                border-top: 2px solid rgba(100, 200, 255, 0.3);
            }
            
            /* When chat expanded, ad moves up */
            .chat-section.expanded ~ * #desktop-ad-bottom,
            body:has(.chat-section.expanded) #desktop-ad-bottom {
                bottom: 150px;
            }
            
            /* Adjust controls when chat expanded */
            .chat-section.expanded ~ * .controls,
            body:has(.chat-section.expanded) .controls {
                bottom: 240px; /* Above expanded chat (150) + ad (90) */
            }
            
            /* Compact everything */
            .section {
                padding: 4px;
                margin-bottom: 0;
            }
            
            .achievements {
                max-height: 50px;
                padding: 2px;
                overflow-y: auto;
            }
            
            .achievement-item {
                font-size: 8px;
                padding: 1px 3px;
            }
            
            .leaderboard-list {
                max-height: 50px;
                overflow-y: auto;
            }
            
            .leaderboard-item {
                font-size: 8px;
                padding: 1px 3px;
            }
            
            .online-players {
                max-height: 50px;
                overflow-y: auto;
            }
        }

        /* TABLET LANDSCAPE MODE - Wide and short (width > height) */
        @media (min-width: 769px) and (max-width: 1366px) and (max-height: 768px) and (orientation: landscape) {
            /* Landscape tablets: 1024x768, 1280x800, 1366x1024 */
            /* GOAL: LESS HEIGHT available, must be more compact vertically */
            
            body {
                overflow-y: auto;
                overflow-x: hidden;
            }
            
            .game-container {
                height: 100vh;
                overflow-y: auto;
            }
            
            .main-area {
                min-height: 100vh;
            }
            
            /* LANDSCAPE: Much less height, must be EXTREMELY compact vertically */
            /* Available height: ~768px - must fit: header, layout, chat, ad, controls */
            
            /* Very compact header - 30px */
            .header {
                padding: 5px 15px;
                flex-shrink: 0;
            }
            
            .header h1 {
                font-size: 14px;
            }
            
            /* Layout: Horizontal (side-by-side) to use width */
            .game-layout {
                flex-direction: row;
                padding-bottom: 135px; /* Space for chat + ad + controls */
                gap: 8px;
            }
            
            /* Sidebars: Very compact - 180px wide */
            .left-sidebar, .right-sidebar {
                width: 180px;
                max-width: 180px;
                height: calc(100vh - 165px); /* Full height minus fixed elements */
                overflow-y: auto;
                overflow-x: hidden;
                padding: 4px;
                display: flex;
                flex-direction: column;
                gap: 4px;
                flex-shrink: 0;
            }
            
            .left-sidebar .section,
            .right-sidebar .section {
                width: 100%;
                padding: 4px;
                margin-bottom: 2px;
            }
            
            .section h3 {
                font-size: 10px;
                margin-bottom: 2px;
            }
            
            .stat-line {
                font-size: 9px;
                margin: 1px 0;
                padding: 0;
            }
            
            .player-info {
                padding: 4px;
                font-size: 9px;
            }
            
            /* Lake: Takes remaining horizontal space, full vertical */
            .fishing-area {
                flex: 1;
                height: calc(100vh - 165px); /* Full height minus header/fixed elements */
                display: flex;
                flex-direction: column;
                padding-bottom: 135px;
            }
            
            .fishing-lake {
                width: calc(100% - 40px);
                height: 100%;
                min-height: 400px;
                flex-shrink: 1;
            }
            
            /* Controls: Fixed - 45px */
            .controls {
                position: fixed;
                bottom: 90px; /* Above chat (40) + ad (50) */
                left: 0;
                right: 0;
                display: flex;
                flex-wrap: wrap;
                gap: 4px;
                padding: 5px;
                background: rgba(20, 30, 50, 0.95);
                border-top: 2px solid rgba(100, 200, 255, 0.3);
                z-index: 140;
                flex-shrink: 0;
            }
            
            .control-btn {
                font-size: 10px;
                padding: 6px 10px;
                min-width: 90px;
                flex: 1;
                max-width: 130px;
            }
            
            /* Chat: Very compact - 120px expanded */
            .chat-section {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                z-index: 150;
            }
            
            .chat-section.expanded {
                height: 120px;
            }
            
            .chat-section.collapsed {
                height: 35px;
            }
            
            /* Ad: Very small in landscape - 50px */
            #desktop-ad-bottom {
                position: fixed;
                bottom: 35px; /* Above collapsed chat */
                left: 0;
                right: 0;
                max-width: 100%;
                margin: 0;
                min-height: 50px;
                max-height: 50px;
                z-index: 145;
                background: rgba(20, 30, 50, 0.95);
                border-top: 2px solid rgba(100, 200, 255, 0.3);
            }
            
            /* When chat expanded, ad moves up */
            .chat-section.expanded ~ * #desktop-ad-bottom,
            body:has(.chat-section.expanded) #desktop-ad-bottom {
                bottom: 120px;
            }
            
            /* Adjust controls when chat expanded */
            .chat-section.expanded ~ * .controls,
            body:has(.chat-section.expanded) .controls {
                bottom: 170px; /* Above expanded chat (120) + ad (50) */
            }
            
            /* Compact sections */
            .section {
                padding: 4px;
                margin-bottom: 2px;
            }
            
            .achievements {
                max-height: 60px;
                padding: 2px;
                overflow-y: auto;
            }
            
            .achievement-item {
                font-size: 8px;
                padding: 1px 3px;
            }
            
            .leaderboard-list {
                max-height: 60px;
                overflow-y: auto;
            }
            
            .leaderboard-item {
                font-size: 8px;
                padding: 1px 3px;
            }
            
            .online-players {
                max-height: 60px;
                overflow-y: auto;
            }
            
            /* Compact chat area */
            .chat-area {
                height: 70px;
                padding: 4px;
            }
            
            .chat-message {
                font-size: 9px;
                margin: 1px 0;
                padding: 2px 4px;
            }
        }

        @media (max-width: 992px) {
            .game-layout {
                flex-direction: column;
            }
            
            .left-sidebar, .right-sidebar {
                width: 100%;
                max-height: 200px;
            }
            
            .fishing-lake {
                max-width: 100%;
                width: calc(100% - 40px);
            }
        }

        @media (max-height: 800px) {
            .fishing-lake {
                height: calc(100vh - 250px);
                min-height: 300px;
            }
        }

        /* Mobile Layout - Completely Different */
        @media (max-width: 768px) {
            /* Hide desktop layout completely */
            .game-layout {
                display: none !important;
            }

            /* Show mobile layout */
            .mobile-game-layout {
                display: flex !important;
            }

            /* Hide header on mobile since we have mobile header */
            .header {
                display: none;
            }

            /* Hide desktop chat section on mobile */
            .chat-section {
                display: none !important;
            }

            /* Ensure catch message is visible on mobile */
            .catch-message {
                z-index: 10000 !important;
                font-size: 16px;
                padding: 15px;
                max-width: 90%;
                border-radius: 10px;
                display: none !important;
            }
            
            .catch-message.show {
                display: block !important;
            }

            /* Mobile-specific simplified layout */
            .mobile-game-layout {
                display: flex;
                flex-direction: column;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                height: 100vh;
                overflow-y: auto;
                overflow-x: hidden;
                z-index: 1; /* Low z-index so modals appear above */
            }

            .mobile-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 8px;
                background: rgba(20, 30, 50, 0.8);
                border-bottom: 2px solid rgba(100, 200, 255, 0.4);
                flex-shrink: 0;
                position: sticky;
                top: 72px;
                z-index: 99;
            }

            .mobile-header-left {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }

            .mobile-header-name {
                font-size: 14px;
                font-weight: bold;
                word-wrap: break-word;
                max-width: 120px;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .mobile-header-stats {
                font-size: 10px;
                color: #64b5f6;
            }

            .mobile-header-right {
                display: flex;
                flex-direction: column;
                gap: 4px;
                text-align: right;
            }

            .mobile-game-area {
                flex: 1;
                display: flex;
                flex-direction: column;
                overflow-y: auto;
            }

            .mobile-fisherman-row {
                display: flex;
                justify-content: space-around;
                width: 100%;
                margin-bottom: 10px;
            }

            .mobile-fisherman {
                width: 40px;
                height: 50px;
                font-size: 28px;
                border-radius: 50%;
                border: 2px solid rgba(100, 200, 255, 0.4);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                background: linear-gradient(135deg, #2c3e50 0%, #34495e 50%, #2c3e50 100%);
            }

            .mobile-fisherman-character {
                font-size: 30px;
                line-height: 1;
            }

            .mobile-fisherman-name {
                font-size: 6px;
                margin-top: 2px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                max-width: 35px;
                background: rgba(0, 0, 0, 0.95);
                padding: 1px 3px;
                border-radius: 2px;
                border: 1px solid rgba(100, 200, 255, 0.3);
                color: #64b5f6;
                font-weight: bold;
            }

            .mobile-fishing-lake {
                width: 100%;
                height: calc(100vh - 550px); /* Adjust for header (~60px), tabs (~40px), fisherman row (~30px), location dropdown (~70px), controls (~64px), ad (~66px), padding (~20px) */
                min-height: 120px;
                max-height: calc(100vh - 550px);
                background: linear-gradient(135deg, #1e3a5f 0%, #4a90e2 50%, #1e3a5f 100%);
                border-radius: 15px;
                border: 2px solid rgba(100, 200, 255, 0.4);
                position: relative;
                overflow: visible;
                z-index: 1; /* Low z-index so modals appear above */
                box-shadow: 
                    0 0 30px rgba(100, 181, 246, 0.3),
                    inset 0 0 50px rgba(0, 0, 0, 0.2);
            }

            .mobile-fishing-lake .fishing-line {
                position: absolute;
                width: 2px;
                background: #ffffff;
                z-index: 10;
            }

            .mobile-fishing-lake .hook {
                position: absolute;
                top: calc(100% - 18px);
                left: 50%;
                width: 18px;
                height: 22px;
                transform: translateX(-50%);
                
                /* Realistic red and white bobber */
                border-radius: 50%;
                border: 2px solid rgba(0, 0, 0, 0.1);
                
                background: 
                    radial-gradient(circle at 40% 35%, rgba(255, 255, 255, 0.6) 0%, transparent 50%),
                    linear-gradient(to bottom,
                        #ff3333 0%,
                        #ff3333 20%,
                        #ff0000 25%,
                        #ff0000 45%,
                        #ffffff 45%,
                        #ffffff 55%,
                        #ff0000 55%,
                        #ff0000 100%
                    );
                
                box-shadow: 
                    0 3px 8px rgba(0, 0, 0, 0.4),
                    inset 0 3px 6px rgba(255, 255, 255, 0.4),
                    inset 0 -6px 8px rgba(0, 0, 0, 0.2);
                z-index: 10;
            }
            
            .mobile-fishing-lake .hook::before {
                content: '';
                position: absolute;
                top: -5px;
                left: 50%;
                transform: translateX(-50%);
                width: 2px;
                height: 8px;
                background: linear-gradient(to bottom, #ffffff 0%, #e0e0e0 100%);
                border-radius: 2px;
                box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            }

            .mobile-controls {
                position: fixed;
                bottom: 100px; /* Above the ad bar with more space (50px ad + 16px padding + 34px buffer) */
                left: 0;
                right: 0;
                display: grid;
                grid-template-columns: 1fr 1fr 1fr;
                gap: 4px;
                padding: 8px;
                background: rgba(15, 25, 40, 0.95);
                border-top: 1px solid rgba(100, 200, 255, 0.3);
                z-index: 1000; /* Higher than ad bar (999) to ensure visibility */
                box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.3);
            }
            
            .mobile-sound-toggle {
                transition: all 0.3s ease;
            }
            
            .mobile-sound-toggle:active {
                transform: scale(0.9);
                background: rgba(100, 200, 255, 0.4) !important;
            }

            .mobile-btn {
                padding: 10px 4px;
                background: rgba(20, 30, 50, 0.8);
                border: 2px solid rgba(100, 200, 255, 0.4);
                color: #64b5f6;
                font-size: 10px;
                font-weight: bold;
                cursor: pointer;
                border-radius: 6px;
                transition: all 0.3s ease;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                min-width: 0;
                text-align: center;
            }

            .mobile-btn:active {
                background: linear-gradient(135deg, #42a5f5 0%, #2196f3 100%);
                color: #000;
            }

            .mobile-info-panels {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            .mobile-panel {
                background: rgba(20, 30, 50, 0.8);
                border: 2px solid rgba(100, 200, 255, 0.4);
                border-radius: 8px;
                padding: 10px;
            }

            .mobile-panel h4 {
                font-size: 12px;
                margin-bottom: 8px;
                color: #64b5f6;
                border-bottom: 1px solid rgba(100, 200, 255, 0.3);
                padding-bottom: 4px;
            }

            .mobile-stats-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 5px;
                font-size: 10px;
            }

            .mobile-chat-section {
                position: fixed;
                bottom: 60px;
                left: 0;
                right: 0;
                background: rgba(0, 0, 0, 0.95);
                border-top: 2px solid rgba(100, 200, 255, 0.4);
                padding: 5px;
                max-height: 100px;
                display: flex;
                flex-direction: column;
            }

            .mobile-chat-input {
                display: flex;
                gap: 5px;
            }

            .mobile-chat-input input {
                flex: 1;
                padding: 6px;
                background: rgba(15, 25, 40, 0.9);
                border: 1px solid rgba(100, 200, 255, 0.3);
                color: #64b5f6;
                font-size: 12px;
            }

            .mobile-menu-bar {
                position: fixed !important;
                bottom: 0 !important;
                left: 0 !important;
                right: 0 !important;
                display: flex;
                background: rgba(15, 25, 40, 0.95);
                border-top: 1px solid rgba(100, 200, 255, 0.3);
                padding: 8px;
                flex-shrink: 0;
                z-index: 999 !important; /* Static ad bar, never changes */
                pointer-events: none; /* Allow clicks to pass through to content below */
            }
            
            .mobile-menu-bar .ad-container {
                pointer-events: auto; /* But allow clicks on the ad itself */
            }

            .mobile-menu-btn {
                flex: 1;
                padding: 10px;
                background: rgba(20, 30, 50, 0.8);
                border: 2px solid rgba(100, 200, 255, 0.4);
                color: #64b5f6;
                font-size: 11px;
                font-weight: bold;
                cursor: pointer;
                border-radius: 5px;
            }

            .mobile-menu-btn:active {
                background: linear-gradient(135deg, #42a5f5 0%, #2196f3 100%);
                color: #000;
            }

            /* Mobile Title */
            .mobile-title {
                padding: 8px;
                background: rgba(20, 30, 50, 0.8);
                border-bottom: 2px solid rgba(100, 200, 255, 0.4);
                text-align: center;
                font-size: 14px;
                font-weight: bold;
                color: #64b5f6;
                flex-shrink: 0;
                position: sticky;
                top: 0;
                z-index: 101;
            }

            /* Mobile Tabs */
            .mobile-tabs {
                display: flex;
                background: rgba(20, 30, 50, 0.8);
                border-bottom: 2px solid rgba(100, 200, 255, 0.4);
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                flex-shrink: 0;
                position: sticky;
                top: 32px;
                z-index: 100;
            }

            .mobile-tab-btn {
                flex: 1;
                padding: 8px 4px;
                background: rgba(20, 30, 50, 0.8);
                border: none;
                border-right: 1px solid rgba(100, 200, 255, 0.3);
                color: #64b5f6;
                font-size: 9px;
                font-weight: bold;
                cursor: pointer;
                white-space: nowrap;
            }

            .mobile-tab-btn:last-child {
                border-right: none;
            }

            .mobile-tab-btn.active {
                background: linear-gradient(135deg, #42a5f5 0%, #2196f3 100%);
                color: #000;
            }

            .mobile-tab-btn:active {
                background: #00aa00;
            }

            .mobile-tab-content {
                flex: 1;
                overflow-y: auto;
                overflow-x: hidden;
                padding: 10px;
                min-height: 0;
                padding-bottom: 180px; /* Space for location dropdown (~60px) + controls (~64px) + ad (~66px) */
                margin-bottom: 0;
                position: relative;
                z-index: 1; /* Ensure tab content stays below modals */
            }

            .mobile-tab-panel {
                display: none;
            }

            .mobile-tab-panel.active {
                display: block;
            }

            .mobile-fishing-area {
                margin-bottom: 0;
                display: flex;
                flex-direction: column;
                gap: 10px;
            }
            
            .mobile-fishing-area .location-dropdown {
                margin: 0;
                padding: 8px;
                order: 3; /* Location dropdown after lake */
                position: relative;
                z-index: 2; /* Above lake but below controls */
            }

            .mobile-controls {
                grid-template-columns: 1fr 1fr 1fr;
            }

            /* Fix shop tabs on mobile */
            .shop-tabs {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: thin;
            }

            .shop-tabs::-webkit-scrollbar {
                height: 5px;
            }

            .shop-tabs::-webkit-scrollbar-track {
                background: rgba(20, 30, 50, 0.8);
            }

            .shop-tabs::-webkit-scrollbar-thumb {
                background: linear-gradient(135deg, #42a5f5 0%, #2196f3 100%);
                border-radius: 5px;
            }

            .tab-btn {
                flex-shrink: 0;
                padding: 8px 10px;
                font-size: 10px;
                white-space: nowrap;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="main-area">
            <div class="header">
                <h1>KITTY CREEK FISHING CLUB</h1>
            </div>

            <div class="game-layout">
                <!-- Left Sidebar -->
                <div class="left-sidebar">
                    <div class="section">
                        <h3>PLAYER INFO</h3>
                        <div class="player-info" id="player-info">
                            <div class="stat-line">Name: <span id="player-name">Guest</span></div>
                            <div class="stat-line">Level: <span id="player-level">1</span></div>
                            <div class="stat-line">Exp: <span id="player-exp">0</span> / <span id="next-level-exp">100</span></div>
                            <div class="stat-line">Money: $<span id="player-money">100</span></div>
                            <div class="stat-line">Fish: <span id="fish-caught">0</span></div>
                            <div class="stat-line">Weight: <span id="total-weight">0</span> lbs</div>
                        </div>
                    </div>

                    <div class="section">
                        <h3>PLAYER STATS</h3>
                        <div class="player-stats" id="player-stats">
                            <div class="stat-line">Accuracy: <span id="stat-accuracy">50</span>/100</div>
                            <div class="stat-line">Luck: <span id="stat-luck">50</span>/100</div>
                            <div class="stat-line">Patience: <span id="stat-patience">50</span>/100</div>
                            <div class="stat-line">Strength: <span id="stat-strength">50</span>/100</div>
                        </div>
                    </div>

                    <div class="section">
                        <h3>ACHIEVEMENTS</h3>
                        <div class="achievements" id="achievements">
                            <div class="achievement-item">üé£ Novice Angler</div>
                            <div class="achievement-item locked">üêü Big Fish Hunter</div>
                            <div class="achievement-item locked">üíé Rare Collector</div>
                        </div>
                    </div>
                </div>

                <!-- Center Game Area -->
                <div class="center-area">
                    <div class="fishing-area">
                        <!-- Side-by-side layout: Player cat on left, lake on right -->
                        <div class="fishing-game-layout">
                            <div class="player-cat-side">
                                <div class="fisherman-row" id="fisherman-row">
                                    <!-- Fishermen will be added here -->
                                </div>
                            </div>
                            <div class="lake-side">
                                <div class="fishing-lake" id="fishing-lake">
                                    <div class="ripples" id="ripples"></div>
                                    <div id="caustics-layer" aria-hidden="true"></div>
                                    <!-- Realistic splash canvas (drawn above water surface) -->
                                    <canvas id="splash-canvas" aria-hidden="true"></canvas>
                                </div>
                            </div>
                        </div>

                        <div class="location-dropdown">
                            <select id="location-select" onchange="game.changeLocation(this.value)">
                                <!-- Locations will be dynamically added here -->
                            </select>
                        </div>
                    </div>

                    <div class="controls">
                        <button class="btn" id="cast-btn">CAST LINE</button>
                        <button class="btn" id="shop-btn">TACKLE SHOP</button>
                        <button class="btn" id="tournament-btn">TOURNAMENT</button>
                        <button class="btn" id="inventory-btn">INVENTORY</button>
                        <button class="btn" id="help-btn">‚ùì HELP</button>
                        <button class="btn" id="sound-btn">üîä SOUND ON</button>
                    </div>
                    
                    <!-- Banner Ad - Desktop Bottom -->
                    <div class="ad-container ad-container-desktop" id="desktop-ad-bottom">
                        <!-- Mock Ad for Testing -->
                        <a href="#" class="mock-ad" onclick="event.preventDefault(); game.handleAdClick('desktop-bottom'); return false;" style="display: block; text-decoration: none; color: inherit;">
                            <div style="display: flex; align-items: center; justify-content: center; gap: 10px; padding: 5px;">
                                <div style="background: linear-gradient(135deg, #42a5f5, #2196f3); color: white; padding: 8px 16px; border-radius: 6px; font-weight: bold; font-size: 14px;">
                                    üé£ Premium Fishing Gear
                                </div>
                                <div style="font-size: 11px; color: rgba(200,200,200,0.8);">
                                    Click to Test Ad ‚Üí Best Rods & Reels
                                </div>
                            </div>
                        </a>
                    </div>
                </div>

                <!-- Right Sidebar -->
                <div class="right-sidebar">
                    <div class="section">
                        <h3>ONLINE PLAYERS</h3>
                        <div class="online-players" id="online-players">
                            <!-- Players will be added here -->
                        </div>
                    </div>

                    <div class="section">
                        <h3>LEADERBOARD</h3>
                        <div class="leaderboard" id="leaderboard">
                            <div class="leaderboard-category">
                                <h4>üèÜ BIGGEST FISH</h4>
                                <div class="leaderboard-list" id="biggest-fish-leaderboard">
                                    <div class="leaderboard-item">Loading...</div>
                                </div>
                            </div>
                            <div class="leaderboard-category">
                                <h4>üé£ BIGGEST BAGS</h4>
                                <div class="leaderboard-list" id="biggest-bags-leaderboard">
                                    <div class="leaderboard-item">Loading...</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="section">
                        <h3>TOURNAMENT INFO</h3>
                        <div class="tournament-info" id="tournament-info">
                            <div>No active tournament</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Chat Section -->
            <div class="chat-section collapsed" id="chat-section">
                <button class="chat-toggle" id="chat-toggle">
                    <span class="chat-toggle-icon">üí¨</span>
                    <span>Chat</span>
                </button>
                <div class="chat-content">
                    <div class="chat-area" id="chat-area">
                        <div class="chat-message system">Welcome to Kitty Creek Fishing Club! üê±üé£</div>
                    </div>
                    <div class="chat-input-container">
                        <input type="text" id="chat-input" placeholder="Type a message...">
                    </div>
                </div>
            </div>

        </div>

        <!-- Catch message (must be outside both layouts to work on mobile) -->
        <div class="catch-message" id="catch-message">
            <div id="catch-text"></div>
        </div>

        <!-- Mobile Layout (hidden by default, shown on mobile via CSS) -->
        <div class="mobile-game-layout" id="mobile-game-layout" style="display: none;">
        <!-- Game Title - At the very top -->
        <div class="mobile-title">
            üê± KITTY CREEK FISHING CLUB üé£
        </div>
        
        <!-- Mobile Tab Navigation -->
        <div class="mobile-tabs">
            <button class="mobile-tab-btn active" data-tab="gameplay">üé£ FISH</button>
            <button class="mobile-tab-btn" data-tab="stats">üìä STATS</button>
            <button class="mobile-tab-btn" data-tab="inventory">üéí INV</button>
            <button class="mobile-tab-btn" data-tab="collection">üêü COLLECT</button>
            <button class="mobile-tab-btn" data-tab="leaderboard">üèÜ LEADER</button>
        </div>

        <div class="mobile-header">
            <div class="mobile-header-left">
                <div class="mobile-header-name" id="mobile-player-name">Guest</div>
                <div class="mobile-header-stats">Level <span id="mobile-player-level">1</span> | $<span id="mobile-player-money">100</span></div>
            </div>
            <div class="mobile-header-right">
                <div style="display: flex; align-items: center; gap: 8px;">
                    <button class="mobile-sound-toggle" id="mobile-sound-btn" style="background: rgba(100, 200, 255, 0.2); border: 1px solid rgba(100, 200, 255, 0.4); border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 16px; padding: 0;">üîä</button>
                    <div style="display: flex; flex-direction: column; gap: 2px;">
                        <div>Exp: <span id="mobile-player-exp">0</span>/<span id="mobile-next-exp">100</span></div>
                        <div><span id="mobile-fish-count">0</span> fish | <span id="mobile-total-weight">0</span> lbs</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Mobile Tab Content -->
        <div class="mobile-tab-content">
            <!-- Gameplay Tab -->
            <div class="mobile-tab-panel active" id="mobile-tab-gameplay">
                <div class="mobile-fishing-area">
                    <div class="mobile-fisherman-row" id="mobile-fisherman-row">
                        <!-- Fishermen will be added here -->
                    </div>
                    <div class="mobile-fishing-lake" id="mobile-fishing-lake">
                        <div class="ripples" id="mobile-ripples"></div>
                        <div id="mobile-caustics-layer" aria-hidden="true"></div>
                        <!-- Realistic splash canvas (drawn above water surface) -->
                        <canvas id="mobile-splash-canvas" aria-hidden="true"></canvas>
                    </div>
                    <div class="location-dropdown" style="background: rgba(20, 30, 50, 0.95); border: 2px solid rgba(100, 200, 255, 0.4); border-radius: 8px; padding: 8px; margin-top: 8px;">
                        <select id="mobile-location-select" onchange="game.changeLocation(this.value)" style="width: 100%; padding: 10px; background: rgba(15, 25, 40, 0.9); color: #64b5f6; border: 2px solid rgba(100, 200, 255, 0.4); border-radius: 6px; font-size: 12px;">
                            <!-- Locations will be dynamically added here -->
                        </select>
                    </div>
                </div>

                <!-- Tournament Timer Banner (shown during active tournaments) -->
                <div id="mobile-tournament-banner" style="display: none; background: rgba(100,200,255,0.2); border: 2px solid rgba(100,200,255,0.4); border-radius: 12px; padding: 12px; margin: 10px; text-align: center; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">
                    <div style="color: #ffffff; font-weight: bold; font-size: 14px; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">üê± TOURNAMENT ACTIVE</div>
                    <div id="mobile-tournament-timer" style="font-size: 18px; font-weight: bold; color: #ffff00; margin-top: 5px;">0:00</div>
                </div>

                <div class="mobile-controls">
                    <button class="mobile-btn" id="mobile-cast-btn">CAST</button>
                    <button class="mobile-btn" id="mobile-shop-btn">SHOP</button>
                    <button class="mobile-btn" id="mobile-tournament-btn">TOURNY</button>
                </div>
            </div>

            <!-- Stats Tab -->
            <div class="mobile-tab-panel" id="mobile-tab-stats">
                <div class="mobile-panel">
                    <h4>PLAYER STATS</h4>
                    <div class="mobile-stats-grid">
                        <div>Accuracy: <span id="mobile-stat-accuracy">50</span></div>
                        <div>Luck: <span id="mobile-stat-luck">50</span></div>
                        <div>Patience: <span id="mobile-stat-patience">50</span></div>
                        <div>Strength: <span id="mobile-stat-strength">50</span></div>
                    </div>
                </div>
                <div class="mobile-panel">
                    <h4>ACHIEVEMENTS</h4>
                    <div class="achievements" id="mobile-achievements"></div>
                </div>
                <div class="mobile-panel">
                    <h4>CHARACTER INFO</h4>
                    <div style="font-size: 10px; margin: 10px 0;">
                        <div style="text-align: center; margin-bottom: 10px;">
                            <img id="mobile-character-display-img" src="" alt="Character" style="width: 60px; height: 60px; border-radius: 50%; border: 2px solid rgba(100,200,255,0.5); box-shadow: 0 2px 8px rgba(0,0,0,0.3);">
                        </div>
                        <div style="display: flex; gap: 5px; flex-direction: column; margin-top: 10px;">
                            <button class="mobile-btn" onclick="game.changeCharacter()" style="background: linear-gradient(135deg, #42a5f5 0%, #2196f3 100%); border-color: rgba(100,200,255,0.5); color: #ffffff; font-size: 10px; padding: 8px; border-radius: 8px; box-shadow: 0 2px 8px rgba(33,150,243,0.3);">üê± CHANGE CHARACTER</button>
                            <button class="mobile-btn" onclick="game.resetCharacter()" style="background: #330000; border-color: #ff0000; color: #ff0000; font-size: 10px; padding: 8px;">RESET CHARACTER</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Inventory Tab -->
            <div class="mobile-tab-panel" id="mobile-tab-inventory">
                <div class="mobile-panel">
                    <h4>EQUIPPED GEAR</h4>
                    <div id="mobile-equipped-gear" style="font-size: 11px; line-height: 1.6;"></div>
                </div>
                <div class="mobile-panel" style="margin-top: 15px;">
                    <h4>RECENT CATCHES</h4>
                    <div id="mobile-recent-catches" style="font-size: 10px;"></div>
                </div>
            </div>

            <!-- Collection Tab -->
            <div class="mobile-tab-panel" id="mobile-tab-collection">
                <div class="mobile-panel">
                    <h4>FISH COLLECTION</h4>
                    <div id="fish-collection-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); gap: 8px; padding: 10px;"></div>
                </div>
            </div>

            <!-- Leaderboard Tab -->
            <div class="mobile-tab-panel" id="mobile-tab-leaderboard">
                <div class="mobile-panel">
                    <h4>BIGGEST FISH</h4>
                    <div id="mobile-biggest-fish-leaderboard" style="font-size: 10px;"></div>
                </div>
                <div class="mobile-panel">
                    <h4>BIGGEST BAGS</h4>
                    <div id="mobile-biggest-bags-leaderboard" style="font-size: 10px;"></div>
                </div>
                <div class="mobile-panel">
                    <h4>TOURNAMENT STATS</h4>
                    <div id="mobile-tournament-stats" style="font-size: 10px;"></div>
                </div>
                <div class="mobile-panel" style="margin-top: 10px;">
                    <h4>‚ùì HELP & GUIDE</h4>
                    <div style="font-size: 11px; max-height: 400px; overflow-y: auto; padding: 8px; background: rgba(15, 25, 40, 0.5); border-radius: 8px;">
                        <p><strong>üê± Welcome to Kitty Creek Fishing Club!</strong></p>
                        <p>Compete with other fisher-cats in real-time tournaments, catch legendary fish, and become the purrfect angler!</p>
                        
                        <p style="margin-top: 8px;"><strong>üéÆ How to Play:</strong></p>
                        <ol style="margin: 5px 0; padding-left: 20px;">
                            <li>Click CAST to throw your line</li>
                            <li>Watch for water ripples</li>
                            <li>Reel in quickly to catch fish</li>
                            <li>Buy better gear in the Shop</li>
                            <li>Join tournaments to compete!</li>
                        </ol>
                        
                        <p style="margin-top: 8px;"><strong>‚å®Ô∏è Keyboard Shortcuts:</strong></p>
                        <div style="margin: 5px 0;">
                            <div>Space - Cast/Reel</div>
                            <div>S - Open Shop</div>
                            <div>T - Join Tournament</div>
                            <div>I - View Inventory</div>
                        </div>
                        
                        <p style="margin-top: 8px;"><strong>üí° Tips:</strong></p>
                        <ul style="margin: 5px 0; padding-left: 20px;">
                            <li>Better gear = Better fish</li>
                            <li>Location affects fish types</li>
                            <li>Fish fast during tournaments</li>
                            <li>Auto-save every 30 seconds</li>
                        </ul>
                        
                        <p style="margin-top: 8px;"><strong>üêü Fish Rarities:</strong></p>
                        <div style="margin: 5px 0;">
                            <div>Common - Easy catches</div>
                            <div>Rare - Special fish</div>
                            <div>Huge - Large fish</div>
                            <div>Legendary - Extremely rare!</div>
                            <div>Trophy - Ultimate prize!</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Mobile Ad Bar (replaces old menu bar) -->
        <div class="mobile-menu-bar" style="padding: 8px;">
            <div class="ad-container ad-container-mobile" id="mobile-ad-bottom" style="margin: 0; height: 50px;">
                <!-- Mock Ad for Testing -->
                <a href="#" class="mock-ad" onclick="event.preventDefault(); game.handleAdClick('mobile-bottom'); return false;" style="display: block; text-decoration: none; color: inherit; height: 100%;">
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; gap: 8px;">
                        <div style="background: linear-gradient(135deg, #42a5f5, #2196f3); color: white; padding: 6px 12px; border-radius: 6px; font-weight: bold; font-size: 11px;">
                            üê± Upgrades
                        </div>
                        <div style="font-size: 9px; color: rgba(200,200,200,0.8);">
                            Tap to Test
                        </div>
                    </div>
                </a>
            </div>
        </div>
        </div>

        <!-- Modals - Outside mobile-game-layout to ensure proper z-index stacking -->
        <!-- Tackle Shop Modal -->
        <div class="modal" id="tackle-shop-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>üé£ TACKLE SHOP</h2>
                    <button class="close-btn" id="close-shop">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="shop-tabs">
                        <button class="tab-btn active" data-tab="rods">RODS</button>
                        <button class="tab-btn" data-tab="reels">REELS</button>
                        <button class="tab-btn" data-tab="lines">LINES</button>
                        <button class="tab-btn" data-tab="hooks">HOOKS</button>
                        <button class="tab-btn" data-tab="baits">BAITS</button>
                    </div>
                    <div class="shop-content" id="shop-content"></div>
                </div>
            </div>
        </div>

        <!-- Inventory Modal -->
        <div class="modal" id="inventory-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>üéí INVENTORY</h2>
                    <button class="close-btn" id="close-inventory">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="inventory-tabs">
                        <button class="tab-btn active" data-tab="recent">RECENT CATCHES</button>
                        <button class="tab-btn" data-tab="top10">TOP 10 BIGGEST</button>
                        <button class="tab-btn" data-tab="gear">EQUIPPED GEAR</button>
                    </div>
                    <div id="inventory-content"></div>
                </div>
            </div>
        </div>

        <!-- Help Modal -->
        <div class="modal" id="help-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>‚ùì HELP & GUIDE</h2>
                    <button class="close-btn" id="close-help">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="help-content">
                        <h3>üê± Welcome to Kitty Creek Fishing Club!</h3>
                        <p>Compete with other fisher-cats in real-time tournaments, catch legendary fish, and become the purrfect angler!</p>
                        
                        <h3>üéÆ How to Play</h3>
                        <ol>
                            <li><strong>Cast Your Line:</strong> Click the CAST button or press Spacebar to throw your line into the water</li>
                            <li><strong>Wait for a Bite:</strong> Watch the water for ripples - when you see movement, reel in quickly!</li>
                            <li><strong>Catch Fish:</strong> Reel in before the fish gets away</li>
                            <li><strong>Upgrade Gear:</strong> Visit the Shop to buy better rods, reels, and tackle</li>
                            <li><strong>Level Up:</strong> Gain experience to unlock new locations and tackle</li>
                            <li><strong>Join Tournaments:</strong> Compete with other players for prizes!</li>
                        </ol>
                        
                        <h3>‚å®Ô∏è Keyboard Shortcuts</h3>
                        <div class="help-shortcuts">
                            <div class="shortcut-item">
                                <span class="shortcut-key">Space</span> - Cast line / Reel in
                            </div>
                            <div class="shortcut-item">
                                <span class="shortcut-key">S</span> - Open Tackle Shop
                            </div>
                            <div class="shortcut-item">
                                <span class="shortcut-key">T</span> - Join Tournament
                            </div>
                            <div class="shortcut-item">
                                <span class="shortcut-key">I</span> - View Inventory
                            </div>
                            <div class="shortcut-item">
                                <span class="shortcut-key">H</span> - Open Help
                            </div>
                        </div>
                        
                        <h3>üí° Tips & Hints</h3>
                        <ul>
                            <li><strong>Better Gear = Better Fish:</strong> Upgrade your rod, reel, and tackle to catch rare fish</li>
                            <li><strong>Location Matters:</strong> Different locations have different fish types and rarities</li>
                            <li><strong>Tournament Strategy:</strong> Fish as fast as possible during tournaments - biggest total weight wins!</li>
                            <li><strong>Auto-Save:</strong> The game automatically saves your progress every 30 seconds</li>
                            <li><strong>Big Catches:</strong> Rare, Huge, Legendary, and Trophy fish broadcast to all players!</li>
                        </ul>
                        
                        <h3>üèÜ Tournament Rules</h3>
                        <ul>
                            <li>Tournaments run for a set time period</li>
                            <li>Total weight of all catches determines the winner</li>
                            <li>Bigger fish = more weight = better chance to win!</li>
                            <li>Check the leaderboard to see how you rank</li>
                        </ul>
                        
                        <h3>üêü Fish Rarities</h3>
                        <ul>
                            <li><strong>Common:</strong> Easy to catch, lower value</li>
                            <li><strong>Uncommon:</strong> Regular fish, moderate value</li>
                            <li><strong>Rare:</strong> Special fish with higher value</li>
                            <li><strong>Huge:</strong> Large fish, excellent weight</li>
                            <li><strong>Legendary:</strong> Extremely rare catches!</li>
                            <li><strong>Trophy:</strong> The ultimate prize fish!</li>
                        </ul>
                        
                        <h3>üí¨ Chat Rules</h3>
                        <ul>
                            <li>Be respectful to other players</li>
                            <li>No spamming or inappropriate content</li>
                            <li>Have fun and happy fishing!</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <div class="login-screen" id="login-screen">
        <div class="login-box">
            <h2>KITTY CREEK FISHING CLUB</h2>
            <input type="text" class="login-input" id="player-name-input" placeholder="Enter your username..." value="">
            <br>
            <div style="margin: 15px 0;">
                <label style="color: #ffffff; display: block; margin-bottom: 8px; font-weight: 600;">Customize Your Character:</label>
                
                <!-- Character Preview -->
                <div style="text-align: center; margin: 15px 0; min-height: 120px; background: rgba(20,30,50,0.8); border: 2px solid rgba(100,200,255,0.4); border-radius: 12px; padding: 15px; display: flex; flex-direction: column; align-items: center; justify-content: center; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">
                    <div id="character-preview-container" style="display: flex; justify-content: center; margin-bottom: 8px;">
                        <div id="character-preview-avatar" class="cat3d" style="width: 80px; height: 80px;" data-player-id="preview" data-cat3d="preview"></div>
                        <div id="character-preview-avatar-2d" class="cat-rig" style="width: 80px; height: 80px; display: none;" data-player-id="preview"></div>
                    </div>
                    <div style="color: #ffffff; font-size: 11px; font-weight: 600;">Your Fishing Cat üê±</div>
                </div>
                
                <!-- Quick Actions -->
                <div style="margin-bottom: 10px;">
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button id="randomize-cat-btn" style="background: linear-gradient(135deg, #42a5f5 0%, #2196f3 100%); color: #ffffff; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px; box-shadow: 0 3px 10px rgba(33,150,243,0.3); transition: all 0.3s ease;">üé≤ Randomize Cat</button>
                    </div>
                </div>

                <!-- Cat Customization Editor -->
                <div id="cat-editor" style="background: rgba(20, 30, 50, 0.9); border: 2px solid rgba(100, 200, 255, 0.4); border-radius: 12px; padding: 15px; margin-top: 15px; display: none;">
                    <h3 style="color: #64b5f6; font-size: 16px; margin: 0 0 12px 0; text-align: center;">üé® Customize Your Cat</h3>
                    
                    <!-- Color Customization -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">
                        <label style="color: #fff; font-size: 11px; display: flex; align-items: center; gap: 6px;">
                            <span>Fur</span>
                            <input id="furColor" type="color" value="#f2a65a" style="width: 30px; height: 20px; border: none; border-radius: 4px; cursor: pointer;">
                        </label>
                        <label style="color: #fff; font-size: 11px; display: flex; align-items: center; gap: 6px;">
                            <span>Pattern</span>
                            <input id="patColor" type="color" value="#d77f3f" style="width: 30px; height: 20px; border: none; border-radius: 4px; cursor: pointer;">
                        </label>
                        <label style="color: #fff; font-size: 11px; display: flex; align-items: center; gap: 6px;">
                            <span>Eyes</span>
                            <input id="eyeColor" type="color" value="#1e2a3a" style="width: 30px; height: 20px; border: none; border-radius: 4px; cursor: pointer;">
                        </label>
                        <label style="color: #fff; font-size: 11px; display: flex; align-items: center; gap: 6px;">
                            <span>Belly</span>
                            <input id="belColor" type="color" value="#f8d7b1" style="width: 30px; height: 20px; border: none; border-radius: 4px; cursor: pointer;">
                        </label>
                    </div>
                    
                    <!-- Gear Customization -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 12px;">
                        <label style="color: #fff; font-size: 11px; display: flex; align-items: center; gap: 6px; cursor: pointer;">
                            <input id="gearHat" type="checkbox" style="transform: scale(1.2);">
                            <span>üé© Hat</span>
                        </label>
                        <label style="color: #fff; font-size: 11px; display: flex; align-items: center; gap: 6px; cursor: pointer;">
                            <input id="gearGl" type="checkbox" style="transform: scale(1.2);">
                            <span>üëì Glasses</span>
                        </label>
                        <label style="color: #fff; font-size: 11px; display: flex; align-items: center; gap: 6px; cursor: pointer;">
                            <input id="gearVest" type="checkbox" style="transform: scale(1.2);">
                            <span>üëî Vest</span>
                        </label>
                    </div>
                    
                    <!-- Preview and Save -->
                    <div style="display: flex; gap: 8px; justify-content: center;">
                        <button id="preview-cat-btn" style="background: linear-gradient(135deg, #66bb6a 0%, #4caf50 100%); color: #ffffff; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 12px; box-shadow: 0 2px 6px rgba(76,175,80,0.3); transition: all 0.3s ease;">üëÅÔ∏è Preview</button>
                        <button id="save-cat-look" style="background: linear-gradient(135deg, #ff7043 0%, #f4511e 100%); color: #ffffff; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 12px; box-shadow: 0 2px 6px rgba(244,81,30,0.3); transition: all 0.3s ease;">üíæ Save Look</button>
                    </div>
                    
                    <!-- Live Preview -->
                    <div id="cat-preview-container" style="display: flex; justify-content: center; margin-top: 12px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                        <div id="live-cat-preview" class="cat-rig" style="width: 60px; height: 60px;"></div>
                    </div>
                </div>
                
            </div>
            <button class="login-btn" id="create-character-btn" style="background: linear-gradient(135deg, #ff7043 0%, #f4511e 100%); margin-bottom: 10px;">üé® CREATE CHARACTER</button>
            <button class="login-btn" id="login-btn">JOIN THE CLUB!</button>
        </div>
    </div>

    <!-- Welcome Back Screen -->
    <div class="login-screen" id="welcome-screen" style="display: none;">
        <div class="login-box">
            <h2 style="color: #00ff00;">üê± WELCOME BACK TO KITTY CREEK! üé£</h2>
            <div style="text-align: center; margin: 30px 0;">
                <img id="welcome-avatar" src="" alt="Your Cat" style="width: 150px; height: 150px; border-radius: 50%; border: 3px solid #00ff00; margin: 20px auto;">
                <div style="color: #00ff00; font-size: 24px; font-weight: bold; margin-top: 20px;" id="welcome-name">Loading...</div>
                <div style="color: #aaa; font-size: 14px; margin-top: 10px;">Loading Kitty Creek...</div>
            </div>
        </div>
    </div>

    <!-- Water refraction filter (lightweight) -->
    <svg width="0" height="0" aria-hidden="true" focusable="false">
        <filter id="water-distort">
            <feTurbulence id="waterNoise"
                          type="fractalNoise"
                          baseFrequency="0.008 0.02"
                          numOctaves="2"
                          seed="5"
                          result="noise"/>
            <feDisplacementMap in="SourceGraphic"
                               in2="noise"
                               scale="6"
                               xChannelSelector="R"
                               yChannelSelector="G"/>
        </filter>
    </svg>

    <!-- Socket.io Client Library -->
    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
    
    <script>
        class FishingHoleMultiplayer {
            constructor() {
                // WebSocket connection for multiplayer
                this.socket = null;
                this.serverUrl = window.location.origin; // Will connect to Railway server
                this.connected = false;
                this.player = {
                    name: 'Guest',
                    character: 'https://api.dicebear.com/7.x/avataaars/svg?seed=default', // Default avatar URL
                    avatarOptions: { style: 'male', hairColor: 'Brown', facialHair: 'none', accessories: 'none' }, // Avatar customization options
                    level: 1,
                    money: 100,
                    experience: 0,
                    totalCaught: 0,
                    totalWeight: 0,
                    biggestCatch: 0,
                    locationUnlocks: [0, 1], // Start with first two locations unlocked
                    tackleUnlocks: {
                        rods: [0], // Basic Rod unlocked
                        reels: [0], // Basic Reel unlocked
                        lines: [0], // Basic Line unlocked
                        hooks: [0], // Basic Hook unlocked
                        baits: [0]  // Basic Bait unlocked
                    },
                    gear: {
                        rod: 'Basic Rod',
                        reel: 'Basic Reel',
                        line: 'Monofilament',
                        hook: 'Basic Hook',
                        bait: 'Basic Bait'
                    },
                    stats: {
                        accuracy: 50,
                        luck: 50,
                        patience: 50,
                        strength: 50
                    },
                    achievements: [],
                    recentCatches: [],
                    top10BiggestFish: [], // Always keep track of top 10 biggest fish ever caught
                    caughtFish: {}, // Track which fish have been caught (name: true)
                    seasonalCatches: {
                        spring: { caught: 0, biggest: 0 },
                        summer: { caught: 0, biggest: 0 },
                        fall: { caught: 0, biggest: 0 },
                        winter: { caught: 0, biggest: 0 }
                    },
                    tournamentStats: {
                        tournamentsPlayed: 0,
                        tournamentsWon: 0,
                        biggestTournamentFish: 0,
                        biggestTournamentBag: 0,
                        totalTournamentWeight: 0,
                        totalTournamentFish: 0
                    }
                };

                this.locations = [
                    // Freshwater Locations
                    { name: 'Lake Shore', difficulty: 'Easy', fish: [0, 1, 2], cost: 0, unlockLevel: 1, description: 'Perfect for beginners' },
                    { name: 'River Bend', difficulty: 'Easy', fish: [0, 1, 2, 3], cost: 0, unlockLevel: 2, description: 'Gentle flowing waters' },
                    { name: 'Deep Lake', difficulty: 'Medium', fish: [2, 3, 4, 5], cost: 50, unlockLevel: 3, description: 'Deep waters with bigger fish' },
                    { name: 'Mountain Stream', difficulty: 'Medium', fish: [3, 4, 5, 6], cost: 75, unlockLevel: 5, description: 'Cold mountain waters' },
                    { name: 'Secret Pond', difficulty: 'Hard', fish: [4, 5, 6, 7], cost: 150, unlockLevel: 8, description: 'Hidden treasure spot' },
                    { name: 'Legendary Waters', difficulty: 'Expert', fish: [6, 7, 8, 9], cost: 300, unlockLevel: 12, description: 'Where legends are born' },
                    
                    // Saltwater Locations
                    { name: 'Ocean Pier', difficulty: 'Medium', fish: [10, 11, 12], cost: 100, unlockLevel: 6, description: 'Saltwater fishing spot' },
                    { name: 'Deep Sea', difficulty: 'Hard', fish: [12, 13, 14], cost: 250, unlockLevel: 10, description: 'Deep ocean fishing' },
                    { name: 'Trophy Waters', difficulty: 'Expert', fish: [25, 26, 27, 28, 29, 30, 31, 32], cost: 500, unlockLevel: 15, description: 'Trophy fish paradise' },
                    
                    // Special Locations
                    { name: 'Crystal Lake', difficulty: 'Hard', fish: [15, 16, 17, 18], cost: 200, unlockLevel: 9, description: 'Magical crystal-clear waters' },
                    { name: 'Abyss', difficulty: 'Expert', fish: [19, 20, 21, 22, 23], cost: 400, unlockLevel: 14, description: 'Bottomless depths' },
                    { name: 'Fishing Tournament', difficulty: 'Tournament', fish: [24, 25, 26, 27, 28], cost: 100, unlockLevel: 10, description: 'Competitive fishing event' }
                ];

                this.currentLocation = 0;
                this.isCasting = false;
                this.otherPlayers = [];
                this.tournament = null;
                this.leaderboardData = {
                    biggestFish: [],
                    biggestBags: []
                };

                // Sound system
                this.audioContext = null;
                this.sounds = {};
                this.soundEnabled = true;
                this.initAudio();

                this.fishTypes = [
                    // Common Fish (0-4)
                    { name: 'Minnow', rarity: 'Common', minWeight: 0.1, maxWeight: 0.5, value: 5, experience: 1, season: 'All' },
                    { name: 'Sunfish', rarity: 'Common', minWeight: 0.3, maxWeight: 1.2, value: 8, experience: 2, season: 'All' },
                    { name: 'Bass', rarity: 'Common', minWeight: 1.0, maxWeight: 5.0, value: 15, experience: 5, season: 'All' },
                    { name: 'Perch', rarity: 'Common', minWeight: 0.5, maxWeight: 2.0, value: 12, experience: 3, season: 'All' },
                    { name: 'Crappie', rarity: 'Common', minWeight: 0.8, maxWeight: 3.0, value: 18, experience: 4, season: 'All' },
                    
                    // Uncommon Fish (5-9)
                    { name: 'Trout', rarity: 'Uncommon', minWeight: 0.5, maxWeight: 3.0, value: 25, experience: 10, season: 'Spring/Fall' },
                    { name: 'Pike', rarity: 'Uncommon', minWeight: 2.0, maxWeight: 8.0, value: 40, experience: 15, season: 'All' },
                    { name: 'Walleye', rarity: 'Uncommon', minWeight: 1.5, maxWeight: 6.0, value: 35, experience: 12, season: 'Spring/Fall' },
                    { name: 'Muskie', rarity: 'Uncommon', minWeight: 5.0, maxWeight: 15.0, value: 60, experience: 20, season: 'All' },
                    { name: 'Carp', rarity: 'Uncommon', minWeight: 3.0, maxWeight: 20.0, value: 30, experience: 8, season: 'All' },
                    
                    // Rare Fish (10-14)
                    { name: 'Salmon', rarity: 'Rare', minWeight: 8.0, maxWeight: 25.0, value: 80, experience: 25, season: 'Fall' },
                    { name: 'Catfish', rarity: 'Rare', minWeight: 5.0, maxWeight: 30.0, value: 70, experience: 22, season: 'All' },
                    { name: 'Sturgeon', rarity: 'Rare', minWeight: 20.0, maxWeight: 50.0, value: 120, experience: 35, season: 'All' },
                    { name: 'Marlin', rarity: 'Rare', minWeight: 50.0, maxWeight: 200.0, value: 200, experience: 50, season: 'All' },
                    { name: 'Tuna', rarity: 'Rare', minWeight: 30.0, maxWeight: 150.0, value: 150, experience: 40, season: 'All' },
                    
                    // Epic Fish (15-19)
                    { name: 'Crystal Bass', rarity: 'Epic', minWeight: 10.0, maxWeight: 35.0, value: 300, experience: 60, season: 'All' },
                    { name: 'Golden Trout', rarity: 'Epic', minWeight: 5.0, maxWeight: 20.0, value: 250, experience: 55, season: 'Spring' },
                    { name: 'Ice Pike', rarity: 'Epic', minWeight: 15.0, maxWeight: 40.0, value: 350, experience: 65, season: 'Winter' },
                    { name: 'Shadow Catfish', rarity: 'Epic', minWeight: 25.0, maxWeight: 60.0, value: 400, experience: 70, season: 'All' },
                    { name: 'Abyssal Eel', rarity: 'Epic', minWeight: 30.0, maxWeight: 80.0, value: 500, experience: 80, season: 'All' },
                    
                    // Legendary Fish (20-24)
                    { name: 'Ancient Sturgeon', rarity: 'Legendary', minWeight: 100.0, maxWeight: 300.0, value: 1000, experience: 150, season: 'All' },
                    { name: 'Leviathan', rarity: 'Legendary', minWeight: 200.0, maxWeight: 500.0, value: 2000, experience: 200, season: 'All' },
                    { name: 'Phoenix Fish', rarity: 'Legendary', minWeight: 50.0, maxWeight: 150.0, value: 1500, experience: 180, season: 'All' },
                    { name: 'Dragon Carp', rarity: 'Legendary', minWeight: 80.0, maxWeight: 200.0, value: 1800, experience: 190, season: 'All' },
                    { name: 'Tournament King', rarity: 'Legendary', minWeight: 60.0, maxWeight: 120.0, value: 1200, experience: 160, season: 'All' },
                    
                    // Trophy Fish (25-32)
                    { name: 'Trophy Bass', rarity: 'Trophy', minWeight: 20.0, maxWeight: 50.0, value: 500, experience: 100, season: 'All' },
                    { name: 'Trophy Pike', rarity: 'Trophy', minWeight: 30.0, maxWeight: 70.0, value: 600, experience: 110, season: 'All' },
                    { name: 'Trophy Salmon', rarity: 'Trophy', minWeight: 40.0, maxWeight: 80.0, value: 700, experience: 120, season: 'Fall' },
                    { name: 'Trophy Marlin', rarity: 'Trophy', minWeight: 100.0, maxWeight: 300.0, value: 1000, experience: 150, season: 'All' },
                    { name: 'Trophy Tuna', rarity: 'Trophy', minWeight: 80.0, maxWeight: 200.0, value: 800, experience: 130, season: 'All' },
                    { name: 'Trophy Sturgeon', rarity: 'Trophy', minWeight: 150.0, maxWeight: 400.0, value: 1200, experience: 170, season: 'All' },
                    { name: 'Trophy Catfish', rarity: 'Trophy', minWeight: 60.0, maxWeight: 150.0, value: 900, experience: 140, season: 'All' },
                    { name: 'Trophy King', rarity: 'Trophy', minWeight: 200.0, maxWeight: 500.0, value: 1500, experience: 200, season: 'All' }
                ];

                // Fish facts database - fun and interesting information
                this.fishFacts = {
                    'Minnow': { fact: 'Tiny but mighty! Minnows travel in huge schools of thousands.', fun: 'So small, even cats think they\'re fishnacks!', real: 'They make excellent live bait due to their movement.' },
                    'Sunfish': { fact: 'Brightly colored and curious little fish.', fun: 'Named for their sunny disposition, not their speed!', real: 'Belongs to the same family as bass.' },
                    'Bass': { fact: 'Aggressive predators with a taste for action.', fun: 'The original bass drops are underwater!', real: 'Can grow up to 25 pounds in ideal conditions.' },
                    'Perch': { fact: 'Striped like a prison uniform for fish crimes.', fun: 'Perched on the edge of greatness... and your hook.', real: 'Lives in freshwater lakes and rivers worldwide.' },
                    'Crappie': { fact: 'Don\'t let the name fool you - delicious eating!', fun: 'Sounds fishy, tastes great!', real: 'Very popular for sport fishing and pan-frying.' },
                    'Trout': { fact: 'Living fossils, some species date back 50 million years.', fun: 'Prefers cold water and colder comedy.', real: 'Can detect vibrations in water from miles away.' },
                    'Pike': { fact: 'Razor-sharp teeth and an attitude to match.', fun: 'The needlefish needle... no, the other way around!', real: 'Ambush predators that can strike at 6 mph.' },
                    'Walleye': { fact: 'Has eyes that glow at night like a cat in the dark.', fun: 'Sees everything, forgives nothing.', real: 'Named for their reflective eyes that help night fishing.' },
                    'Muskie': { fact: 'The freshwater version of a shark.', fun: 'Fish of 10,000 casts... but we only count the caught ones!', real: 'Can live up to 30 years in the wild.' },
                    'Carp': { fact: 'Bottom feeders who love muddy waters.', fun: 'King of the murky depths and questionable dietary choices.', real: 'Introduced to North America in the 1800s.' },
                    'Salmon': { fact: 'Journeys hundreds of miles to spawn in their birthplace.', fun: 'Swims upstream in life like we do on Mondays.', real: 'Changes color dramatically during spawning season.' },
                    'Catfish': { fact: 'Whiskered bottom dwellers with electrical sensors.', fun: 'Has more whiskers than my uncle at Christmas!', real: 'Some species can grow over 100 pounds.' },
                    'Sturgeon': { fact: 'Living dinosaurs that can reach 20 feet and 3,000 pounds!', fun: 'Swims like it owns the river... because it probably does.', real: 'Can live over 100 years old.' },
                    'Marlin': { fact: 'Speed demon of the ocean, reaching 60+ mph.', fun: 'The sports car of the sea with a bill for a bumper.', real: 'One of the fastest fish in the ocean.' },
                    'Tuna': { fact: 'Warm-blooded fish that never stops swimming.', fun: 'If it stops swimming, we all get sushi!', real: 'Can maintain body heat 10¬∞F warmer than water.' },
                    'Crystal Bass': { fact: 'Rare variant that shimmers like diamonds.', fun: 'Blindingly beautiful and dangerously expensive!', real: 'Color mutation found in less than 1% of bass.' },
                    'Golden Trout': { fact: 'Flashy mountain trout from the Sierra Nevadas.', fun: 'More valuable than gold... well, bronze at least.', real: 'Native to alpine streams above 9,000 feet.' },
                    'Ice Pike': { fact: 'Arctic warrior that thrives in frozen waters.', fun: 'Thinks 32¬∞F is a perfect swimming temperature!', real: 'Produces antifreeze proteins in blood.' },
                    'Shadow Catfish': { fact: 'Elusive nocturnal hunter of the deep.', fun: 'Wears sunglasses at night... underwater.', real: 'Evolved enhanced senses for dark water hunting.' },
                    'Abyssal Eel': { fact: 'Deep sea dweller from the darkest depths.', fun: 'Lives where light fears to tread... literally.', real: 'Can survive under crushing ocean pressure.' },
                    'Ancient Sturgeon': { fact: 'Prehistoric fish that outlived dinosaurs.', fun: 'Older than your ancestors and twice as grumpy!', real: 'Lived through the extinction that killed dinosaurs.' },
                    'Leviathan': { fact: 'Mythical sea monster of biblical proportions.', fun: 'Size: YES. Attitude: Also YES.', real: 'Inspired by giant prehistoric whales.' },
                    'Phoenix Fish': { fact: 'Legendary creature that rises from the depths.', fun: 'Dying means a new fishing trip for it!', real: 'Mythical fish symbolizing rebirth and renewal.' },
                    'Dragon Carp': { fact: 'Legend speaks of its fiery underwater presence.', fun: 'Breathes underwater fire... and smoke signals.', real: 'Ancient Asian legends speak of dragon fish.' },
                    'Tournament King': { fact: 'Crown jewel of competitive fishing.', fun: 'Wins every beauty contest it enters!', real: 'Prized catch in professional fishing tournaments.' },
                    'Trophy Bass': { fact: 'Wall-hanger of epic proportions.', fun: 'Big enough to tell fishing lies about!', real: 'World record: 22 lbs 4 oz.' },
                    'Trophy Pike': { fact: 'Predator that makes other fish nervous.', fun: 'Has a resume of 10,000 minor offenses.', real: 'Can grow over 50 inches long.' },
                    'Trophy Salmon': { fact: 'Ocean warrior returned to freshwater.', fun: 'Swam an entire marathon just to spawn!', real: 'Can leap 10 feet in waterfalls.' },
                    'Trophy Marlin': { fact: 'Trophy that dreams are made of.', fun: 'Bill so long it doubles as a sword!', real: 'Can reach speeds over 68 mph.' },
                    'Trophy Tuna': { fact: 'Ocean giant worth its weight in sashimi.', fun: 'Sushi price tag included!', real: 'Can weigh over 1,000 pounds.' },
                    'Trophy Sturgeon': { fact: 'Ancient giant of the rivers.', fun: 'Older than your grandpa and twice as wise!', real: 'Some reach over 15 feet long.' },
                    'Trophy Catfish': { fact: 'Freshwater giant with suction cup mouth.', fun: 'Named "Trophy" because it won first place!', real: 'World record catfish was over 300 lbs.' },
                    'Trophy King': { fact: 'The ultimate catch - king of all fish!', fun: 'Rules the depths with an iron fin!', real: 'Crown jewel of any angler\'s collection.' }
                };

                // Complete tackle system
                this.tackle = {
                    rods: [
                        { name: 'Basic Rod', cost: 0, catchBonus: 0, strength: 10, description: 'Starting rod', unlockLevel: 1 },
                        { name: 'Fiberglass Rod', cost: 250, catchBonus: 5, strength: 15, description: 'Better durability', unlockLevel: 3 },
                        { name: 'Carbon Fiber Rod', cost: 1000, catchBonus: 10, strength: 20, description: 'Lightweight and strong', unlockLevel: 6 },
                        { name: 'Pro Rod', cost: 3500, catchBonus: 15, strength: 25, description: 'Professional grade', unlockLevel: 9 },
                        { name: 'Master Rod', cost: 10000, catchBonus: 20, strength: 30, description: 'Master angler equipment', unlockLevel: 12 },
                        { name: 'Legendary Rod', cost: 30000, catchBonus: 25, strength: 40, description: 'Legendary craftsmanship', unlockLevel: 15 },
                        { name: 'Trophy Rod', cost: 100000, catchBonus: 30, strength: 50, description: 'Trophy fishing specialist', unlockLevel: 18 }
                    ],
                    reels: [
                        { name: 'Basic Reel', cost: 0, speedBonus: 0, smoothness: 10, description: 'Simple reel', unlockLevel: 1 },
                        { name: 'Spinning Reel', cost: 200, speedBonus: 5, smoothness: 15, description: 'Smooth retrieval', unlockLevel: 4 },
                        { name: 'Baitcasting Reel', cost: 750, speedBonus: 10, smoothness: 20, description: 'Precision casting', unlockLevel: 7 },
                        { name: 'Fly Reel', cost: 2500, speedBonus: 15, smoothness: 25, description: 'Fly fishing specialist', unlockLevel: 10 },
                        { name: 'Big Game Reel', cost: 8000, speedBonus: 20, smoothness: 30, description: 'Heavy duty fishing', unlockLevel: 13 },
                        { name: 'Trophy Reel', cost: 25000, speedBonus: 25, smoothness: 40, description: 'Trophy fishing specialist', unlockLevel: 16 }
                    ],
                    lines: [
                        { name: 'Monofilament', cost: 0, strength: 10, visibility: 5, description: 'Basic fishing line', unlockLevel: 1 },
                        { name: 'Braided Line', cost: 150, strength: 15, visibility: 3, description: 'Strong and thin', unlockLevel: 5 },
                        { name: 'Fluorocarbon', cost: 500, strength: 12, visibility: 1, description: 'Nearly invisible', unlockLevel: 8 },
                        { name: 'Wire Line', cost: 2000, strength: 25, visibility: 8, description: 'Heavy duty fishing', unlockLevel: 12 },
                        { name: 'Titanium Line', cost: 8000, strength: 35, visibility: 2, description: 'Ultimate strength', unlockLevel: 16 }
                    ],
                    hooks: [
                        { name: 'Basic Hook', cost: 0, catchBonus: 0, size: 8, description: 'Standard hook - 600ms timing window', unlockLevel: 1 },
                        { name: 'Barbed Hook', cost: 100, catchBonus: 5, size: 8, description: 'Better fish retention - 700ms timing window', unlockLevel: 3 },
                        { name: 'Circle Hook', cost: 300, catchBonus: 3, size: 6, description: 'Fish-friendly design - 800ms timing window', unlockLevel: 5 },
                        { name: 'Treble Hook', cost: 800, catchBonus: 8, size: 6, description: 'Triple hook design - 900ms timing window', unlockLevel: 7 },
                        { name: 'Jig Hook', cost: 2500, catchBonus: 10, size: 4, description: 'Jig fishing specialist - 1000ms timing window', unlockLevel: 10 },
                        { name: 'Trophy Hook', cost: 10000, catchBonus: 15, size: 2, description: 'Trophy fish specialist - 1100ms timing window', unlockLevel: 15 }
                    ],
                    baits: [
                        { name: 'Basic Bait', cost: 0, catchBonus: 0, durability: 10, description: 'Simple worm bait', unlockLevel: 1 },
                        { name: 'Live Bait', cost: 75, catchBonus: 8, durability: 15, description: 'Live worm', unlockLevel: 2 },
                        { name: 'Artificial Lure', cost: 250, catchBonus: 5, durability: 25, description: 'Reusable lure', unlockLevel: 4 },
                        { name: 'Premium Bait', cost: 1000, catchBonus: 12, durability: 20, description: 'High-quality bait', unlockLevel: 6 },
                        { name: 'Specialty Bait', cost: 4000, catchBonus: 18, durability: 15, description: 'Rare fish attractant', unlockLevel: 10 },
                        { name: 'Trophy Bait', cost: 15000, catchBonus: 25, durability: 10, description: 'Trophy fish magnet', unlockLevel: 15 }
                    ]
                };

                this.init();
            }

            init() {
                this.loadGameData();
                
                // Check if player has saved data (has played before)
                const savedData = localStorage.getItem('fishingHoleGame');
                const loginScreen = document.getElementById('login-screen');
                const welcomeScreen = document.getElementById('welcome-screen');
                
                if (savedData) {
                    const gameData = JSON.parse(savedData);
                    // If player has a name and character saved, show welcome screen then auto-login
                    if (gameData.player && gameData.player.name && gameData.player.name !== 'Guest' && gameData.player.character) {
                        // Hide login screen (only shown for new players)
                        if (loginScreen) {
                            loginScreen.classList.add('hidden');
                        }
                        
                        // Set player data from saved game
                        this.player.name = gameData.player.name;
                        this.player.character = gameData.player.character;
                        this.player.avatarOptions = gameData.player.avatarOptions || { type: 'cat', url: gameData.player.character };
                        
                        // Show welcome screen
                        if (welcomeScreen) {
                            welcomeScreen.style.display = 'flex';
                            const welcomeName = document.getElementById('welcome-name');
                            const welcomeAvatar = document.getElementById('welcome-avatar');
                            if (welcomeName) welcomeName.textContent = this.player.name;
                            // Don't use robohash - hide avatar image since we use 3D cats
                            if (welcomeAvatar) {
                                if (this.player.character === 'cat-rig' || this.player.avatarOptions?.type === 'cat') {
                                    welcomeAvatar.style.display = 'none'; // Hide image, use 3D cat instead
                                } else {
                                    welcomeAvatar.src = this.player.character;
                                }
                            }
                            
                            // Hide welcome screen after 2 seconds and start game
                            setTimeout(() => {
                                if (welcomeScreen) welcomeScreen.style.display = 'none';
                                this.addChatMessage('system', `${this.player.name} joined Kitty Creek Fishing Club! üê±`);
                                this.positionPlayers();
                                this.joinGame();
                            }, 2000);
                        } else {
                            // If welcome screen doesn't exist, just start game
                            this.addChatMessage('system', `${this.player.name} joined Kitty Creek Fishing Club! üê±`);
                            this.positionPlayers();
                            this.joinGame();
                        }
                    } else {
                        // Player has data but no character - show login to create character
                        if (loginScreen) {
                            loginScreen.classList.remove('hidden');
                        }
                    }
                } else {
                    // New player - show login screen to create character
                    if (loginScreen) {
                        loginScreen.classList.remove('hidden');
                    }
                }
                
                this.connectToServer(); // Connect to Railway server
                this.setupEventListeners();
                this.initializeWaterEffects();
                if (!this.player.name || this.player.name === 'Guest') {
                    // Only position players if not auto-logged in
                    this.positionPlayers();
                }
                // AI/Other players disabled - only showing player's cat
                // this.simulateMultiplayer();
                this.updateDisplay();
                this.updateAchievementsDisplay();
                this.updateLeaderboard();
                this.createAnimatedRipples();
                this.startAutoSave(); // Start auto-save
                this.loadChatState(); // Load chat collapsed/expanded state
                this.initMockAds(); // Initialize rotating mock ads
            }

            connectToServer() {
                try {
                    this.socket = io(this.serverUrl, {
                        transports: ['websocket', 'polling']
                    });

                    this.socket.on('connect', () => {
                        console.log('Connected to server');
                        this.connected = true;
                        this.addChatMessage('system', 'Connected to multiplayer server!');
                        
                        // Join game after login
                        if (this.player.name !== 'Guest') {
                            this.joinGame();
                        }
                    });

                    this.socket.on('disconnect', () => {
                        console.log('Disconnected from server');
                        this.connected = false;
                        this.addChatMessage('system', 'Disconnected from server');
                    });

                    this.socket.on('player-joined', (data) => {
                        this.addChatMessage('other', `${data.name} joined the game!`);
                        this.showGlobalAnnouncement(`üëã ${data.name} joined Kitty Creek! üê±`, '#00ffff');
                        this.updateOnlinePlayers();
                    });

                    this.socket.on('player-left', (data) => {
                        this.addChatMessage('other', `${data.name} left the game`);
                        this.updateOnlinePlayers();
                        
                        // Remove fishing lines for the player who left - use player name to avoid index issues
                        const lake = document.getElementById('fishing-lake');
                        const mobileLake = document.getElementById('mobile-fishing-lake');
                        
                        if (lake) {
                            // Remove lines by player name (more reliable than index)
                            lake.querySelectorAll('.fishing-line').forEach(line => {
                                if (line.dataset.playerName && line.dataset.playerName.includes(data.name)) {
                                    line.remove();
                                }
                            });
                            // Also remove any orphaned hooks
                            lake.querySelectorAll('.hook').forEach(hook => {
                                const parentLine = hook.closest('.fishing-line');
                                if (!parentLine || (parentLine.dataset.playerName && parentLine.dataset.playerName.includes(data.name))) {
                                    hook.remove();
                                }
                            });
                        }
                        
                        if (mobileLake) {
                            // Remove lines by player name
                            mobileLake.querySelectorAll('.fishing-line').forEach(line => {
                                if (line.dataset.playerName && line.dataset.playerName.includes(data.name)) {
                                    line.remove();
                                }
                            });
                            // Also remove any orphaned hooks
                            mobileLake.querySelectorAll('.hook').forEach(hook => {
                                const parentLine = hook.closest('.fishing-line');
                                if (!parentLine || (parentLine.dataset.playerName && parentLine.dataset.playerName.includes(data.name))) {
                                    hook.remove();
                                }
                            });
                        }
                        
                        // Reposition players to clean up empty spots
                        this.positionPlayers();
                    });

                    this.socket.on('player-list', (players) => {
                        // Separate real players from simulated ones
                        // players is now an array of objects with {name, level}
                        const realPlayerData = players.filter(p => p.name !== this.player.name);
                        const simulatedPlayers = this.otherPlayers.filter(p => p.isSimulated);
                        
                        // Map real players with their actual levels and characters
                        const realPlayers = realPlayerData.map(playerData => ({
                            name: playerData.name,
                            level: playerData.level || 1,
                            character: playerData.character || 'cat-rig', // Use cat rig system
                            fishing: false,
                            catches: 0,
                            isCasting: false,
                            biggestCatch: 0,
                            recentCatches: [],
                            isSimulated: false // Mark as real player
                        }));
                        
                        // Combine real players with simulated ones
                        this.otherPlayers = [...realPlayers, ...simulatedPlayers];
                        this.updateOnlinePlayers();
                        this.positionPlayers(); // Update visual positioning
                    });

                    this.socket.on('fish-caught', (data) => {
                        // Only show chat message if not marked as silent (tournament catches are silent)
                        if (!data.silent) {
                            this.addChatMessage('other', `${data.player} caught a ${data.fish.name} (${data.weight.toFixed(1)} lbs)!`);
                        }
                        
                        // Update tournament scores if this is a tournament catch
                        if (data.tournamentId && this.tournament && this.tournament.tournamentId === data.tournamentId) {
                            if (!this.tournament.scores[data.player]) {
                                this.tournament.scores[data.player] = {
                                    totalWeight: 0,
                                    fishCount: 0,
                                    biggestCatch: 0
                                };
                                this.tournament.catches[data.player] = [];
                            }
                            
                            this.tournament.scores[data.player].totalWeight += data.weight;
                            this.tournament.scores[data.player].fishCount++;
                            if (data.weight > this.tournament.scores[data.player].biggestCatch) {
                                this.tournament.scores[data.player].biggestCatch = data.weight;
                            }
                            
                            this.tournament.catches[data.player].push({
                                fish: data.fish.name,
                                weight: data.weight,
                                timestamp: Date.now()
                            });
                            
                            // Update tournament display if active
                            if (this.tournament.phase === 'active') {
                                this.updateTournamentDisplay();
                            }
                        }
                    });

                    this.socket.on('special-catch', (data) => {
                        // Show special catch announcements to ALL players, including the one who caught it
                        const fishName = data.fish.name;
                        const weight = data.weight;
                        const value = data.value;
                        const isRare = data.isRare || false;
                        const isHuge = data.isHuge || false;
                        const isLegendary = data.isLegendary || false;
                        const isTrophy = data.isTrophy || false;
                        
                        // Only show for other players (not the one who caught it)
                        if (data.player !== this.player.name) {
                            if (isLegendary || isTrophy) {
                                this.addChatMessage('legendary', `üèÜ LEGENDARY CATCH! ${data.player} caught a ${fishName}! ${weight.toFixed(1)}lbs, +$${value} üèÜ`);
                                this.showGlobalAnnouncement(`üèÜ LEGENDARY CATCH! ${data.player} caught a ${fishName}! ${weight.toFixed(1)}lbs üèÜ`, '#ff00ff');
                            } else if (isRare) {
                                this.addChatMessage('rare', `üíé RARE CATCH! ${data.player} caught a ${fishName}! ${weight.toFixed(1)}lbs, +$${value} üíé`);
                                this.showGlobalAnnouncement(`üíé RARE CATCH! ${data.player} caught a ${fishName}! ${weight.toFixed(1)}lbs üíé`, '#00ffff');
                            } else if (isHuge) {
                                this.addChatMessage('huge', `üêü HUGE FISH! ${data.player} caught a massive ${fishName}! ${weight.toFixed(1)}lbs, +$${value} üêü`);
                                this.showGlobalAnnouncement(`üêü HUGE FISH! ${data.player} caught a massive ${fishName}! ${weight.toFixed(1)}lbs üêü`, '#ffff00');
                            }
                        }
                    });

                    this.socket.on('chat-message', (data) => {
                        this.addChatMessage('other', `${data.player}: ${data.message}`);
                        // Show message in banner above buttons
                        this.showChatBanner(`${data.player}: ${data.message}`);
                    });

                    this.socket.on('game-saved', () => {
                        console.log('Game saved to server');
                    });

                    this.socket.on('error', (error) => {
                        console.error('Server error:', error);
                        this.addChatMessage('system', `Error: ${error.message}`);
                    });

                    this.socket.on('tournament-start', (data) => {
                        // Only create tournament for other players (not if we already have one)
                        if (!this.tournament) {
                            // Create a read-only tournament instance for viewing
                            // Use the same startTime so countdown matches
                            this.tournament = {
                                active: true,
                                phase: 'joining',
                                participants: data.participants || [],
                                startTime: Date.now() - (data.elapsedTime || 0), // Match the host's countdown
                                duration: 5 * 60 * 1000, // 5 minutes
                                joinPeriod: 60 * 1000, // 60 seconds to join
                                scores: {},
                                tournamentId: data.tournamentId,
                                catches: {},
                                isViewer: true // Mark as viewer-only (not participant)
                            };
                            
                            // Initialize scores for all participants
                            this.tournament.participants.forEach(name => {
                                this.tournament.scores[name] = {
                                    totalWeight: 0,
                                    fishCount: 0,
                                    biggestCatch: 0
                                };
                                this.tournament.catches[name] = [];
                            });
                            
                            this.updateTournamentDisplay();
                            this.showGlobalAnnouncement('üê± KITTY CREEK TOURNAMENT STARTING! üé£', '#ffff00');
                            this.addChatMessage('system', 'üê± A tournament is starting! Join by clicking TOURNAMENT button!');
                        }
                    });

                    this.socket.on('tournament-countdown', (data) => {
                        // Show countdown for viewers
                        if (this.tournament && this.tournament.isViewer) {
                            this.showGlobalAnnouncement(`üê± TOURNAMENT STARTS IN ${data.seconds} SECONDS! üé£`, '#ff00ff');
                            this.addChatMessage('system', `Tournament starts in ${data.seconds} seconds!`);
                            this.updateTournamentDisplay(); // Update the display
                        }
                    });

                    this.socket.on('tournament-active', (data) => {
                        // Switch to active phase for viewers
                        if (this.tournament && this.tournament.isViewer && this.tournament.tournamentId === data.tournamentId) {
                            this.tournament.phase = 'active';
                            this.tournament.startTime = Date.now();
                            this.updateTournamentDisplay();
                            this.showGlobalAnnouncement('üê± KITTY CREEK TOURNAMENT HAS BEGUN! üé£', '#00ff00');
                            this.addChatMessage('system', 'üê± TOURNAMENT FISHING HAS BEGUN! Good luck, furriend!');
                        }
                    });

                    this.socket.on('tournament-end', (data) => {
                        // Update tournament scores and show results for viewers
                        if (this.tournament && this.tournament.tournamentId === data.tournamentId) {
                            this.tournament.scores = data.scores;
                            this.tournament.catches = data.catches;
                            this.tournament.phase = 'ended';
                            
                            // Award prize money if this player won
                            if (data.winner === this.player.name && data.prizeAmount > 0) {
                                this.player.money += data.prizeAmount;
                                this.addChatMessage('system', `üèÜ Congratulations! You won $${data.prizeAmount} prize money!`);
                                this.showMessage(`üèÜ Tournament Win: +$${data.prizeAmount}!`, '#ffd700');
                                this.saveGameData();
                            }
                            
                            // Show results
                            this.showTournamentResults();
                            this.addChatMessage('system', `Tournament ended! Winner: ${data.winner} with ${Math.max(...Object.values(data.scores).map(s => s.totalWeight)).toFixed(2)} lbs!`);
                            
                            // Clear tournament after showing results
                            setTimeout(() => {
                                this.tournament = null;
                                this.updateTournamentDisplay();
                            }, 10000);
                        }
                    });

                    this.socket.on('player-casting', (data) => {
                        // Find player and show their casting animation
                        const playerIndex = this.otherPlayers.findIndex(p => p.name === data.name);
                        if (playerIndex !== -1) {
                            this.otherPlayers[playerIndex].isCasting = true;
                            this.addFishingLine(playerIndex + 1, true); // +1 because index 0 is current player
                            
                            // Auto-reel after a delay (simulated)
                            setTimeout(() => {
                                if (this.otherPlayers[playerIndex]) {
                                    this.otherPlayers[playerIndex].isCasting = false;
                                    const lines = document.querySelectorAll('.fishing-line');
                                    lines.forEach(line => {
                                        if (line.dataset.playerIndex == (playerIndex + 1).toString()) {
                                            line.remove();
                                        }
                                    });
                                }
                            }, 3000 + Math.random() * 2000);
                        }
                    });
                } catch (error) {
                    console.error('Failed to connect to server:', error);
                    this.addChatMessage('system', 'Multiplayer unavailable - playing offline');
                }
            }

            joinGame() {
                if (this.socket && this.connected) {
                    this.socket.emit('join-game', {
                        name: this.player.name,
                        level: this.player.level,
                        money: this.player.money,
                        experience: this.player.experience,
                        locationUnlocks: this.player.locationUnlocks,
                        tackleUnlocks: this.player.tackleUnlocks,
                        gear: this.player.gear,
                        stats: this.player.stats,
                        character: this.player.character // Send selected avatar
                    });
                }
            }

            initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.createSounds();
                } catch (error) {
                    console.log('Web Audio API not supported, sounds disabled');
                }
            }

            initAudioOnInteraction() {
                // Auto-resume audio context on first user interaction
                if (!this.audioContext) {
                    const resumeAudio = () => {
                        if (!this.audioContext) {
                            this.initAudio();
                        }
                        if (this.audioContext && this.audioContext.state === 'suspended') {
                            this.audioContext.resume().then(() => {
                                console.log('Audio context resumed successfully');
                            }).catch(error => {
                                console.log('Error resuming audio context:', error);
                            });
                        }
                        // Remove listeners after first interaction
                        document.removeEventListener('click', resumeAudio);
                        document.removeEventListener('touchstart', resumeAudio);
                        document.removeEventListener('keydown', resumeAudio);
                    };
                    
                    // Listen for any user interaction to resume audio
                    document.addEventListener('click', resumeAudio, { once: true });
                    document.addEventListener('touchstart', resumeAudio, { once: true });
                    document.addEventListener('keydown', resumeAudio, { once: true });
                }
            }

            createSounds() {
                if (!this.audioContext) return;

                // Casting sound - whoosh with line release
                this.sounds.cast = () => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.3);
                    
                    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                    
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.3);
                };

                // Reeling sound - mechanical whirring
                this.sounds.reel = () => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    
                    oscillator.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(80, this.audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(120, this.audioContext.currentTime + 0.5);
                    
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(200, this.audioContext.currentTime);
                    
                    gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                    
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.5);
                };

                // Cat meow sound generator
                this.sounds.catMeow = (pitch = 400, duration = 0.3) => {
                    const osc1 = this.audioContext.createOscillator();
                    const osc2 = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    
                    osc1.type = 'sine';
                    osc2.type = 'triangle';
                    
                    // Create meow shape: start high, dip down, go back up
                    osc1.frequency.setValueAtTime(pitch * 1.5, this.audioContext.currentTime);
                    osc1.frequency.exponentialRampToValueAtTime(pitch * 0.7, this.audioContext.currentTime + duration * 0.4);
                    osc1.frequency.exponentialRampToValueAtTime(pitch * 1.2, this.audioContext.currentTime + duration);
                    
                    osc2.frequency.setValueAtTime(pitch * 1.3, this.audioContext.currentTime);
                    osc2.frequency.exponentialRampToValueAtTime(pitch * 0.8, this.audioContext.currentTime + duration * 0.4);
                    osc2.frequency.exponentialRampToValueAtTime(pitch * 1.1, this.audioContext.currentTime + duration);
                    
                    filter.type = 'bandpass';
                    filter.frequency.setValueAtTime(pitch, this.audioContext.currentTime);
                    filter.Q.setValueAtTime(3, this.audioContext.currentTime);
                    
                    osc1.connect(filter);
                    osc2.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    gain.gain.setValueAtTime(0.25, this.audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                    
                    osc1.start();
                    osc2.start();
                    osc1.stop(this.audioContext.currentTime + duration);
                    osc2.stop(this.audioContext.currentTime + duration);
                };

                // Cat purr sound
                this.sounds.catPurr = () => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(120, this.audioContext.currentTime);
                    osc.frequency.setValueAtTime(115, this.audioContext.currentTime + 0.1);
                    osc.frequency.setValueAtTime(125, this.audioContext.currentTime + 0.2);
                    osc.frequency.setValueAtTime(120, this.audioContext.currentTime + 0.3);
                    
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(300, this.audioContext.currentTime);
                    
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    gain.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                    
                    osc.start();
                    osc.stop(this.audioContext.currentTime + 0.5);
                };

                // Fish caught sound - splash and cat meow!
                this.sounds.catch = () => {
                    // Splash sound
                    const splashOsc = this.audioContext.createOscillator();
                    const splashGain = this.audioContext.createGain();
                    const splashFilter = this.audioContext.createBiquadFilter();
                    
                    splashOsc.connect(splashFilter);
                    splashFilter.connect(splashGain);
                    splashGain.connect(this.audioContext.destination);
                    
                    splashOsc.type = 'sawtooth';
                    splashFilter.type = 'bandpass';
                    splashFilter.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    splashFilter.Q.setValueAtTime(1, this.audioContext.currentTime);
                    
                    splashGain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    splashGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                    
                    splashOsc.start();
                    splashOsc.stop(this.audioContext.currentTime + 0.2);
                    
                    // Cat meow for success!
                    setTimeout(() => {
                        this.sounds.catMeow(450, 0.3);
                    }, 150);
                };

                // Big fish caught - deeper splash and excited cat meows!
                this.sounds.bigCatch = () => {
                    // Big splash
                    const bigSplashOsc = this.audioContext.createOscillator();
                    const bigSplashGain = this.audioContext.createGain();
                    const bigSplashFilter = this.audioContext.createBiquadFilter();
                    
                    bigSplashOsc.connect(bigSplashFilter);
                    bigSplashFilter.connect(bigSplashGain);
                    bigSplashGain.connect(this.audioContext.destination);
                    
                    bigSplashOsc.type = 'sawtooth';
                    bigSplashFilter.type = 'bandpass';
                    bigSplashFilter.frequency.setValueAtTime(400, this.audioContext.currentTime);
                    bigSplashFilter.Q.setValueAtTime(0.5, this.audioContext.currentTime);
                    
                    bigSplashGain.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                    bigSplashGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
                    
                    bigSplashOsc.start();
                    bigSplashOsc.stop(this.audioContext.currentTime + 0.4);
                    
                    // Excited cat meows (higher pitch, more energetic)
                    setTimeout(() => {
                        this.sounds.catMeow(550, 0.25); // First excited meow
                        setTimeout(() => {
                            this.sounds.catMeow(600, 0.3); // Second higher meow
                        }, 200);
                    }, 250);
                };

                // Level up celebration - cat purr and happy meows!
                this.sounds.levelUp = () => {
                    // Cat purr for level up happiness
                    this.sounds.catPurr();
                    
                    // Happy meows after purr
                    setTimeout(() => {
                        this.sounds.catMeow(500, 0.35); // Happy meow
                        setTimeout(() => {
                            this.sounds.catMeow(550, 0.3); // Excited follow-up
                        }, 300);
                    }, 400);
                };
            }

            playFanfare() {
                const notes = [523, 659, 784, 1047]; // C, E, G, C (octave)
                notes.forEach((freq, index) => {
                    setTimeout(() => {
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();
                        
                        osc.connect(gain);
                        gain.connect(this.audioContext.destination);
                        
                        osc.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                        gain.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                        
                        osc.start();
                        osc.stop(this.audioContext.currentTime + 0.3);
                    }, index * 100);
                });
            }

            playFireworks() {
                // Multiple firework bursts
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();
                        const filter = this.audioContext.createBiquadFilter();
                        
                        osc.connect(filter);
                        filter.connect(gain);
                        gain.connect(this.audioContext.destination);
                        
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(200 + Math.random() * 200, this.audioContext.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.5);
                        
                        filter.type = 'lowpass';
                        filter.frequency.setValueAtTime(1000, this.audioContext.currentTime);
                        filter.frequency.exponentialRampToValueAtTime(100, this.audioContext.currentTime + 0.5);
                        
                        gain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                        
                        osc.start();
                        osc.stop(this.audioContext.currentTime + 0.5);
                    }, i * 200);
                }
            }

            playSound(soundName) {
                if (this.soundEnabled && this.audioContext && this.sounds[soundName]) {
                    // Resume audio context if suspended (required by some browsers)
                    if (this.audioContext.state === 'suspended') {
                        this.audioContext.resume().then(() => {
                            this.sounds[soundName]();
                        }).catch(error => {
                            console.log('Error resuming audio context:', error);
                        });
                    } else {
                        this.sounds[soundName]();
                    }
                }
            }

            toggleSound() {
                this.soundEnabled = !this.soundEnabled;
                const soundBtn = document.getElementById('sound-btn');
                const mobileSoundBtn = document.getElementById('mobile-sound-btn');
                
                if (soundBtn) {
                    soundBtn.textContent = this.soundEnabled ? 'üîä SOUND ON' : 'üîá SOUND OFF';
                }
                
                if (mobileSoundBtn) {
                    mobileSoundBtn.textContent = this.soundEnabled ? 'üîä' : 'üîá';
                }
                
                if (this.soundEnabled) {
                    this.addChatMessage('system', 'Sound effects enabled!');
                } else {
                    this.addChatMessage('system', 'Sound effects disabled!');
                }
                
                localStorage.setItem('fishingGameSoundEnabled', this.soundEnabled.toString());
            }

            toggleChat() {
                const chatSection = document.getElementById('chat-section');
                const isCollapsed = chatSection.classList.contains('collapsed');
                
                if (isCollapsed) {
                    chatSection.classList.remove('collapsed');
                    chatSection.classList.add('expanded');
                    localStorage.setItem('fishingGameChatExpanded', 'true');
                    // Focus input when expanded
                    setTimeout(() => {
                        const chatInput = document.getElementById('chat-input');
                        if (chatInput) chatInput.focus();
                    }, 100);
                } else {
                    chatSection.classList.remove('expanded');
                    chatSection.classList.add('collapsed');
                    localStorage.setItem('fishingGameChatExpanded', 'false');
                }
            }

            loadChatState() {
                const chatExpanded = localStorage.getItem('fishingGameChatExpanded');
                const chatSection = document.getElementById('chat-section');
                
                if (chatExpanded === 'true') {
                    chatSection.classList.remove('collapsed');
                    chatSection.classList.add('expanded');
                } else {
                    chatSection.classList.remove('expanded');
                    chatSection.classList.add('collapsed');
                }
            }

            showCongratulationsPopup(type, items) {
                const level = this.player.level;
                let title = '';
                let itemList = '';
                
                if (type === 'location') {
                    title = `Congratulations on reaching Level ${level}!`;
                    itemList = `You have unlocked new fishing locations:\n‚Ä¢ ${items.join('\n‚Ä¢ ')}`;
                } else if (type === 'tackle') {
                    title = `Congratulations on reaching Level ${level}!`;
                    itemList = `You have unlocked new tackle:\n‚Ä¢ ${items.join('\n‚Ä¢ ')}`;
                }
                
                // Create popup modal
                const popup = document.createElement('div');
                popup.className = 'congratulations-popup';
                popup.innerHTML = `
                    <div class="congratulations-content">
                        <div class="congratulations-header">
                            <h2>üéâ ${title} üéâ</h2>
                        </div>
                        <div class="congratulations-body">
                            <p>${itemList}</p>
                        </div>
                        <div class="congratulations-footer">
                            <button class="btn" onclick="this.parentElement.parentElement.parentElement.remove()">Awesome!</button>
                        </div>
                    </div>
                `;
                
                // Add CSS for the popup
                popup.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                    animation: fadeIn 0.5s ease-out;
                `;
                
                // Add CSS for the content
                const style = document.createElement('style');
                style.textContent = `
                    .congratulations-content {
                        background: linear-gradient(135deg, #001100, #003300);
                        border: 2px solid rgba(100, 200, 255, 0.4);
                        border-radius: 15px;
                        padding: 30px;
                        max-width: 500px;
                        text-align: center;
                        box-shadow: 0 0 30px rgba(100, 181, 246, 0.5);
                        animation: slideIn 0.5s ease-out;
                    }
                    
                    .congratulations-header h2 {
                        color: #ffff00;
                        margin: 0 0 20px 0;
                        font-size: 24px;
                        text-shadow: 0 0 10px rgba(255, 255, 0, 0.5);
                    }
                    
                    .congratulations-body {
                        color: #64b5f6;
                        font-size: 16px;
                        line-height: 1.6;
                        margin-bottom: 25px;
                        white-space: pre-line;
                    }
                    
                    .congratulations-footer .btn {
                        background: linear-gradient(135deg, #42a5f5 0%, #2196f3 100%);
                        color: #000;
                        border: none;
                        padding: 12px 30px;
                        font-size: 16px;
                        font-weight: bold;
                        border-radius: 8px;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    }
                    
                    .congratulations-footer .btn:hover {
                        background: #00cc00;
                        transform: scale(1.05);
                    }
                    
                    @keyframes fadeIn {
                        from { opacity: 0; }
                        to { opacity: 1; }
                    }
                    
                    @keyframes slideIn {
                        from { transform: translateY(-50px); opacity: 0; }
                        to { transform: translateY(0); opacity: 1; }
                    }
                `;
                
                document.head.appendChild(style);
                document.body.appendChild(popup);
                
                // Auto-remove after 10 seconds
                setTimeout(() => {
                    if (popup.parentElement) {
                        popup.remove();
                        style.remove();
                    }
                }, 10000);
            }

            setupEventListeners() {
                document.getElementById('cast-btn').addEventListener('click', () => this.castLine());
                document.getElementById('shop-btn').addEventListener('click', () => this.openShop());
                document.getElementById('tournament-btn').addEventListener('click', () => this.toggleTournament());
                document.getElementById('inventory-btn').addEventListener('click', () => this.openInventory());
                document.getElementById('help-btn').addEventListener('click', () => this.openHelp());
                document.getElementById('close-help').addEventListener('click', () => this.closeHelp());
                document.getElementById('sound-btn').addEventListener('click', () => this.toggleSound());
                
                // Load saved sound preference
                const savedSoundEnabled = localStorage.getItem('fishingGameSoundEnabled');
                if (savedSoundEnabled !== null) {
                    this.soundEnabled = savedSoundEnabled === 'true';
                    const soundBtn = document.getElementById('sound-btn');
                    const mobileSoundBtn = document.getElementById('mobile-sound-btn');
                    if (soundBtn) {
                        soundBtn.textContent = this.soundEnabled ? 'üîä SOUND ON' : 'üîá SOUND OFF';
                    }
                    if (mobileSoundBtn) {
                        mobileSoundBtn.textContent = this.soundEnabled ? 'üîä' : 'üîá';
                    }
                }
                
                // Initialize audio context on first user interaction
                this.initAudioOnInteraction();
                
                // Chat toggle
                document.getElementById('chat-toggle').addEventListener('click', () => this.toggleChat());

                // Login button
                document.getElementById('create-character-btn').addEventListener('click', () => {
                    const catEditor = document.getElementById('cat-editor');
                    if (catEditor) {
                        catEditor.style.display = catEditor.style.display === 'none' ? 'block' : 'none';
                    }
                });
                document.getElementById('login-btn').addEventListener('click', () => this.login());

                // Character System - New Integrated Approach
                function initializeCharacterSystem() {
                    // Load saved avatar options or use defaults - ensure complete structure
                    const playerOptions = this.player?.avatarOptions;
                    const savedOptions = {
                        colors: {
                            fur: playerOptions?.colors?.fur || '#f2a65a',
                            pattern: playerOptions?.colors?.pattern || '#d77f3f',
                            ear: playerOptions?.colors?.ear || '#c76b2a',
                            eye: playerOptions?.colors?.eye || '#1e2a3a',
                            belly: playerOptions?.colors?.belly || '#f8d7b1'
                        },
                        gear: {
                            hat: playerOptions?.gear?.hat || false,
                            glasses: playerOptions?.gear?.glasses || false,
                            vest: playerOptions?.gear?.vest || false
                        }
                    };

                    // Set initial values in editor - check if elements exist first
                    const furColorEl = document.getElementById('furColor');
                    const patColorEl = document.getElementById('patColor');
                    const eyeColorEl = document.getElementById('eyeColor');
                    const belColorEl = document.getElementById('belColor');
                    const gearHatEl = document.getElementById('gearHat');
                    const gearGlEl = document.getElementById('gearGl');
                    const gearVestEl = document.getElementById('gearVest');

                    if (furColorEl) furColorEl.value = savedOptions.colors.fur;
                    if (patColorEl) patColorEl.value = savedOptions.colors.pattern;
                    if (eyeColorEl) eyeColorEl.value = savedOptions.colors.eye;
                    if (belColorEl) belColorEl.value = savedOptions.colors.belly;
                    if (gearHatEl) gearHatEl.checked = savedOptions.gear.hat;
                    if (gearGlEl) gearGlEl.checked = savedOptions.gear.glasses;
                    if (gearVestEl) gearVestEl.checked = savedOptions.gear.vest;

                    // Update both previews
                    updateCharacterPreview();
                    updateLivePreview();

                    // Randomize button
                    const randomizeBtn = document.getElementById('randomize-cat-btn');
                    if (randomizeBtn) {
                        randomizeBtn.addEventListener('click', () => {
                            randomizeCatAppearance();
                        });
                    }

                    // Preview button
                    const previewBtn = document.getElementById('preview-cat-btn');
                    if (previewBtn) {
                        previewBtn.addEventListener('click', () => {
                            updateLivePreview();
                        });
                    }

                    // Save button
                    const saveBtn = document.getElementById('save-cat-look');
                    if (saveBtn) {
                        saveBtn.addEventListener('click', () => {
                            saveCatLook();
                        });
                    }

                    // Auto-update preview on color/gear changes
                    ['furColor', 'patColor', 'eyeColor', 'belColor', 'gearHat', 'gearGl', 'gearVest'].forEach(id => {
                        const element = document.getElementById(id);
                        if (element) {
                            element.addEventListener('change', () => {
                                updateCharacterPreview();
                                updateLivePreview();
                            });
                        }
                    });
                    
                    // Force initial preview update
                    setTimeout(() => {
                        updateCharacterPreview();
                        console.log('Character preview initialized');
                    }, 100);
                }

                function randomizeCatAppearance() {
                    const furColors = ['#f2a65a', '#8b4513', '#2f4f4f', '#ff69b4', '#32cd32', '#ff4500', '#9370db', '#20b2aa'];
                    const patternColors = ['#d77f3f', '#654321', '#1f3f3f', '#ff1493', '#228b22', '#ff6347', '#8a2be2', '#008b8b'];
                    const eyeColors = ['#1e2a3a', '#8b0000', '#006400', '#4b0082', '#ff8c00', '#dc143c', '#000080', '#2e8b57'];
                    const bellyColors = ['#f8d7b1', '#f5deb3', '#ffe4e1', '#f0f8ff', '#f0fff0', '#fff8dc', '#f5f5dc', '#ffe4b5'];

                    // Randomize colors
                    document.getElementById('furColor').value = furColors[Math.floor(Math.random() * furColors.length)];
                    document.getElementById('patColor').value = patternColors[Math.floor(Math.random() * patternColors.length)];
                    document.getElementById('eyeColor').value = eyeColors[Math.floor(Math.random() * eyeColors.length)];
                    document.getElementById('belColor').value = bellyColors[Math.floor(Math.random() * bellyColors.length)];

                    // Randomize gear (30% chance for each)
                    document.getElementById('gearHat').checked = Math.random() < 0.3;
                    document.getElementById('gearGl').checked = Math.random() < 0.3;
                    document.getElementById('gearVest').checked = Math.random() < 0.3;

                    // Update previews
                    updateCharacterPreview();
                    updateLivePreview();
                }

                function updateCharacterPreview() {
                    const colors = {
                        fur: document.getElementById('furColor')?.value || '#f2a65a',
                        pattern: document.getElementById('patColor')?.value || '#d77f3f',
                        ear: '#c76b2a',
                        eye: document.getElementById('eyeColor')?.value || '#1e2a3a',
                        belly: document.getElementById('belColor')?.value || '#f8d7b1',
                        whisker: '#2b2b2b'
                    };

                    const gear = {
                        hat: document.getElementById('gearHat')?.checked || false,
                        glasses: document.getElementById('gearGl')?.checked || false,
                        vest: document.getElementById('gearVest')?.checked || false
                    };

                    // Try 3D preview first
                    const preview3D = document.getElementById('character-preview-avatar');
                    const preview2D = document.getElementById('character-preview-avatar-2d');
                    
                    if ('WebGLRenderingContext' in window && window.mountPlayerCat3D) {
                        // Use 3D preview
                        if (preview3D) preview3D.style.display = 'block';
                        if (preview2D) preview2D.style.display = 'none';
                        
                        // Mount or update 3D cat - defer to ensure container is visible
                        if (preview3D) {
                            // Check if preview container is visible before mounting
                            const previewRect = preview3D.getBoundingClientRect();
                            if (previewRect.width > 0 && previewRect.height > 0 && preview3D.offsetParent !== null) {
                                // Container is visible, mount immediately
                                requestAnimationFrame(() => {
                                    window.mountPlayerCat3D('preview', {
                                        furColor: colors.fur,
                                        scale: 0.8
                                    });
                                });
                            }
                            // If not visible, mount will happen when updateCharacterPreview is called again
                            // when the character selection panel becomes visible
                        }
                    } else {
                        // Fallback to 2D preview
                        if (preview3D) preview3D.style.display = 'none';
                        if (preview2D) preview2D.style.display = 'block';
                        
                        if (window.renderCatRig && preview2D) {
                            window.renderCatRig(preview2D, { colors, gear });
                        }
                    }
                }

                function updateLivePreview() {
                    const colors = {
                        fur: document.getElementById('furColor')?.value || '#f2a65a',
                        pattern: document.getElementById('patColor')?.value || '#d77f3f',
                        ear: '#c76b2a',
                        eye: document.getElementById('eyeColor')?.value || '#1e2a3a',
                        belly: document.getElementById('belColor')?.value || '#f8d7b1',
                        whisker: '#2b2b2b'
                    };

                    const gear = {
                        hat: document.getElementById('gearHat')?.checked || false,
                        glasses: document.getElementById('gearGl')?.checked || false,
                        vest: document.getElementById('gearVest')?.checked || false
                    };

                    const previewContainer = document.getElementById('live-cat-preview');
                    if (window.renderCatRig && previewContainer) {
                        window.renderCatRig(previewContainer, { colors, gear });
                    }
                }

                function saveCatLook() {
                    const colors = {
                        fur: document.getElementById('furColor')?.value || '#f2a65a',
                        pattern: document.getElementById('patColor')?.value || '#d77f3f',
                        ear: '#c76b2a',
                        eye: document.getElementById('eyeColor')?.value || '#1e2a3a',
                        belly: document.getElementById('belColor')?.value || '#f8d7b1',
                        whisker: '#2b2b2b'
                    };

                    const gear = {
                        hat: document.getElementById('gearHat')?.checked || false,
                        glasses: document.getElementById('gearGl')?.checked || false,
                        vest: document.getElementById('gearVest')?.checked || false
                    };

                    // Save to player data - ensure player exists
                    if (this.player) {
                        this.player.avatarOptions = { colors, gear, type: 'cat' };
                        this.saveGameData();
                    }

                    // Show success message
                    const saveBtn = document.getElementById('save-cat-look');
                    if (saveBtn) {
                        const originalText = saveBtn.textContent;
                        saveBtn.textContent = '‚úÖ Saved!';
                        saveBtn.style.background = 'linear-gradient(135deg, #4caf50 0%, #2e7d32 100%)';
                        
                        setTimeout(() => {
                            saveBtn.textContent = originalText;
                            saveBtn.style.background = 'linear-gradient(135deg, #ff7043 0%, #f4511e 100%)';
                        }, 2000);
                    }

                    console.log('Cat look saved:', colors, gear);
                }

                // Initialize the character system
                initializeCharacterSystem.call(this);

                // Inventory tab buttons
                document.querySelectorAll('.inventory-tabs .tab-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const tabName = e.currentTarget.dataset.tab || e.target.closest('.tab-btn')?.dataset.tab;
                        if (tabName) {
                            this.switchInventoryTab(tabName);
                        }
                    });
                });

                // Tackle shop buttons (delegated event listener)
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('tackle-btn')) {
                        const action = e.target.dataset.action;
                        const category = e.target.dataset.category;
                        const index = parseInt(e.target.dataset.index);
                        
                        if (action === 'buy') {
                            this.buyTackle(category, index);
                        } else if (action === 'equip') {
                            this.equipTackle(category, index);
                        }
                    }
                });

                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    // Spacebar to cast (only when not in input fields)
                    if (e.code === 'Space' && !['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
                        e.preventDefault();
                        if (!this.isCasting) {
                            this.castLine();
                        }
                    }
                });

                // Mouse interaction with water
                this.setupWaterInteractions();

                // Tackle shop modal events
                document.getElementById('close-shop').addEventListener('click', () => this.closeShop());

                // Mobile button handlers
                const mobileCastBtn = document.getElementById('mobile-cast-btn');
                const mobileShopBtn = document.getElementById('mobile-shop-btn');
                const mobileTournamentBtn = document.getElementById('mobile-tournament-btn');
                const mobileInventoryBtn = document.getElementById('mobile-inventory-btn');
                const mobileSaveBtn = document.getElementById('mobile-save-btn');
                const mobileExportBtn = document.getElementById('mobile-export-btn');
                const mobileSoundBtn = document.getElementById('mobile-sound-btn');
                const mobileHelpBtn = document.getElementById('mobile-help-btn');

                if (mobileCastBtn) mobileCastBtn.addEventListener('click', () => this.castLine());
                if (mobileShopBtn) mobileShopBtn.addEventListener('click', () => this.openShop());
                if (mobileTournamentBtn) mobileTournamentBtn.addEventListener('click', () => this.toggleTournament());
                if (mobileInventoryBtn) mobileInventoryBtn.addEventListener('click', () => this.openInventory());
                if (mobileSaveBtn) mobileSaveBtn.addEventListener('click', () => this.manualSave());
                if (mobileExportBtn) mobileExportBtn.addEventListener('click', () => this.exportGameData());
                if (mobileSoundBtn) mobileSoundBtn.addEventListener('click', () => this.toggleSound());
                if (mobileHelpBtn) mobileHelpBtn.addEventListener('click', () => this.openHelp());
                
                // Desktop tab switching
                document.querySelectorAll('.desktop-tab-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const tabName = btn.dataset.tab;
                        
                        // Remove active class from all tabs and content
                        document.querySelectorAll('.desktop-tab-btn').forEach(b => b.classList.remove('active'));
                        document.querySelectorAll('.desktop-tab-content').forEach(c => c.classList.remove('active'));
                        
                        // Add active class to clicked tab and corresponding content
                        btn.classList.add('active');
                        const content = document.getElementById(`desktop-tab-${tabName}`);
                        if (content) {
                            content.classList.add('active');
                            
                            // Render content based on tab
                            if (tabName === 'collection') {
                                this.renderDesktopCollection();
                            } else if (tabName === 'stats') {
                                this.renderDesktopStats();
                            } else if (tabName === 'recent') {
                                this.renderDesktopRecent();
                            }
                        }
                    });
                });

                // Mobile tab switching
                document.querySelectorAll('.mobile-tab-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const tabName = btn.dataset.tab;
                        
                        // Remove active class from all tabs and panels
                        document.querySelectorAll('.mobile-tab-btn').forEach(b => b.classList.remove('active'));
                        document.querySelectorAll('.mobile-tab-panel').forEach(p => p.classList.remove('active'));
                        
                        // Add active class to clicked tab and corresponding panel
                        btn.classList.add('active');
                        const panel = document.getElementById(`mobile-tab-${tabName}`);
                        if (panel) panel.classList.add('active');
                        
                        // Update inventory display when switching to inventory tab
                        if (tabName === 'inventory') {
                            this.updateMobileInventory();
                        }
                        
                        // Update collection display when switching to collection tab
                        if (tabName === 'collection') {
                            this.renderFishCollection();
                        }
                    });
                });

                document.getElementById('tackle-shop-modal').addEventListener('click', (e) => {
                    if (e.target.id === 'tackle-shop-modal') {
                        this.closeShop();
                    }
                });

                // Inventory modal events
                document.getElementById('close-inventory').addEventListener('click', () => this.closeInventory());
                document.getElementById('inventory-modal').addEventListener('click', (e) => {
                    if (e.target.id === 'inventory-modal') {
                        this.closeInventory();
                    }
                });

                // Shop tab events (only for tackle shop tabs)
                document.querySelectorAll('#tackle-shop-modal .tab-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.switchShopTab(e.target.dataset.tab));
                });

                document.getElementById('chat-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && e.target.value.trim()) {
                        this.sendMessage(e.target.value);
                        e.target.value = '';
                    }
                });
                
                // Help modal events
                document.getElementById('help-modal').addEventListener('click', (e) => {
                    if (e.target.id === 'help-modal') {
                        this.closeHelp();
                    }
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Don't trigger shortcuts when typing in inputs
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    
                    if (e.key === ' ' || e.key === 'Spacebar') {
                        e.preventDefault();
                        this.castLine();
                    } else if (e.key === 's' || e.key === 'S') {
                        e.preventDefault();
                        this.openShop();
                    } else if (e.key === 't' || e.key === 'T') {
                        e.preventDefault();
                        this.toggleTournament();
                    } else if (e.key === 'i' || e.key === 'I') {
                        e.preventDefault();
                        this.openInventory();
                    } else if (e.key === 'h' || e.key === 'H') {
                        e.preventDefault();
                        this.openHelp();
                    }
                });
            }

            login() {
                const name = document.getElementById('player-name-input').value.trim();
                if (!name) {
                    alert('Please enter your name!');
                    return;
                }

                this.player.name = name;
                
                // Use cat rig system instead of robohash
                this.player.character = 'cat-rig'; // Mark as using cat rig system
                
                // Ensure avatarOptions exist with proper structure
                if (!this.player.avatarOptions) {
                    this.player.avatarOptions = {
                        colors: { fur: '#f2a65a', pattern: '#d77f3f', ear: '#c76b2a', eye: '#1e2a3a', belly: '#f8d7b1' },
                        gear: { hat: false, glasses: false, vest: false },
                        type: 'cat'
                    };
                } else {
                    // Ensure nested structure exists
                    if (!this.player.avatarOptions.colors) {
                        this.player.avatarOptions.colors = { fur: '#f2a65a', pattern: '#d77f3f', ear: '#c76b2a', eye: '#1e2a3a', belly: '#f8d7b1' };
                    }
                    if (!this.player.avatarOptions.gear) {
                        this.player.avatarOptions.gear = { hat: false, glasses: false, vest: false };
                    }
                    if (!this.player.avatarOptions.type) {
                        this.player.avatarOptions.type = 'cat';
                    }
                }
                
                this.saveGameData();
                document.getElementById('login-screen').classList.add('hidden');
                this.addChatMessage('system', `${name} joined Kitty Creek Fishing Club! üê±`);
                this.positionPlayers(); // Reposition players with new name
                
                // Join multiplayer game
                this.joinGame();
                this.updateDisplay();
                this.saveGameData(); // Save character selection
            }


            positionPlayers() {
                const fishermanRow = document.getElementById('fisherman-row');
                const lake = document.getElementById('fishing-lake');
                const mobileFishermanRow = document.getElementById('mobile-fisherman-row');
                const mobileLake = document.getElementById('mobile-fishing-lake');
                
                // Don't clear fisherman rows - reuse existing DOM to prevent disposal churn
                // Only clear fishing lines and hooks from lakes
                if (lake) {
                    // Remove all fishing lines and hooks
                    lake.querySelectorAll('.fishing-line').forEach(l => l.remove());
                    lake.querySelectorAll('.hook').forEach(h => h.remove());
                    // Also remove any orphaned splashes
                    lake.querySelectorAll('.hook-splash, .hook-landing-splash').forEach(s => s.remove());
                }
                if (mobileLake) {
                    // Remove all fishing lines and hooks
                    mobileLake.querySelectorAll('.fishing-line').forEach(l => l.remove());
                    mobileLake.querySelectorAll('.hook').forEach(h => h.remove());
                    // Also remove any orphaned splashes
                    mobileLake.querySelectorAll('.hook-splash, .hook-landing-splash').forEach(s => s.remove());
                }
                
                // Clean up only disconnected/removed players from fisherman rows
                const existingPlayerIds = new Set([window.safeKey(this.player.name)]);
                this.otherPlayers.forEach(p => existingPlayerIds.add(window.safeKey(p.name)));
                
                // Remove fisherman elements for players no longer in the game
                if (fishermanRow) {
                    fishermanRow.querySelectorAll('.fisherman').forEach(fisher => {
                        const cat3d = fisher.querySelector('.cat3d');
                        if (cat3d) {
                            const playerId = cat3d.dataset.playerId || cat3d.dataset.cat3d;
                            if (playerId && !existingPlayerIds.has(window.safeKey(playerId))) {
                                // Player left, dispose and remove
                                if (cat3d.__renderer && window.CatRigs) {
                                    const rig = window.CatRigs.map.get(window.safeKey(playerId));
                                    if (rig) rig.dispose();
                                }
                                fisher.remove();
                            }
                        }
                    });
                }
                
                if (mobileFishermanRow) {
                    mobileFishermanRow.querySelectorAll('.mobile-fisherman').forEach(fisher => {
                        const cat3d = fisher.querySelector('.cat3d');
                        if (cat3d) {
                            const playerId = cat3d.dataset.playerId || cat3d.dataset.cat3d;
                            if (playerId && !existingPlayerIds.has(window.safeKey(playerId))) {
                                // Player left, dispose and remove
                                if (cat3d.__renderer && window.CatRigs) {
                                    const rig = window.CatRigs.map.get(window.safeKey(playerId));
                                    if (rig) rig.dispose();
                                }
                                fisher.remove();
                            }
                        }
                    });
                }
                
                // Add current player - reuse existing DOM if present
                let playerFisher = fishermanRow?.querySelector('#player-fisher');
                const useCatRig = this.player.character === 'cat-rig' || this.player.avatarOptions?.type === 'cat';
                const isMobile = window.matchMedia('(max-width: 768px)').matches;
                
                if (!playerFisher) {
                    playerFisher = document.createElement('div');
                    playerFisher.className = 'fisherman you';
                    playerFisher.id = 'player-fisher';
                    
                    if (useCatRig) {
                        if (!isMobile) {
                            const key = window.safeKey(this.player.name);
                            playerFisher.innerHTML = `
                                <div class="cat3d" data-player-id="${this.player.name}" data-cat3d="${key}"></div>
                                <div class="cat-rig" data-player-id="${this.player.name}" style="display: none;"></div>
                                <div class="fisherman-name">${this.player.name}</div>
                            `;
                        } else {
                            playerFisher.innerHTML = `
                                <div class="cat-rig" data-player-id="${this.player.name}" style="display: none;"></div>
                                <div class="fisherman-name">${this.player.name}</div>
                            `;
                        }
                    } else {
                        playerFisher.innerHTML = `
                            <div class="fisherman-character">${this.player.character || 'üë®'}</div>
                            <div class="fisherman-name">${this.player.name}</div>
                        `;
                    }
                    if (fishermanRow) fishermanRow.appendChild(playerFisher);
                } else {
                    // Update name if it changed
                    const nameEl = playerFisher.querySelector('.fisherman-name');
                    if (nameEl) nameEl.textContent = this.player.name;
                    
                    // Update data-cat3d attribute if cat3d container exists
                    const cat3dEl = playerFisher.querySelector('.cat3d');
                    if (cat3dEl && useCatRig) {
                        const key = window.safeKey(this.player.name);
                        cat3dEl.setAttribute('data-cat3d', key);
                        cat3dEl.setAttribute('data-player-id', this.player.name);
                    }
                }
                
                // Ensure player's cat mounts immediately after row is created
                if (useCatRig && !isMobile && playerFisher?.querySelector('.cat3d') && window.mountPlayerCat3D) {
                    const my3d = playerFisher.querySelector('.cat3d');
                    requestAnimationFrame(() => {
                        const r = my3d.getBoundingClientRect();
                        if (r.width > 0 && r.height > 0 && my3d.offsetParent !== null) {
                            window.mountPlayerCat3D(this.player.name, {
                                furColor: this.player?.avatarOptions?.colors?.fur || '#c8a079',
                                scale: 0.9,
                                profile: 'desktop'
                            });
                        }
                    });
                }

                // Add mobile player - reuse existing DOM if present
                let mobilePlayerFisher = mobileFishermanRow?.querySelector('#mobile-player-fisher');
                if (!mobilePlayerFisher) {
                    mobilePlayerFisher = document.createElement('div');
                    mobilePlayerFisher.className = 'mobile-fisherman';
                    mobilePlayerFisher.id = 'mobile-player-fisher';
                    
                    if (useCatRig && isMobile) {
                        const key = window.safeKey(this.player.name);
                        mobilePlayerFisher.innerHTML = `
                            <div class="cat3d" data-player-id="${this.player.name}" data-cat3d="${key}"></div>
                            <div class="cat-rig" data-player-id="${this.player.name}" style="display: none;"></div>
                            <div class="mobile-fisherman-name">${this.player.name}</div>
                        `;
                    } else {
                        mobilePlayerFisher.innerHTML = `
                            <div class="mobile-fisherman-character">${this.player.character || 'üë®'}</div>
                            <div class="mobile-fisherman-name">${this.player.name}</div>
                        `;
                    }
                    if (mobileFishermanRow) mobileFishermanRow.appendChild(mobilePlayerFisher);
                } else {
                    const nameEl = mobilePlayerFisher.querySelector('.mobile-fisherman-name');
                    if (nameEl) nameEl.textContent = this.player.name;
                    
                    // Update data-cat3d attribute if cat3d container exists
                    const cat3dEl = mobilePlayerFisher.querySelector('.cat3d');
                    if (cat3dEl && useCatRig && isMobile) {
                        const key = window.safeKey(this.player.name);
                        cat3dEl.setAttribute('data-cat3d', key);
                        cat3dEl.setAttribute('data-player-id', this.player.name);
                    }
                }

                // Defer mount to ensure DOM is ready and avoid race conditions
                if (useCatRig && window.mountPlayerCat3D) {
                    requestAnimationFrame(() => {
                        if (!isMobile && playerFisher?.querySelector('.cat3d')) {
                            const cat3dEl = playerFisher.querySelector('.cat3d');
                            // Only mount if container is visible
                            const rect = cat3dEl.getBoundingClientRect();
                            if (rect.width > 0 && rect.height > 0 && cat3dEl.offsetParent !== null) {
                                const opts = this.player.avatarOptions || {
                                    colors: { fur: '#f2a65a', pattern: '#d77f3f', ear: '#c76b2a', eye: '#1e2a3a', belly: '#f8d7b1' },
                                    gear: { hat: false, glasses: false, vest: false }
                                };
                                window.mountPlayerCat3D(this.player.name, {
                                    furColor: opts?.colors?.fur || '#f2a65a',
                                    scale: 0.8,
                                    profile: 'desktop'
                                });
                            }
                        } else if (isMobile && mobilePlayerFisher?.querySelector('.cat3d')) {
                            const cat3dEl = mobilePlayerFisher.querySelector('.cat3d');
                            // Only mount if container is visible (mobile layout must be shown)
                            const rect = cat3dEl.getBoundingClientRect();
                            if (rect.width > 0 && rect.height > 0 && cat3dEl.offsetParent !== null) {
                                const opts = this.player.avatarOptions || {
                                    colors: { fur: '#f2a65a', pattern: '#d77f3f', ear: '#c76b2a', eye: '#1e2a3a', belly: '#f8d7b1' },
                                    gear: { hat: false, glasses: false, vest: false }
                                };
                                window.mountPlayerCat3D(this.player.name, {
                                    furColor: opts?.colors?.fur || '#f2a65a',
                                    scale: 0.6,
                                    profile: 'mobile'
                                });
                            }
                        }
                    });
                }
                
                // Skip other players - only showing player's cat
                // No AI or other players for now
                /*
                // Determine which players get 3D (limit to MAX_3D_RENDERERS)
                const eligible3D = window.choose3DPlayers(this.otherPlayers, this.player.name);
                
                // Add other players - reuse existing DOM when possible
                this.otherPlayers.forEach((p) => {
                    const playerKey = window.safeKey(p.name);
                    const shouldUse3D = eligible3D.has(playerKey);
                    
                    // Desktop version
                    if (!isMobile) {
                        let fisher = fishermanRow?.querySelector(`.fisherman.other[data-player-key="${playerKey}"]`);
                        
                        if (!fisher) {
                            fisher = document.createElement('div');
                            fisher.className = 'fisherman other';
                            fisher.dataset.playerKey = playerKey;
                            fisher.title = `${p.name} - Level ${p.level}`;
                            
                            if (shouldUse3D) {
                                fisher.innerHTML = `
                                    <div class="cat3d" data-player-id="${p.name}" data-cat3d="${playerKey}"></div>
                                    <div class="cat-rig" data-player-id="${p.name}" style="display:none;"></div>
                                    <div class="fisherman-name">${p.name}</div>
                                `;
                            } else {
                                fisher.innerHTML = `
                                    <div class="cat-rig" data-player-id="${p.name}"></div>
                                    <div class="fisherman-name">${p.name}</div>
                                `;
                            }
                            if (fishermanRow) fishermanRow.appendChild(fisher);
                        } else {
                            // Update name/level
                            const nameEl = fisher.querySelector('.fisherman-name');
                            if (nameEl) nameEl.textContent = p.name;
                            fisher.title = `${p.name} - Level ${p.level}`;
                        }
                        
                        // Mount 3D only for eligible players, deferred to avoid race conditions
                        if (shouldUse3D && fisher.querySelector('.cat3d') && window.mountPlayerCat3D) {
                            requestAnimationFrame(() => {
                                const cat3dEl = fisher.querySelector('.cat3d');
                                // Only mount if container is visible
                                if (cat3dEl) {
                                    const rect = cat3dEl.getBoundingClientRect();
                                    if (rect.width > 0 && rect.height > 0 && cat3dEl.offsetParent !== null) {
                                        window.mountPlayerCat3D(p.name, {
                                            furColor: p?.avatarOptions?.colors?.fur || '#c8a079',
                                            scale: 0.8,
                                            profile: 'desktop'
                                        });
                                    }
                                }
                            });
                        } else if (!shouldUse3D && fisher.querySelector('.cat-rig')) {
                            // Use 2D for non-eligible players
                            const rig = fisher.querySelector('.cat-rig');
                            if (rig && window.renderCatRig) {
                                window.renderCatRig(rig, p.avatarOptions || {});
                            }
                        }
                    }

                    // Mobile version
                    if (isMobile) {
                        let mobileFisher = mobileFishermanRow?.querySelector(`.mobile-fisherman[data-player-key="${playerKey}"]`);
                        
                        if (!mobileFisher) {
                            mobileFisher = document.createElement('div');
                            mobileFisher.className = 'mobile-fisherman';
                            mobileFisher.dataset.playerKey = playerKey;
                            
                            if (shouldUse3D) {
                                mobileFisher.innerHTML = `
                                    <div class="cat3d" data-player-id="${p.name}" data-cat3d="${playerKey}"></div>
                                    <div class="cat-rig" data-player-id="${p.name}" style="display:none;"></div>
                                    <div class="mobile-fisherman-name">${p.name}</div>
                                `;
                            } else {
                                mobileFisher.innerHTML = `
                                    <div class="cat-rig" data-player-id="${p.name}"></div>
                                    <div class="mobile-fisherman-name">${p.name}</div>
                                `;
                            }
                            if (mobileFishermanRow) mobileFishermanRow.appendChild(mobileFisher);
                        } else {
                            const nameEl = mobileFisher.querySelector('.mobile-fisherman-name');
                            if (nameEl) nameEl.textContent = p.name;
                        }
                        
                        // Mount 3D only for eligible players, deferred - respect chooser limit
                        if (shouldUse3D && mobileFisher.querySelector('.cat3d') && window.mountPlayerCat3D) {
                            requestAnimationFrame(() => {
                                const cat3dEl = mobileFisher.querySelector('.cat3d');
                                // Only mount if container is visible (mobile layout must be shown)
                                if (cat3dEl) {
                                    const rect = cat3dEl.getBoundingClientRect();
                                    if (rect.width > 0 && rect.height > 0 && cat3dEl.offsetParent !== null) {
                                        window.mountPlayerCat3D(p.name, {
                                            furColor: p?.avatarOptions?.colors?.fur || '#c8a079',
                                            scale: 0.6,
                                            profile: 'mobile'
                                        });
                                    }
                                }
                            });
                        } else if (!shouldUse3D && mobileFisher.querySelector('.cat-rig')) {
                            const rig = mobileFisher.querySelector('.cat-rig');
                            if (rig && window.renderCatRig) {
                                window.renderCatRig(rig, p.avatarOptions || {});
                            }
                        }
                    }
                });
                */ // End commented other players section
            }

            createAnimatedRipples() {
                const ripplesContainer = document.getElementById('ripples');
                const mobileRipplesContainer = document.getElementById('mobile-ripples');
                
                // Create multiple ripples at random positions
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        if (ripplesContainer) this.createRipple(ripplesContainer);
                        if (mobileRipplesContainer) this.createRipple(mobileRipplesContainer);
                    }, i * 500); // Stagger the creation
                }
                
                // Continue creating ripples periodically
                setInterval(() => {
                    if (ripplesContainer) this.createRipple(ripplesContainer);
                    if (mobileRipplesContainer) this.createRipple(mobileRipplesContainer);
                }, 2000);
                
                // Create wave ripples and fish shadows
                this.createWaterEffects();
            }

            createWaterEffects() {
                const lake = document.getElementById('fishing-lake');
                const mobileLake = document.getElementById('mobile-fishing-lake');
                
                // Create fish shadows swimming randomly
                for (let i = 0; i < 4; i++) {
                    if (lake) {
                        const fish = document.createElement('div');
                        fish.className = 'fish-shadow';
                        fish.style.top = (15 + i * 20) + '%';
                        fish.style.left = Math.random() * 80 + 10 + '%';
                        lake.appendChild(fish);
                        this.startRandomFishSwim(fish);
                    }
                    
                    if (mobileLake) {
                        const mobileFish = document.createElement('div');
                        mobileFish.className = 'fish-shadow';
                        mobileFish.style.top = (15 + i * 20) + '%';
                        mobileFish.style.left = Math.random() * 80 + 10 + '%';
                        mobileLake.appendChild(mobileFish);
                        this.startRandomFishSwim(mobileFish);
                    }
                }
            }

            startRandomFishSwim(fishElement) {
                const moveRandomly = () => {
                    const lake = fishElement.parentElement;
                    if (!lake) return;
                    
                    const rect = lake.getBoundingClientRect();
                    const fishRect = fishElement.getBoundingClientRect();
                    
                    // Get current position in pixels
                    const currentLeft = fishRect.left - rect.left;
                    const currentTop = fishRect.top - rect.top;
                    
                    // Pick a random new position anywhere in the lake
                    const newLeft = Math.random() * (rect.width - 40);
                    const newTop = Math.random() * (rect.height - 20);
                    
                    // Calculate distance and duration
                    const distance = Math.sqrt(
                        Math.pow(newLeft - currentLeft, 2) + Math.pow(newTop - currentTop, 2)
                    );
                    const duration = (distance / 50) * 1000; // Adjust speed
                    
                    // Move to new position
                    fishElement.style.transition = `all ${duration}ms ease-in-out`;
                    fishElement.style.left = newLeft + 'px';
                    fishElement.style.top = newTop + 'px';
                    
                    // Flip fish direction
                    if (newLeft > currentLeft) {
                        fishElement.style.transform = 'scaleX(1)';
                    } else {
                        fishElement.style.transform = 'scaleX(-1)';
                    }
                    
                    // Schedule next random movement
                    setTimeout(moveRandomly, duration + 2000 + Math.random() * 3000);
                };
                
                // Start first movement
                setTimeout(moveRandomly, Math.random() * 2000);
            }

            createRipple(container) {
                const ripple = document.createElement('div');
                ripple.className = 'ripple';
                
                // Random position within the lake
                const x = Math.random() * 80 + 10; // 10% to 90% of width
                const y = Math.random() * 80 + 10; // 10% to 90% of height
                const size = Math.random() * 30 + 20; // 20px to 50px
                
                ripple.style.left = x + '%';
                ripple.style.top = y + '%';
                ripple.style.width = size + 'px';
                ripple.style.height = size + 'px';
                
                // Random animation delay
                ripple.style.animationDelay = Math.random() * 2 + 's';
                
                container.appendChild(ripple);
                
                // Remove ripple after animation completes
                setTimeout(() => {
                    if (ripple.parentNode) {
                        ripple.parentNode.removeChild(ripple);
                    }
                }, 4000);
            }

            initializeWaterEffects() {
                // Check for low-end device performance
                const isLowEnd = navigator.hardwareConcurrency <= 2 || 
                                navigator.deviceMemory <= 2 || 
                                /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                if (isLowEnd) {
                    // Disable water distortion on low-end devices
                    document.querySelectorAll('.fishing-lake').forEach(lake => {
                        lake.classList.add('low-performance');
                    });
                }
                
                // Start water noise animation
                this.startWaterNoiseAnimation();
                
                // Start caustics animation
                this.startCausticsAnimation();
                
                // Install ripple effects
                this.installRippleEffects();
                
                // Initialize splash system
                this.initializeSplashSystem();
                
                // Initialize cat rig system
                this.initializeCatRigSystem();
            }

            startWaterNoiseAnimation() {
                const turb = document.getElementById('waterNoise');
                if (!turb) return;
                
                let t = 0;
                let rafId;

                const tick = () => {
                    // Tiny drift; keep it very subtle
                    t += 0.0025;
                    const x = 0.006 + Math.sin(t) * 0.002;
                    const y = 0.015 + Math.cos(t * 0.8) * 0.002;
                    turb.setAttribute('baseFrequency', `${x.toFixed(4)} ${y.toFixed(4)}`);
                    rafId = requestAnimationFrame(tick);
                };

                // Honor reduced motion
                const media = window.matchMedia('(prefers-reduced-motion: reduce)');
                if (media.matches) return;
                tick();
            }

            startCausticsAnimation() {
                // Caustics now use CSS animation instead of JavaScript
                // The causticsDrift keyframe handles the gentle movement
                console.log('Caustics animation started via CSS keyframes');
            }

            installRippleEffects() {
                const lake = document.querySelector('.fishing-lake');
                const mobileLake = document.querySelector('.mobile-fishing-lake');
                
                if (!lake && !mobileLake) return;
                
                // Throttle helper
                const throttle = (fn, wait) => {
                    let t = 0;
                    return (...a) => {
                        const n = Date.now();
                        if (n - t >= wait) {
                            t = n;
                            fn(...a);
                        }
                    };
                };

                const spawnRippleAt = (lakeEl, x, y, invert = false, scaleBoost = 1) => {
                    const r = document.createElement('div');
                    r.className = invert ? 'water-ripple-invert' : 'water-ripple';
                    r.style.left = x + 'px';
                    r.style.top = y + 'px';
                    r.style.animationDuration = invert ? `${700*scaleBoost|0}ms` : `${1000*scaleBoost|0}ms`;
                    lakeEl.appendChild(r);
                    r.addEventListener('animationend', () => r.remove());
                };

                // Install pointer ripples
                const installPointerRipples = (lakeEl) => {
                    if (!lakeEl) return;
                    const rect = () => lakeEl.getBoundingClientRect();
                    const onMove = throttle((e) => {
                        const p = e.touches ? e.touches[0] : e;
                        spawnRippleAt(lakeEl, p.clientX - rect().left, p.clientY - rect().top, false, 1);
                    }, 150);
                    lakeEl.addEventListener('pointermove', onMove, {passive: true});
                    lakeEl.addEventListener('touchmove', onMove, {passive: true});
                };

                installPointerRipples(lake);
                installPointerRipples(mobileLake);
            }

            // Realistic Splash System with Canvas and Particles
            initializeSplashSystem() {
                const RM = matchMedia('(prefers-reduced-motion: reduce)').matches;

                class SplashSystem {
                    constructor(lakeEl, canvas) {
                        this.lake = lakeEl;
                        this.canvas = canvas;
                        this.ctx = canvas.getContext('2d');
                        this.particles = [];
                        this.rings = [];
                        this.last = performance.now();
                        this.running = false;
                        this.resize();
                        window.addEventListener('resize', () => this.resize());
                        
                        // Always start the splash system (it will respect reduced motion in individual effects)
                        this.start();
                        
                        console.log('Splash system initialized for:', lakeEl.id);
                    }
                    
                    resize() {
                        const r = this.lake.getBoundingClientRect();
                        if (r.width === 0 || r.height === 0) {
                            console.log('Lake has zero dimensions, skipping resize');
                            return;
                        }
                        
                        this.canvas.width = r.width * devicePixelRatio;
                        this.canvas.height = r.height * devicePixelRatio;
                        this.ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
                        
                        console.log('Canvas resized to:', r.width, 'x', r.height, 'devicePixelRatio:', devicePixelRatio);
                    }
                    
                    start() {
                        if (this.running) return;
                        this.running = true;
                        const loop = (t) => {
                            if (!this.running) return;
                            const dt = Math.min(0.033, (t - this.last) / 1000); // clamp
                            this.last = t;
                            this.update(dt);
                            this.draw();
                            requestAnimationFrame(loop);
                        };
                        requestAnimationFrame(loop);
                    }
                    
                    stop() { this.running = false; }

                    // world coords from lake-relative pixel x,y
                    emitSplash(x, y, power = 1, kind = 'impact') {
                        if (RM) return;

                        // Emit splash effect
                        // Debug logging removed for cleaner console

                        // Crown jets (the upward droplets)
                        const jets = Math.floor(12 + power * 10);
                        for (let i = 0; i < jets; i++) {
                            const a = (i / jets) * Math.PI * 2 + (Math.random() - 0.5) * 0.35;
                            const spd = 120 + Math.random() * 140 * power;
                            const vx = Math.cos(a) * spd * (0.25 + Math.random() * 0.75);
                            const vy = -(180 + Math.random() * 220 * power); // upward impulse
                            this.particles.push(this.makeDrop(x, y, vx, vy, power));
                        }

                        // Mist (small, short-lived, glints)
                        const mistN = Math.floor(30 + power * 40);
                        for (let i = 0; i < mistN; i++) {
                            const vx = (Math.random() - 0.5) * 180 * power;
                            const vy = -Math.random() * 120 * power;
                            const p = this.makeDrop(x, y, vx, vy, power * 0.5);
                            p.size *= 0.5; p.life *= 0.6; p.alpha = 0.6;
                            this.particles.push(p);
                        }

                        // Surface ring
                        this.rings.push({
                            x, y, r: 4, w: 2, alpha: 0.75, growth: 110 + 80 * power, fade: 0.85
                        });

                        console.log('Created', jets, 'jets,', mistN, 'mist particles, and 1 ring. Total particles:', this.particles.length);

                        // Brief caustics kick if you added that layer (optional)
                        const c = document.getElementById('caustics-layer');
                        const mobileC = document.getElementById('mobile-caustics-layer');
                        if (c) { 
                            c.style.transition = 'opacity .18s ease'; 
                            c.style.opacity = '0.3';
                            setTimeout(() => c.style.opacity = '0.22', 200); 
                        }
                        if (mobileC) { 
                            mobileC.style.transition = 'opacity .18s ease'; 
                            mobileC.style.opacity = '0.3';
                            setTimeout(() => mobileC.style.opacity = '0.22', 200); 
                        }
                    }

                    // suction ring for fish bite (reverse feel)
                    emitSuction(x, y, power = 1) {
                        if (RM) return;
                        this.rings.push({ x, y, r: 2, w: 2, alpha: 0.7, growth: 90, fade: 0.9, invert: true });
                        // a few downward glugs
                        for (let i = 0; i < 6; i++) {
                            const vx = (Math.random() - 0.5) * 40;
                            const vy = 30 + Math.random() * 60; // down
                            const p = this.makeDrop(x, y, vx, vy, 0.6);
                            p.alpha = 0.5; p.gravity = 250; p.drag = 0.96;
                            this.particles.push(p);
                        }
                        if (navigator.vibrate) navigator.vibrate(12);
                    }

                    // soft wake while reeling/fighting
                    emitWake(x, y) {
                        if (RM) return;
                        // tiny ring + a couple of small droplets
                        this.rings.push({ x, y, r: 1.5, w: 1.5, alpha: 0.45, growth: 60, fade: 0.92 });
                        for (let i = 0; i < 2; i++) {
                            const vx = (Math.random() - 0.5) * 60;
                            const vy = -(10 + Math.random() * 30);
                            const p = this.makeDrop(x, y, vx, vy, 0.3);
                            p.size *= 0.6; p.alpha = 0.5;
                            this.particles.push(p);
                        }
                    }

                    makeDrop(x, y, vx, vy, scale) {
                        return {
                            x, y,
                            vx, vy,
                            size: 2.5 * (0.8 + Math.random() * 0.8) * (0.7 + 0.6 * scale),
                            life: 0.7 + Math.random() * 0.6,
                            age: 0,
                            alpha: 0.9,
                            gravity: 420, // px/s^2
                            drag: 0.985,
                            bounce: 0.35
                        };
                    }

                    update(dt) {
                        // particles
                        for (let i = this.particles.length - 1; i >= 0; i--) {
                            const p = this.particles[i];
                            p.vx *= p.drag;
                            p.vy = p.vy * p.drag + p.gravity * dt;
                            p.x += p.vx * dt;
                            p.y += p.vy * dt;
                            p.age += dt;
                            // hit water surface (y ~ baseline): make a micro ring and dampen
                            const H = this.canvas.height / devicePixelRatio;
                            if (p.y > H - 2) { // surface/bottom clamp depending on composition
                                p.y = H - 2;
                                p.vy *= -p.bounce;
                                p.vx *= 0.7;
                                this.rings.push({ x: p.x, y: p.y, r: 1.5, w: 1, alpha: 0.35, growth: 80, fade: 0.9 });
                                // convert to foam/mist quickly
                                p.life *= 0.6;
                            }
                            if (p.age > p.life) { this.particles.splice(i, 1); }
                        }
                        // rings
                        for (let i = this.rings.length - 1; i >= 0; i--) {
                            const r = this.rings[i];
                            r.r += r.growth * dt;
                            r.alpha *= r.fade;
                            r.w *= 0.995;
                            if (r.alpha < 0.04) this.rings.splice(i, 1);
                        }
                    }

                    draw() {
                        const ctx = this.ctx;
                        ctx.clearRect(0, 0, this.canvas.width / devicePixelRatio, this.canvas.height / devicePixelRatio);

                        // Debug: log particle count occasionally
                        if (this.particles.length > 0 || this.rings.length > 0) {
                            // Debug logging removed for cleaner console
                        }

                        // rings
                        for (const r of this.rings) {
                            ctx.beginPath();
                            ctx.arc(r.x, r.y, r.r, 0, Math.PI * 2);
                            ctx.strokeStyle = `rgba(200,230,255,${r.alpha})`;
                            ctx.lineWidth = r.w;
                            ctx.globalCompositeOperation = r.invert ? 'destination-out' : 'lighter';
                            ctx.stroke();
                        }
                        ctx.globalCompositeOperation = 'source-over';

                        // droplets (simple highlights)
                        for (const p of this.particles) {
                            const a = Math.max(0, 1 - p.age / p.life) * p.alpha;
                            ctx.beginPath();
                            ctx.ellipse(p.x, p.y, p.size, p.size * 0.85, 0, 0, Math.PI * 2);
                            ctx.fillStyle = `rgba(220,240,255,${a})`;
                            ctx.shadowColor = 'rgba(180,220,255,0.6)';
                            ctx.shadowBlur = 6;
                            ctx.fill();
                            ctx.shadowBlur = 0;
                        }
                    }
                }

                // Initialize splash systems for both desktop and mobile
                const desktopLake = document.getElementById('fishing-lake');
                const desktopCanvas = document.getElementById('splash-canvas');
                const mobileLake = document.getElementById('mobile-fishing-lake');
                const mobileCanvas = document.getElementById('mobile-splash-canvas');

                // Add a small delay to ensure DOM is fully loaded and elements are sized
                setTimeout(() => {
                    if (desktopLake && desktopCanvas) {
                        this.desktopSplashSystem = new SplashSystem(desktopLake, desktopCanvas);
                        // Desktop splash system created
                    }
                    if (mobileLake && mobileCanvas) {
                        this.mobileSplashSystem = new SplashSystem(mobileLake, mobileCanvas);
                        // Mobile splash system created
                    }

                    // Keep splash systems accessible globally
                    window.splashFX = this.desktopSplashSystem;
                    window.mobileSplashFX = this.mobileSplashSystem;
                    
                    // Splash systems initialized
                }, 100);
            }

            // Animated Cat Rig System
            initializeCatRigSystem() {
                // Build one animated SVG cat
                function buildCatSVG(opts) {
                    const {
                        fur = '#f2a65a', pattern = '#d77f3f', ear = '#c76b2a',
                        eye = '#1e2a3a', belly = '#f8d7b1', whisker = '#2b2b2b'
                    } = opts || {};
                    const wrap = document.createElement('div');
                    wrap.className = 'cat-rig';
                    wrap.innerHTML = `
                        <div class="cat-gear">
                            <div class="cat-hat"></div>
                            <div class="cat-glasses"></div>
                            <div class="cat-vest"></div>
                        </div>
                        <div class="cat-emote" aria-hidden="true"></div>
                        <svg viewBox="0 0 100 100" aria-hidden="true">
                            <!-- Tail -->
                            <g class="cat-tail">
                                <path d="M78,70 q16,8 10,18 q-10,2 -18,-8" fill="${fur}" opacity=".95"/>
                            </g>

                            <!-- Body + belly -->
                            <g class="cat-body">
                                <ellipse cx="52" cy="66" rx="26" ry="22" fill="${fur}"/>
                                <ellipse cx="50" cy="72" rx="16" ry="12" fill="${belly}" opacity=".9"/>
                                <!-- stripes/spots (pattern) -->
                                <path d="M38,58 l-6,3 M44,54 l-5,3 M60,55 l6,3 M66,59 l5,3"
                                      stroke="${pattern}" stroke-width="3" stroke-linecap="round"/>
                            </g>

                            <!-- Ears -->
                            <g class="cat-earL"><path d="M30,30 l-10,-6 l6,14 z" fill="${fur}"/>
                                                <path d="M28,31 l-6,-4 l4,9 z" fill="${ear}"/></g>
                            <g class="cat-earR"><path d="M70,30 l10,-6 l-6,14 z" fill="${fur}"/>
                                                <path d="M72,31 l6,-4 l-4,9 z" fill="${ear}"/></g>

                            <!-- Head -->
                            <g class="cat-head">
                                <ellipse cx="50" cy="44" rx="20" ry="16" fill="${fur}"/>
                                <!-- Eyes -->
                                <g class="cat-eyes">
                                    <ellipse cx="43" cy="44" rx="3.6" ry="4.6" fill="${eye}"/>
                                    <ellipse cx="57" cy="44" rx="3.6" ry="4.6" fill="${eye}"/>
                                </g>
                                <!-- Nose & mouth -->
                                <ellipse cx="50" cy="50" rx="2.6" ry="2.1" fill="#ff8fa3"/>
                                <path d="M50,52 q-3,3 -6,0 M50,52 q3,3 6,0" stroke="#3b2b2b" stroke-width="1.5" fill="none" stroke-linecap="round"/>
                                <!-- Whiskers -->
                                <path d="M34,49 h10 M34,52 h10 M56,49 h10 M56,52 h10" stroke="${whisker}" stroke-width="1.2" stroke-linecap="round" opacity=".85"/>
                            </g>
                        </svg>`;
                    return wrap;
                }

                // Apply gear art (simple inline SVGs or PNGs)
                function applyGear(container, gear) {
                    const hat = container.querySelector('.cat-hat');
                    const gls = container.querySelector('.cat-glasses');
                    const vest = container.querySelector('.cat-vest');

                    if (gear?.hat) {
                        hat.classList.add('show');
                        // example hat SVG
                        hat.innerHTML = `<svg viewBox="0 0 100 100"><path d="M28,34 h44 a8,8 0 0 1 8,8 v2 H20 v-2 a8,8 0 0 1 8,-8z" fill="#2e3a4a"/></svg>`;
                    } else { 
                        hat.classList.remove('show'); 
                        hat.innerHTML = ''; 
                    }

                    if (gear?.glasses) {
                        gls.classList.add('show');
                        gls.innerHTML = `<svg viewBox="0 0 100 100"><g fill="none" stroke="#111" stroke-width="2">
                            <circle cx="42" cy="45" r="8"/><circle cx="58" cy="45" r="8"/><path d="M50,45 h2"/></g></svg>`;
                    } else { 
                        gls.classList.remove('show'); 
                        gls.innerHTML = ''; 
                    }

                    if (gear?.vest) {
                        vest.classList.add('show');
                        vest.innerHTML = `<svg viewBox="0 0 100 100"><path d="M34,56 h32 v18 q-16,8 -32,0 z" fill="#1f6aa5" opacity=".85"/></svg>`;
                    } else { 
                        vest.classList.remove('show'); 
                        vest.innerHTML = ''; 
                    }
                }

                // Emotes
                function showEmote(container, text, ms = 900) {
                    const b = container.querySelector('.cat-emote');
                    if (!b) return;
                    b.textContent = text;
                    b.classList.add('show');
                    setTimeout(() => b.classList.remove('show'), ms);
                }

                /* PUBLIC: create/refresh a rig for a given fisherman node */
                window.renderCatRig = function mountCatRig(targetEl, options) {
                    // options: { colors:{fur,pattern,ear,eye,belly,whisker}, gear:{hat,glasses,vest} }
                    targetEl.innerHTML = '';
                    const rig = buildCatSVG(options?.colors);
                    targetEl.appendChild(rig.firstElementChild); // cat-gear
                    targetEl.appendChild(rig.querySelector('.cat-emote'));
                    targetEl.appendChild(rig.querySelector('svg'));
                    applyGear(targetEl, options?.gear);
                    return targetEl;
                };

                // Quick reactions during gameplay
                window.catRigPlay = {
                    cheer: (targetEl) => showEmote(targetEl, 'üò∫'),
                    sad: (targetEl) => showEmote(targetEl, 'üôÄ'),
                    wow: (targetEl) => showEmote(targetEl, 'ü§©'),
                    talk: (targetEl, msg) => showEmote(targetEl, msg, 1200)
                };

                console.log('Cat rig system initialized');
            }

            setupWaterInteractions() {
                const lake = document.getElementById('fishing-lake');
                let isDragging = false;
                let lastRippleTime = 0;
                const rippleThrottle = 100; // Minimum ms between ripples when dragging

                // Click on water
                lake.addEventListener('click', (e) => {
                    this.createMouseRipple(e, lake);
                });

                // Mouse down - start dragging
                lake.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    this.createMouseRipple(e, lake);
                });

                // Mouse move while dragging - create ripples
                lake.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const now = Date.now();
                        if (now - lastRippleTime > rippleThrottle) {
                            this.createMouseRipple(e, lake);
                            lastRippleTime = now;
                        }
                    }
                });

                // Mouse up - stop dragging
                lake.addEventListener('mouseup', () => {
                    isDragging = false;
                });

                // Mouse leave - stop dragging
                lake.addEventListener('mouseleave', () => {
                    isDragging = false;
                });

                // Touch support for mobile
                lake.addEventListener('touchstart', (e) => {
                    isDragging = true;
                    const touch = e.touches[0];
                    this.createMouseRipple({ clientX: touch.clientX, clientY: touch.clientY }, lake);
                }, { passive: true });

                lake.addEventListener('touchmove', (e) => {
                    if (isDragging) {
                        e.preventDefault();
                        const touch = e.touches[0];
                        const now = Date.now();
                        if (now - lastRippleTime > rippleThrottle) {
                            this.createMouseRipple({ clientX: touch.clientX, clientY: touch.clientY }, lake);
                            lastRippleTime = now;
                        }
                    }
                }, { passive: false }); // Must be non-passive because we use preventDefault()

                lake.addEventListener('touchend', () => {
                    isDragging = false;
                }, { passive: true });
            }

            createMouseRipple(e, lake) {
                const ripple = document.createElement('div');
                ripple.className = 'mouse-ripple';
                
                // Get position relative to lake
                const rect = lake.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Set position
                ripple.style.left = x + 'px';
                ripple.style.top = y + 'px';
                ripple.style.width = '20px';
                ripple.style.height = '20px';
                ripple.style.transform = 'translate(-50%, -50%)';
                
                // Add to lake
                lake.appendChild(ripple);
                
                // Remove after animation
                setTimeout(() => {
                    if (ripple.parentNode) {
                        ripple.remove();
                    }
                }, 1500);
            }

            castLine() {
                // Trigger cat casting animation
                if (window.CatRigs) {
                    window.CatRigs.bite(this.player.name); // Quick reaction when casting
                }
                if (this.isCasting) return;

                this.isCasting = true;
                this.fishStrikeTime = null; // Reset fish strike timing
                this.hookSetSuccess = false; // Reset hook set success
                this.autoFailTimer = null; // Reset auto-fail timer
                
                const castBtn = document.getElementById('cast-btn');
                const mobileCastBtn = document.getElementById('mobile-cast-btn');
                
                if (castBtn) {
                    castBtn.textContent = 'WAITING...';
                    castBtn.classList.add('casting');
                    castBtn.disabled = true;
                }
                
                if (mobileCastBtn) {
                    mobileCastBtn.textContent = 'WAITING...';
                    mobileCastBtn.classList.add('casting');
                    mobileCastBtn.disabled = true;
                }

                // Get player's 3D cat for ballistic casting
                const playerKey = window.safeKey(this.player.name);
                const catRig = window.CatRigs?.map?.get(playerKey);
                const cat3D = catRig?.model ? catRig : null;
                
                if (cat3D && cat3D.animateCast) {
                    // Use 3D ballistic casting system
                    // Define lake bounds in 3D space that cast toward the lake container
                    // Calculate lake center in 3D based on screen position
                    const isMobile = window.innerWidth <= 768;
                    const lakeEl = document.getElementById(isMobile ? 'mobile-fishing-lake' : 'fishing-lake');
                    if (!lakeEl) return;
                    
                    // Simple 3D casting: cast forward (positive Z) toward lake
                    // Since cat is on left and lake on right, cast should go mostly in +Z (forward)
                    // Use simple fixed bounds that match the normalized model scale (~1 unit)
                    const lakeBounds = {
                        center: { x: 0, y: -0.5, z: 2.5 }, // Forward and slightly down (water level)
                        halfW: 1.5,  // Small horizontal spread
                        halfH: 1.0,   // Small depth spread
                        y: -0.5,      // Water surface Y (below rod tip at ~0)
                        wind: { x: 0, y: 0 } // Optional wind
                    };
                    
                    console.log('Cat3D: Casting with simplified lakeBounds:', lakeBounds);
                    
                    // Generate random seed for deterministic casting
                    const rngSeed = Date.now() + Math.floor(Math.random() * 10000);
                    
                    // Trigger 3D cast animation (raycaster will be created inside if needed)
                    cat3D.animateCast({
                        rngSeed,
                        lakeBounds,
                        lakeMesh: null, // No mesh yet, using flat plane
                        raycaster: null, // Will be created in animateCast if needed
                        splashSystem: window.splashFX || window.mobileSplashFX
                    });
                } else {
                    // Fallback to 2D casting system (only if Cat3D unavailable)
                    // DISABLED: Legacy DOM line conflicts with Cat3D overlay system
                    // this.addFishingLine(0, true);
                    console.log('Cat3D: Using legacy 2D cast system (Cat3D unavailable)');
                }
                
                this.playSound('cast'); // Casting sound
                
                // Notify server
                if (this.socket && this.connected) {
                    this.socket.emit('cast-line');
                }
                
                const ripples = document.getElementById('ripples');
                if (ripples) ripples.classList.add('active');

                // Progressive bite timing based on level
                // Levels 1-5: Quick paced (0.5 to 2 seconds)
                // Levels 6+: Progressively slower (2 to 6+ seconds)
                let minBiteTime = 500; // 0.5 seconds
                let maxBiteTime = 2000; // 2 seconds
                
                if (this.player.level >= 6) {
                    // Levels 6-10: 2 to 4 seconds
                    minBiteTime = 2000;
                    maxBiteTime = 4000;
                    
                    if (this.player.level >= 11) {
                        // Levels 11-15: 3 to 5.5 seconds
                        minBiteTime = 3000;
                        maxBiteTime = 5500;
                        
                        if (this.player.level >= 16) {
                            // Levels 16+: 4 to 7 seconds
                            minBiteTime = 4000;
                            maxBiteTime = 7000;
                        }
                    }
                }
                
                const biteTime = minBiteTime + Math.random() * (maxBiteTime - minBiteTime);
                
                // Phase 1: Wait for bite, then show bobber strike
                setTimeout(() => {
                    // Use Cat3D strike if available, else legacy DOM
                    if (cat3D && cat3D._overlayBobber) {
                        // Trigger strike on overlay bobber
                        const bobber = cat3D._overlayBobber;
                        if (bobber) {
                            bobber.style.animation = 'fishStrikeIntense 0.4s ease-in-out infinite';
                            bobber.style.transform = 'scale(1.3)';
                            bobber.style.filter = 'brightness(1.2) drop-shadow(0 0 8px rgba(255,255,255,0.6))';
                        }
                    } else {
                        this.showFishStrike(); // Fallback to legacy DOM bobber
                    }
                    this.fishStrikeTime = Date.now(); // Record when fish struck
                    
                    // Trigger cat bite/reaction animation on fish strike
                    if (window.CatRigs) {
                        window.CatRigs.bite(this.player.name); // Alert reaction when fish strikes
                    }
                    
                    // Update button to allow hook setting
                    if (castBtn) {
                        castBtn.textContent = 'SET HOOK!';
                        castBtn.disabled = false;
                        castBtn.onclick = () => this.setHook();
                    }
                    
                    if (mobileCastBtn) {
                        mobileCastBtn.textContent = 'SET HOOK!';
                        mobileCastBtn.disabled = false;
                        mobileCastBtn.onclick = () => this.setHook();
                    }
                    
                    // Auto-fail if player doesn't react in time (3-5 seconds AFTER fish strikes)
                    const reactionTime = 3000 + Math.random() * 2000; // 3-5 seconds
                    this.autoFailTimer = setTimeout(() => {
                        if (!this.hookSetSuccess && this.isCasting && this.fishStrikeTime) {
                            this.missFish('Too slow! Fish got away!');
                        }
                    }, reactionTime);
                    
                }, biteTime);
            }

            showFishStrike() {
                // Show dramatic bobber strike animation
                // Skip if using Cat3D overlay system
                const playerKey = window.safeKey ? window.safeKey(this.player.name) : this.player.name.toLowerCase();
                if (window.CatRigs && window.CatRigs.map && window.CatRigs.map.has(playerKey)) {
                    // Cat3D handles strikes via overlay bobber - already done in castLine()
                    return;
                }
                
                // Legacy DOM system only
                const lake = document.getElementById('fishing-lake');
                const mobileLake = document.getElementById('mobile-fishing-lake');
                
                const isMobile = window.innerWidth <= 768;
                const activeLake = isMobile ? mobileLake : lake;
                
                if (!activeLake) return;
                
                // Find the fishing line for current player
                const lines = activeLake.querySelectorAll('.fishing-line');
                lines.forEach(line => {
                    if (line.dataset.playerIndex === '0') {
                        // Get the bobber (hook element)
                        const bobber = line.querySelector('.hook');
                        if (bobber) {
                            // Add dramatic strike animation with more movement
                            bobber.style.animation = 'fishStrikeIntense 0.4s ease-in-out infinite';
                            bobber.style.transform = 'scale(1.3)';
                            bobber.style.filter = 'brightness(1.2) drop-shadow(0 0 8px rgba(255,255,255,0.6))';
                            
                            // Animate the fishing line to show subtle tension
                            line.style.animation = 'lineTensionSubtle 0.4s ease-in-out infinite';
                            line.style.filter = 'brightness(1.05)';
                            
                            // Create multiple splash effects for more drama
                            for (let i = 0; i < 3; i++) {
                                setTimeout(() => {
                                    const splash = document.createElement('div');
                                    splash.className = 'fish-splash';
                                    splash.style.cssText = `
                                        position: absolute;
                                        width: ${25 + i * 10}px;
                                        height: ${25 + i * 10}px;
                                        background: radial-gradient(circle, rgba(255,255,255,${0.9 - i * 0.2}) 0%, rgba(255,255,255,${0.4 - i * 0.1}) 50%, transparent 100%);
                                        border-radius: 50%;
                                        left: 50%;
                                        top: 50%;
                                        transform: translate(-50%, -50%) rotate(${i * 120}deg);
                                        animation: splashExpandIntense 0.8s ease-out forwards;
                                        pointer-events: none;
                                        z-index: 10;
                                    `;
                                    bobber.appendChild(splash);
                                    
                                    // Remove splash after animation
                                    setTimeout(() => {
                                        if (splash.parentNode) {
                                            splash.parentNode.removeChild(splash);
                                        }
                                    }, 800);
                                }, i * 100); // Stagger the splashes
                            }
                            
                            // Add water ripples around the bobber
                            const ripple = document.createElement('div');
                            ripple.className = 'strike-ripple';
                            ripple.style.cssText = `
                                position: absolute;
                                width: 40px;
                                height: 40px;
                                border: 2px solid rgba(255,255,255,0.6);
                                border-radius: 50%;
                                left: 50%;
                                top: 50%;
                                transform: translate(-50%, -50%);
                                animation: rippleExpand 1.2s ease-out infinite;
                                pointer-events: none;
                                z-index: 5;
                            `;
                            bobber.appendChild(ripple);
                            
                            // Remove ripple after animation
                            setTimeout(() => {
                                if (ripple.parentNode) {
                                    ripple.parentNode.removeChild(ripple);
                                }
                            }, 1200);
                            
                            // Add realistic suction splash effect for fish bite
                            const lakeRect = activeLake.getBoundingClientRect();
                            const bobberRect = bobber.getBoundingClientRect();
                            const bobberX = bobberRect.left - lakeRect.left;
                            const bobberY = bobberRect.top - lakeRect.top;
                            
                            console.log('Fish strike suction - bobberX:', bobberX, 'bobberY:', bobberY, 'isMobile:', isMobile);
                            
                            const splashSystem = isMobile ? window.mobileSplashFX : window.splashFX;
                            if (splashSystem) {
                                splashSystem.emitSuction(bobberX, bobberY, 0.9);
                                console.log('Suction effect emitted successfully');
                            } else {
                                console.log('No splash system available for suction!');
                            }
                            
                        // Add cat wow emote for fish strike
                        const playerFisher = document.getElementById('player-fisher');
                        const mobilePlayerFisher = document.getElementById('mobile-player-fisher');
                        const rigContainer = playerFisher?.querySelector('.cat-rig') || mobilePlayerFisher?.querySelector('.cat-rig');
                        if (rigContainer && window.catRigPlay) {
                            window.catRigPlay.wow(rigContainer);
                        }
                        
                        // Add 3D cat bite reaction
                        if (window.CatRigs) {
                            window.CatRigs.bite(this.player.name);
                        }
                        }
                    }
                });
                
                this.playSound('bite'); // Fish bite sound
            }

            setHook() {
                if (!this.fishStrikeTime || this.hookSetSuccess) return;
                
                const reactionTime = Date.now() - this.fishStrikeTime;
                const castBtn = document.getElementById('cast-btn');
                const mobileCastBtn = document.getElementById('mobile-cast-btn');
                
                // Get current hook to determine timing window
                const hookName = this.player.gear?.hooks || this.player.gear?.hook;
                const hook = hookName ? this.tackle.hooks.find(h => h.name === hookName) : null;
                
                // Determine timing window based on hook quality
                let maxTimingWindow = 800; // Default timing window
                if (hook) {
                    switch (hook.name) {
                        case 'Basic Hook':
                            maxTimingWindow = 800; // 200-800ms
                            break;
                        case 'Barbed Hook':
                            maxTimingWindow = 900; // 200-900ms
                            break;
                        case 'Circle Hook':
                            maxTimingWindow = 1000; // 200-1000ms
                            break;
                        case 'Treble Hook':
                            maxTimingWindow = 1100; // 200-1100ms
                            break;
                        case 'Jig Hook':
                            maxTimingWindow = 1200; // 200-1200ms
                            break;
                        case 'Trophy Hook':
                            maxTimingWindow = 1300; // 200-1300ms
                            break;
                        default:
                            maxTimingWindow = 800;
                    }
                }
                
                // Timing-based success:
                // Too fast (< 200ms): Miss - "Too eager!"
                // Perfect timing (200ms to maxTimingWindow): Success
                // Too slow (> maxTimingWindow): Miss - "Too slow!"
                
                if (reactionTime < 200) {
                    this.missFish('Too eager! Fish wasn\'t ready!');
                } else if (reactionTime <= maxTimingWindow) {
                    // Success! Hook set properly
                    this.hookSetSuccess = true;
                    
                    // Clear auto-fail timer since we succeeded
                    if (this.autoFailTimer) {
                        clearTimeout(this.autoFailTimer);
                        this.autoFailTimer = null;
                    }
                    
                    // Stop bobber strike animations
                    this.stopBobberAnimations();
                    
                    if (castBtn) {
                        castBtn.textContent = 'REELING...';
                        castBtn.disabled = true;
                    }
                    
                    if (mobileCastBtn) {
                        mobileCastBtn.textContent = 'REELING...';
                        mobileCastBtn.disabled = true;
                    }
                    
                    this.playSound('hookset'); // Hook set sound
                    
                    // Calculate catch chance and reel in
                    const catchChance = this.calculateCatchChance();
                    setTimeout(() => {
                        this.reelIn(catchChance);
                    }, 500); // Brief delay to show hook set success
                    
                } else {
                    this.missFish('Too slow! Fish got away!');
                }
            }

            missFish(reason) {
                this.isCasting = false;
                this.hookSetSuccess = false;
                this.fishStrikeTime = null;
                
                // Clear auto-fail timer
                if (this.autoFailTimer) {
                    clearTimeout(this.autoFailTimer);
                    this.autoFailTimer = null;
                }
                
                // Stop bobber strike animations
                this.stopBobberAnimations();
                
                const castBtn = document.getElementById('cast-btn');
                const mobileCastBtn = document.getElementById('mobile-cast-btn');
                
                if (castBtn) {
                    castBtn.textContent = 'CAST LINE';
                    castBtn.classList.remove('casting');
                    castBtn.disabled = false;
                    castBtn.onclick = () => this.castLine();
                }
                
                if (mobileCastBtn) {
                    mobileCastBtn.textContent = 'CAST';
                    mobileCastBtn.classList.remove('casting');
                    mobileCastBtn.disabled = false;
                    mobileCastBtn.onclick = () => this.castLine();
                }
                
                // Remove fishing line (both legacy and Cat3D overlay)
                this.removeFishingLine(0);
                
                // Clean up Cat3D overlay elements on miss
                const playerKey = window.safeKey ? window.safeKey(this.player.name) : this.player.name.toLowerCase();
                if (window.CatRigs && window.CatRigs.map && window.CatRigs.map.has(playerKey)) {
                    const cat3D = window.CatRigs.map.get(playerKey);
                    if (cat3D) {
                        if (cat3D._overlayLine) cat3D._overlayLine.style.display = 'none';
                        if (cat3D._overlayBobber) {
                            cat3D._overlayBobber.style.display = 'none';
                            // Reset strike animation
                            cat3D._overlayBobber.style.animation = '';
                            cat3D._overlayBobber.style.transform = '';
                            cat3D._overlayBobber.style.filter = '';
                        }
                        if (cat3D.bobber) cat3D.bobber.visible = false;
                        if (cat3D.fishingLine) cat3D.fishingLine.visible = false;
                    }
                }
                
                // Show miss message
                this.showMessage(reason, 'error');
                this.playSound('miss'); // Miss sound
            }

            stopBobberAnimations() {
                const lake = document.getElementById('fishing-lake');
                const mobileLake = document.getElementById('mobile-fishing-lake');
                
                const isMobile = window.innerWidth <= 768;
                const activeLake = isMobile ? mobileLake : lake;
                
                if (!activeLake) return;
                
                // Find the fishing line for current player
                const lines = activeLake.querySelectorAll('.fishing-line');
                lines.forEach(line => {
                    if (line.dataset.playerIndex === '0') {
                        // Get the bobber (hook element)
                        const bobber = line.querySelector('.hook');
                        if (bobber) {
                            // Stop animations and reset styles
                            bobber.style.animation = 'none';
                            bobber.style.transform = 'translateX(-50%) scale(1)';
                            bobber.style.filter = 'none';
                            
                            // Reset line animation
                            line.style.animation = 'none';
                            line.style.filter = 'none';
                            
                            // Remove any remaining splash effects
                            const splashes = bobber.querySelectorAll('.fish-splash, .strike-ripple');
                            splashes.forEach(splash => splash.remove());
                        }
                    }
                });
            }

            addFishingLine(playerIndex, isCasting = false) {
                const fishermanRow = document.getElementById('fisherman-row');
                const lake = document.getElementById('fishing-lake');
                const mobileFishermanRow = document.getElementById('mobile-fisherman-row');
                const mobileLake = document.getElementById('mobile-fishing-lake');
                
                // Detect if we're on mobile by checking screen width
                const isMobile = window.innerWidth <= 768;
                
                // Use mobile elements if we're on mobile, otherwise use desktop
                const activeFishermanRow = isMobile ? mobileFishermanRow : fishermanRow;
                const activeLake = isMobile ? mobileLake : lake;
                
                if (!activeFishermanRow || !activeLake) return null;
                
                const fishermen = activeFishermanRow.querySelectorAll('.fisherman, .mobile-fisherman');
                
                if (playerIndex >= fishermen.length) return null;
                
                const fisherman = fishermen[playerIndex];
                
                // CRITICAL: Check if fisherman is actually visible on screen
                // If fisherman has zero width/height or is not displayed, don't create a line
                const fishermanRect = fisherman.getBoundingClientRect();
                if (fishermanRect.width === 0 || fishermanRect.height === 0) {
                    // Fisherman is not visible, don't create a fishing line
                    return null;
                }
                
                // Check if fisherman is actually in the viewport (not hidden by CSS)
                const computedStyle = window.getComputedStyle(fisherman);
                if (computedStyle.display === 'none' || computedStyle.visibility === 'hidden' || computedStyle.opacity === '0') {
                    return null;
                }
                
                const lakeRect = activeLake.getBoundingClientRect();
                
                const line = document.createElement('div');
                line.className = 'fishing-line';
                line.dataset.playerIndex = playerIndex.toString();
                // Store player name for better cleanup tracking
                const playerName = fisherman.textContent.trim().split('\n')[0];
                line.dataset.playerName = playerName;
                if (isCasting) line.classList.add('casting');
                
                // Position line from fisherman to lake
                const fishermanCenterX = fishermanRect.left + fishermanRect.width / 2;
                const fishermanBottom = fishermanRect.bottom;
                const lakeTop = lakeRect.top;
                const lakeHeight = lakeRect.height;
                
                // Calculate responsive cast distance based on lake size
                // Cast further on larger screens, less on smaller screens
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                
                // Base distance calculation - proportion of lake height
                let castDistance = lakeHeight * 0.5; // Cast halfway into lake by default
                
                // Adjust based on screen size
                if (screenWidth >= 1400 && screenHeight >= 800) {
                    // Large screens - cast much further
                    castDistance = lakeHeight * 0.7; // 70% of lake height
                } else if (screenWidth >= 1200 && screenHeight >= 700) {
                    // Medium screens - cast moderately
                    castDistance = lakeHeight * 0.6; // 60% of lake height
                } else if (screenWidth >= 992 && screenHeight >= 600) {
                    // Small screens - cast less
                    castDistance = lakeHeight * 0.5; // 50% of lake height
                } else {
                    // Very small screens - cast minimally
                    castDistance = lakeHeight * 0.4; // 40% of lake height
                }
                
                // Ensure minimum cast distance
                const minCast = 80;
                const maxCast = lakeHeight * 0.8; // Never more than 80% of lake
                castDistance = Math.max(minCast, Math.min(castDistance, maxCast));
                
                const lineLength = lakeTop - fishermanBottom + castDistance;
                
                line.style.left = (fishermanCenterX - lakeRect.left) + 'px';
                line.style.top = '0px';
                line.style.height = lineLength + 'px';
                
                const hook = document.createElement('div');
                hook.className = 'hook';
                line.appendChild(hook);
                
                // Add splash animation at the hook (bottom of the line)
                const splash = document.createElement('div');
                splash.className = 'hook-splash';
                splash.style.left = line.style.left;
                splash.style.top = lineLength + 'px'; // Position at bottom of line where hook is
                activeLake.appendChild(splash);
                
                // Store splash reference on line for cleanup
                line.dataset.splashId = splash.id || `splash-${Date.now()}-${Math.random()}`;
                splash.id = line.dataset.splashId;
                
                // Add realistic splash effect when hook hits water
                setTimeout(() => {
                    // Get the actual hook position from the DOM after it's been positioned
                    const hookElement = line.querySelector('.hook');
                    if (!hookElement) return;
                    
                    const lakeRect = activeLake.getBoundingClientRect();
                    const hookRect = hookElement.getBoundingClientRect();
                    
                    // Calculate hook position relative to the lake
                    const hookX = hookRect.left - lakeRect.left;
                    const hookY = hookRect.top - lakeRect.top;
                    
                    // Emit splash effect at hook impact point
                    const splashSystem = isMobile ? window.mobileSplashFX : window.splashFX;
                    
                    if (splashSystem) {
                        splashSystem.emitSplash(hookX, hookY, 1.0, 'impact');
                    } else {
                        console.log('No splash system available!');
                    }
                }, 200); // Increased delay to ensure hook is fully positioned
                
                activeLake.appendChild(line);
                
                // Create landing splash effect when hook hits water (after line extends)
                setTimeout(() => {
                    this.createHookLandingSplash(line.style.left, lineLength, activeLake);
                }, 300); // Small delay to simulate hook reaching water
                
                return line;
            }

            createHookLandingSplash(left, top, lake) {
                const landingSplash = document.createElement('div');
                landingSplash.className = 'hook-landing-splash';
                
                // Parse left position (could be "123px" or a number)
                const leftValue = typeof left === 'string' ? parseFloat(left) : left;
                landingSplash.style.left = leftValue + 'px';
                landingSplash.style.top = top + 'px';
                
                // Add third splash wave element
                const splashWave = document.createElement('div');
                splashWave.className = 'splash-wave';
                landingSplash.appendChild(splashWave);
                
                // Add to lake
                lake.appendChild(landingSplash);
                
                // Remove after animation completes
                setTimeout(() => {
                    if (landingSplash.parentNode) {
                        landingSplash.remove();
                    }
                }, 1500);
            }

            removeFishingLine(playerIndex) {
                // Clean up Cat3D overlay if using it (for current player only)
                const playerKey = window.safeKey ? window.safeKey(this.player.name) : this.player.name.toLowerCase();
                if (playerIndex === 0 && window.CatRigs && window.CatRigs.map && window.CatRigs.map.has(playerKey)) {
                    const cat3D = window.CatRigs.map.get(playerKey);
                    if (cat3D) {
                        if (cat3D._overlayLine) cat3D._overlayLine.style.display = 'none';
                        if (cat3D._overlayBobber) {
                            cat3D._overlayBobber.style.display = 'none';
                            // Reset any animations
                            cat3D._overlayBobber.style.animation = '';
                            cat3D._overlayBobber.style.transform = '';
                            cat3D._overlayBobber.style.filter = '';
                        }
                        if (cat3D.bobber) cat3D.bobber.visible = false;
                        if (cat3D.fishingLine) cat3D.fishingLine.visible = false;
                    }
                }
                
                // Legacy DOM line cleanup
                const lake = document.getElementById('fishing-lake');
                const mobileLake = document.getElementById('mobile-fishing-lake');
                
                const isMobile = window.innerWidth <= 768;
                const activeLake = isMobile ? mobileLake : lake;
                
                if (!activeLake) return;
                
                // Find and remove fishing lines for the specified player
                const lines = activeLake.querySelectorAll('.fishing-line');
                lines.forEach(line => {
                    if (line.dataset.playerIndex === playerIndex.toString()) {
                        // Remove associated splash if it exists
                        const splashId = line.dataset.splashId;
                        if (splashId) {
                            const splash = document.getElementById(splashId);
                            if (splash) {
                                splash.remove();
                            }
                        }
                        
                        // Remove the line itself
                        line.remove();
                    }
                });
            }

            calculateCatchChance() {
                // During tournaments, everyone has equal chance (level playing field)
                if (this.tournament && this.tournament.phase === 'active') {
                    // Equal base chance for all players regardless of equipment/stats
                    return 0.7; // 70% base chance, same for everyone
                }
                
                // Normal fishing uses player equipment and stats
                // Progressive difficulty: catch rate DECREASES at higher levels
                // Increased base chance due to new interactive fishing mechanics
                let chance = 0.9; // 90% base chance (increased from 80%)
                
                const location = this.locations[this.currentLocation];
                
                // Reduced penalties since players will miss due to timing now
                if (this.player.level >= 16) {
                    chance -= 0.20; // Reduced from 40% to 20% penalty
                } else if (this.player.level >= 11) {
                    chance -= 0.15; // Reduced from 30% to 15% penalty
                } else if (this.player.level >= 6) {
                    chance -= 0.10; // Reduced from 20% to 10% penalty
                }
                
                // Progressive difficulty based on location difficulty
                // Reduced penalties since players will miss due to timing now
                if (location.difficulty === 'Easy') {
                    chance += 0.05; // Easy locations: +5% catch rate
                } else if (location.difficulty === 'Medium') {
                    chance -= 0.02; // Reduced from 5% to 2% penalty
                } else if (location.difficulty === 'Hard') {
                    chance -= 0.08; // Reduced from 15% to 8% penalty
                } else if (location.difficulty === 'Expert') {
                    chance -= 0.12; // Reduced from 25% to 12% penalty
                }
                
                // Add tackle bonuses - BETTER gear significantly improves your chances
                // Check both plural and singular keys for compatibility
                const rodName = this.player.gear?.rods || this.player.gear?.rod;
                const reelName = this.player.gear?.reels || this.player.gear?.reel;
                const lineName = this.player.gear?.lines || this.player.gear?.line;
                const hookName = this.player.gear?.hooks || this.player.gear?.hook;
                const baitName = this.player.gear?.baits || this.player.gear?.bait;
                
                const rod = rodName ? this.tackle.rods.find(r => r.name === rodName) : null;
                const reel = reelName ? this.tackle.reels.find(r => r.name === reelName) : null;
                const line = lineName ? this.tackle.lines.find(l => l.name === lineName) : null;
                const hook = hookName ? this.tackle.hooks.find(h => h.name === hookName) : null;
                const bait = baitName ? this.tackle.baits.find(b => b.name === baitName) : null;
                
                if (rod) chance += rod.catchBonus / 80; // Better rods significantly help
                if (reel) chance += reel.speedBonus / 150; // Reels help a bit
                if (line) chance += line.strength / 800; // Lines help slightly
                if (hook) chance += hook.catchBonus / 80; // Better hooks significantly help
                if (bait) chance += bait.catchBonus / 80; // Better bait significantly helps
                
                // Add player stats bonuses
                const accuracyBonus = (this.player.stats.accuracy - 50) * 0.0015; // Accuracy matters more
                const luckBonus = (this.player.stats.luck - 50) * 0.002; // Luck helps
                const patienceBonus = (this.player.stats.patience - 50) * 0.0008; // Patience helps
                const strengthBonus = (this.player.stats.strength - 50) * 0.001; // Strength helps
                
                chance += accuracyBonus + luckBonus + patienceBonus + strengthBonus;
                
                // Cap between 20% and 85% max (increased due to reduced penalties)
                return Math.min(0.85, Math.max(0.20, chance)); 
            }

            showFishBite() {
                // Animate the bobber with a bite animation
                const lake = document.getElementById('fishing-lake');
                const mobileLake = document.getElementById('mobile-fishing-lake');
                
                const isMobile = window.innerWidth <= 768;
                const activeLake = isMobile ? mobileLake : lake;
                
                if (!activeLake) return;
                
                // Find the fishing line for current player
                const lines = activeLake.querySelectorAll('.fishing-line');
                lines.forEach(line => {
                    if (line.dataset.playerIndex === '0') {
                        // Get the bobber (hook element)
                        const bobber = line.querySelector('.hook');
                        if (bobber) {
                            // Add bite animation to bobber
                            bobber.style.animation = 'fishBite 0.8s ease-in-out';
                            
                            // Create big splash effect at bobber position
                            const splash = document.createElement('div');
                            splash.className = 'fish-bite-splash';
                            const lineRect = line.getBoundingClientRect();
                            const lakeRect = activeLake.getBoundingClientRect();
                            const bobberX = lineRect.left + lineRect.width / 2 - lakeRect.left;
                            const bobberY = lineRect.bottom - lakeRect.top;
                            
                            splash.style.left = bobberX + 'px';
                            splash.style.top = bobberY + 'px';
                            
                            activeLake.appendChild(splash);
                            
                            // Remove splash after animation
                            setTimeout(() => {
                                if (splash.parentNode) {
                                    splash.remove();
                                }
                            }, 1500);
                            
                            // Reset bobber animation
                            setTimeout(() => {
                                bobber.style.animation = '';
                            }, 800);
                        }
                    }
                });
            }

            reelIn(catchChance) {
                this.isCasting = false;
                this.playSound('reel'); // Reeling sound
                
                // Animate reeling in with smooth animation
                const lake = document.getElementById('fishing-lake');
                const mobileLake = document.getElementById('mobile-fishing-lake');
                
                // Detect if we're on mobile by checking screen width
                const isMobile = window.innerWidth <= 768;
                const activeLake = isMobile ? mobileLake : lake;
                
                if (!activeLake) return;
                
                // Only remove lines for the current player (playerIndex 0)
                const lines = activeLake.querySelectorAll('.fishing-line');
                lines.forEach(line => {
                    // Only process lines that belong to the current player (playerIndex 0)
                    if (line.dataset.playerIndex === '0') {
                        // Store original height for animation
                        const originalHeight = line.offsetHeight;
                        line.style.setProperty('--original-height', originalHeight + 'px');
                        
                        // Ensure height is set for animation
                        line.style.height = originalHeight + 'px';
                        
                        // Add reel animation that shrinks height upward (transform-origin top)
                        line.style.animation = 'reelIn 1.2s ease-out forwards';
                        line.style.transformOrigin = 'top center';
                        
                        // Animate splash to follow the bobber during reel-in
                        const bobber = line.querySelector('.hook');
                        const splashId = line.dataset.splashId;
                        if (splashId) {
                            const splash = document.getElementById(splashId);
                            if (splash && bobber) {
                                // Define timing variables first
                                const startTime = Date.now();
                                const duration = 1200; // Match reel-in animation duration
                                
                                // Make splash follow bobber by updating its position during animation
                                const updateSplashPosition = () => {
                                    if (splash && bobber && line.parentNode) {
                                        const lineRect = line.getBoundingClientRect();
                                        const lakeRect = activeLake.getBoundingClientRect();
                                        const lineHeight = lineRect.height;
                                        
                                        // Position splash relative to the lake container at the bottom of the line
                                        const splashTop = lineHeight;
                                        splash.style.top = splashTop + 'px';
                                        splash.style.left = line.style.left; // Keep same horizontal position as line
                                        splash.style.position = 'absolute';
                                        splash.style.zIndex = '10'; // Ensure it's visible
                                        splash.style.opacity = '1'; // Ensure it's visible
                                        
                                        // Make splash bigger and add animation
                                        splash.style.width = '40px'; // Increased from default
                                        splash.style.height = '40px'; // Increased from default
                                        splash.style.borderRadius = '50%';
                                        splash.style.background = 'radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.4) 50%, transparent 100%)';
                                        
                                        // Add pulsing animation during reel-in
                                        const elapsed = Date.now() - startTime;
                                        const progress = elapsed / duration;
                                        const pulseScale = 1 + Math.sin(progress * Math.PI * 4) * 0.2; // Pulse between 0.8 and 1.2
                                        
                                        // Add slight rotation for more dynamic effect
                                        const rotation = progress * 360; // Full rotation over duration
                                        splash.style.transform = `translate(-50%, -50%) scale(${pulseScale}) rotate(${rotation}deg)`;
                                    }
                                };
                                
                                // Update splash position throughout the animation
                                
                                // Initial position update
                                updateSplashPosition();
                                
                                // Add wake effects during reeling
                                let lastWakeTime = 0;
                                const wakeInterval = 90; // ms between wake effects
                                
                                const updateInterval = setInterval(() => {
                                    const elapsed = Date.now() - startTime;
                                    if (elapsed < duration) {
                                        updateSplashPosition();
                                        
                                        // Add wake effects at regular intervals
                                        if (elapsed - lastWakeTime > wakeInterval) {
                                            // Get actual bobber position instead of calculated position
                                            const bobberElement = line.querySelector('.hook');
                                            if (bobberElement) {
                                                const lakeRect = activeLake.getBoundingClientRect();
                                                const bobberRect = bobberElement.getBoundingClientRect();
                                                const wakeX = bobberRect.left - lakeRect.left;
                                                const wakeY = bobberRect.top - lakeRect.top;
                                                
                                                const splashSystem = isMobile ? window.mobileSplashFX : window.splashFX;
                                                if (splashSystem) {
                                                    splashSystem.emitWake(wakeX, wakeY);
                                                }
                                            }
                                            lastWakeTime = elapsed;
                                        }
                                    } else {
                                        clearInterval(updateInterval);
                                        if (splash) {
                                            splash.remove();
                                        }
                                    }
                                }, 16); // ~60fps updates
                                
                                // Clean up after animation completes
                                setTimeout(() => {
                                    clearInterval(updateInterval);
                                    if (splash && splash.parentNode) {
                                        splash.remove();
                                    }
                                }, duration);
                            } else {
                                // Fallback: simple animation if positioning fails
                                if (splash) {
                                    splash.style.animation = 'reelIn 1.2s ease-out forwards';
                                    setTimeout(() => splash.remove(), 1200);
                                }
                            }
                        }
                        
                        // Remove line after animation
                        setTimeout(() => line.remove(), 1200);
                    }
                });
                
                // Clean up splashes associated with current player's line
                // Splashes are removed by their associated line above, but clean up any orphaned ones
                const currentPlayerSplash = activeLake.querySelector(`#splash-0, [data-splash-for="0"]`);
                if (currentPlayerSplash) {
                    currentPlayerSplash.style.animation = 'reelIn 1.2s ease-out forwards';
                    setTimeout(() => currentPlayerSplash.remove(), 1200);
                }
                
                const ripples = document.getElementById('ripples');
                const mobileRipples = document.getElementById('mobile-ripples');
                if (ripples) ripples.classList.remove('active');
                if (mobileRipples) mobileRipples.classList.remove('active');
                
                const castBtn = document.getElementById('cast-btn');
                const mobileCastBtn = document.getElementById('mobile-cast-btn');
                
                if (castBtn) {
                    castBtn.textContent = 'CAST LINE';
                    castBtn.classList.remove('casting');
                    castBtn.disabled = false;
                    castBtn.onclick = () => this.castLine();
                }
                
                if (mobileCastBtn) {
                    mobileCastBtn.textContent = 'CAST';
                    mobileCastBtn.classList.remove('casting');
                    mobileCastBtn.disabled = false;
                    mobileCastBtn.onclick = () => this.castLine();
                }

                const caughtFish = Math.random() < catchChance;
                
                // Delay catch/no-catch message slightly to sync with animation
                setTimeout(() => {
                    if (caughtFish) {
                        this.catchRandomFish();
                        
                        // Add cat cheer emote
                        const playerFisher = document.getElementById('player-fisher');
                        const mobilePlayerFisher = document.getElementById('mobile-player-fisher');
                        const rigContainer = playerFisher?.querySelector('.cat-rig') || mobilePlayerFisher?.querySelector('.cat-rig');
                        if (rigContainer && window.catRigPlay) {
                            window.catRigPlay.cheer(rigContainer);
                        }
                        
                        // Add 3D cat catch reaction
                        if (window.CatRigs) {
                            window.CatRigs.catch(this.player.name);
                        }
                    } else {
                        // Show humorous "no catch" messages
                        const noCatchMessages = [
                            "That fish was too quick for your paws! üêæ",
                            "The fish saw you coming and said 'NOPE!' üòπ",
                            "Just a nibble... your whiskers need more practice!",
                            "Fish are gossiping about your casting technique! üò∏",
                            "They're doing cat yoga down there! üßò‚Äç‚ôÄÔ∏è",
                            "Fish are on their meow-ning break! ‚òï",
                            "A ghost fish stole your bait and laughed! üëªüòπ",
                            "Fish are watching cat videos... but not yours! üì∫",
                            "They swam away purring at your attempt!",
                            "Your bait was too fancy for fish who prefer cat food! üêü",
                            "Fish are playing hide and seek... you're 'it'!",
                            "Maybe try a different spot, furriend?",
                            "That fish said 'meow-bee next time!' üò∏",
                            "Fish are having a catnip party without you! üéâüåø",
                            "Just a friendly turtle saying 'meow-lo!' üê¢",
                            "The fish are playing tag... and you're still it!",
                            "Your hook came back empty... like a cat's food bowl at 3am!",
                            "Fish saw your cat avatar and got jealous! üòº",
                            "They're busy practicing their fin-ishing moves!",
                            "Fish are playing poker... and winning! üÉè",
                            "Your bait was too spicy for their delicate palates! üå∂Ô∏è",
                            "Fish are on vacation... to avoid cats! üèñÔ∏è",
                            "They're writing their memoirs... 'My Life as Cat Bait' üìù",
                            "Fish are doing karaoke... 'Don't Stop Belly-in!' üé§",
                            "Just a crab waving hello with claws! ü¶Ä",
                            "Fish are practicing social distancing... from cats!",
                            "They're having a business meeting... about avoiding cats! üíº",
                            "Fish are doing homework... 'How to Avoid Being Caught 101' üìö",
                            "That fish escaped faster than you run from the vacuum! üèÉ",
                            "Your purr-suasion skills need work! üò∏",
                            "That fish ghosted you harder than your last Tinder date! üíÄ",
                            "Fish are filing a restraining order against you! üìã",
                            "The fish laughed and gave you a participation trophy! üèÜ",
                            "That fish yelled 'DEUCES!' and swam away! ‚úåÔ∏è",
                            "Fish are starting a support group: 'Victims of Cat Fishing' üé£",
                            "That fish is now writing a strongly worded Yelp review about you! ‚≠ê",
                            "The fish took one look at you and said 'Hard pass!' üôÖ",
                            "Fish are organizing a protest: 'Occupy the Deep End!' üì¢",
                            "That fish went 'Nah fam, not today Satan!' üòà",
                            "The fish just added you to their fish-block list! üö´",
                            "Fish are literally creating an escape committee right now! üèÉ‚Äç‚ôÄÔ∏èüèÉ‚Äç‚ôÇÔ∏è",
                            "That fish is ghost writing its autobiography: 'The One That Got Away... Again' üìñ",
                            "The fish sent back your bait with a complaint form! üìù",
                            "Fish are forming an anti-cat coalition... and you're President! üëî",
                            "That fish just called its lawyer! And won! ‚öñÔ∏è",
                            "The fish started a GoFundMe: 'Save Me From This Cat's Awful Casting' üí∞",
                            "Fish are doing inventory... of their bait collection you keep donating! üì¶",
                            "That fish put 'Professional Escapologist' on its LinkedIn! üíº",
                            "The fish just roasted you in front of its whole school! üî•",
                            "Fish are voting you 'Least Threatening Cat of the Month' üèÖ",
                            "That fish escaped and is now teaching other fish your techniques... backwards! üéì"
                        ];
                        const randomMessage = noCatchMessages[Math.floor(Math.random() * noCatchMessages.length)];
                        this.showMessage(randomMessage, '#ffff00');
                        
                        // Add cat sad emote
                        const playerFisher = document.getElementById('player-fisher');
                        const mobilePlayerFisher = document.getElementById('mobile-player-fisher');
                        const rigContainer = playerFisher?.querySelector('.cat-rig') || mobilePlayerFisher?.querySelector('.cat-rig');
                        if (rigContainer && window.catRigPlay) {
                            window.catRigPlay.sad(rigContainer);
                        }
                        
                        // Add 3D cat sad reaction
                        if (window.CatRigs) {
                            window.CatRigs.sad(this.player.name);
                        }
                    }
                }, 400);
            }

            catchRandomFish() {
                const location = this.locations[this.currentLocation];
                const availableFish = location.fish;
                
                // Progressive fish selection based on level and equipment
                // Higher level locations have better fish, but you need better gear to catch them
                let selectedFishIndex;
                
                // Determine difficulty modifier based on location difficulty
                let difficultyModifier = 0;
                if (location.difficulty === 'Easy') difficultyModifier = 0;
                else if (location.difficulty === 'Medium') difficultyModifier = 1;
                else if (location.difficulty === 'Hard') difficultyModifier = 2;
                else if (location.difficulty === 'Expert') difficultyModifier = 3;
                
                // Calculate player's fishing power based on equipment and level
                const rod = this.tackle.rods.find(r => r.name === this.player.gear.rod);
                const reel = this.tackle.reels.find(r => r.name === this.player.gear.reel);
                const hook = this.tackle.hooks.find(h => h.name === this.player.gear.hook);
                const bait = this.tackle.baits.find(b => b.name === this.player.gear.bait);
                
                let fishingPower = 0;
                if (rod) fishingPower += rod.catchBonus;
                if (reel) fishingPower += reel.speedBonus;
                if (hook) fishingPower += hook.catchBonus;
                if (bait) fishingPower += bait.catchBonus;
                fishingPower += this.player.level * 5; // Level adds to fishing power
                
                // Calculate chance to catch better fish
                // Higher difficulty locations have rare/epic/legendary fish at the end of the array
                const maxFishIndex = availableFish.length - 1;
                const chanceForBestFish = Math.min(0.3, fishingPower / 200); // Up to 30% chance for best fish
                
                if (Math.random() < chanceForBestFish) {
                    // Player catches one of the better fish from this location
                    const topTierRange = Math.ceil(availableFish.length * 0.3); // Top 30% of fish
                    const startIndex = Math.max(0, maxFishIndex - topTierRange);
                    const rangeSize = maxFishIndex - startIndex + 1;
                    selectedFishIndex = startIndex + Math.floor(Math.random() * rangeSize);
                } else {
                    // Standard fish selection with slight weighting toward better fish
                    const roll = Math.random();
                    if (roll < 0.5) {
                        // 50% chance for bottom 40% of fish
                        const bottomEnd = Math.max(1, Math.ceil(availableFish.length * 0.4));
                        selectedFishIndex = Math.floor(Math.random() * bottomEnd);
                    } else if (roll < 0.85) {
                        // 35% chance for middle 40% of fish
                        const midStart = Math.ceil(availableFish.length * 0.4);
                        const midEnd = Math.min(availableFish.length, Math.ceil(availableFish.length * 0.8));
                        const rangeSize = Math.max(1, midEnd - midStart);
                        selectedFishIndex = midStart + Math.floor(Math.random() * rangeSize);
                    } else {
                        // 15% chance for top 20% of fish
                        const topStart = Math.min(maxFishIndex, Math.ceil(availableFish.length * 0.8));
                        const rangeSize = maxFishIndex - topStart + 1;
                        selectedFishIndex = topStart + Math.floor(Math.random() * rangeSize);
                    }
                }
                
                // Ensure selectedFishIndex is within bounds
                selectedFishIndex = Math.max(0, Math.min(selectedFishIndex, maxFishIndex));
                if (selectedFishIndex < 0 || selectedFishIndex >= availableFish.length) {
                    console.error('Invalid fish index:', selectedFishIndex, 'Available fish:', availableFish.length);
                    if (availableFish.length === 0) {
                        console.error('No available fish!');
                        return; // Cannot catch fish without any available
                    }
                    selectedFishIndex = 0; // Use first fish as fallback
                }
                
                const randomFishType = availableFish[selectedFishIndex];
                
                // Safety check: ensure we have a valid fish type index
                if (randomFishType === undefined || randomFishType >= this.fishTypes.length) {
                    console.error('Invalid fish type index:', randomFishType, 'Available:', availableFish, 'Total fish types:', this.fishTypes.length);
                    if (availableFish.length > 0) {
                        const fallbackFish = availableFish[0];
                        if (fallbackFish !== undefined && fallbackFish < this.fishTypes.length) {
                            const fishData = this.fishTypes[fallbackFish];
                        } else {
                            console.error('Fallback fish also invalid:', fallbackFish);
                            return; // Cannot proceed without valid fish data
                        }
                    }
                    return;
                }
                
                const fishData = this.fishTypes[randomFishType];
                
                // Safety check: if fishData is undefined, use a default fish
                if (!fishData) {
                    console.error('Invalid fish data for type:', randomFishType);
                    // Use first available fish as fallback
                    const fallbackFish = availableFish.length > 0 ? availableFish[0] : 0;
                    const fallbackData = this.fishTypes[fallbackFish];
                    if (!fallbackData) {
                        console.error('No valid fish data found!');
                        return;
                    }
                    // Use fallback fish
                    const defaultWeight = fallbackData.minWeight + Math.random() * (fallbackData.maxWeight - fallbackData.minWeight);
                    const defaultValue = Math.floor(fallbackData.value * (1 + defaultWeight / fallbackData.maxWeight));
                    const defaultExp = Math.floor(fallbackData.experience * (1 + defaultWeight / fallbackData.maxWeight));
                    
                    this.addChatMessage('you', `Caught a ${fallbackData.name} (${defaultWeight.toFixed(1)} lbs)!`);
                    this.player.totalCaught++;
                    this.player.totalWeight += defaultWeight;
                    if (defaultWeight > this.player.biggestCatch) {
                        this.player.biggestCatch = defaultWeight;
                    }
                    this.player.money += defaultValue;
                    this.player.experience += defaultExp;
                    this.updateDisplay();
                    return;
                }

                // During tournaments, fish can be MUCH bigger (up to 3x max weight)
                let weight;
                if (this.tournament && this.tournament.phase === 'active') {
                    // Tournament mode: fish can be 1x to 3x their normal max weight
                    const baseWeight = fishData.minWeight + Math.random() * (fishData.maxWeight - fishData.minWeight);
                    const tournamentMultiplier = 1.0 + Math.random() * 2.0; // 1.0x to 3.0x
                    weight = baseWeight * tournamentMultiplier;
                } else {
                    // Normal fishing: standard weight range
                    weight = fishData.minWeight + Math.random() * (fishData.maxWeight - fishData.minWeight);
                }
                
                const value = Math.floor(fishData.value * (1 + weight / fishData.maxWeight));
                const experience = Math.floor(fishData.experience * (1 + weight / fishData.maxWeight));

                // Record the catch
                const catchData = {
                    fish: fishData,
                    weight: weight,
                    value: value,
                    experience: experience,
                    location: location.name,
                    timestamp: Date.now()
                };
                
                // Track if this is a new fish for the collection
                const isNewFish = !this.player.caughtFish || !this.player.caughtFish[fishData.name];
                if (isNewFish) {
                    // Mark fish as caught
                    if (!this.player.caughtFish) {
                        this.player.caughtFish = {};
                    }
                    this.player.caughtFish[fishData.name] = true;
                    
                    // Show new fish banner
                    this.showNewFishBanner(fishData);
                }
                
                this.player.recentCatches.push(catchData);
                
                // Keep only last 50 catches to prevent memory issues
                if (this.player.recentCatches.length > 50) {
                    this.player.recentCatches = this.player.recentCatches.slice(-50);
                }

                // Update player stats
                this.player.money += value;
                this.player.experience += experience;
                this.player.totalCaught++;
                this.player.totalWeight += weight;

                // Update biggest catch (only for normal fishing, not tournaments)
                if ((!this.tournament || this.tournament.phase !== 'active') && weight > this.player.biggestCatch) {
                    this.player.biggestCatch = weight;
                }

                // Update top 10 biggest fish (only goes up, never down)
                // BUT: Tournament catches don't count toward normal leaderboards
                if (!this.tournament || this.tournament.phase !== 'active') {
                    this.updateTop10BiggestFish(catchData);
                }

                // Determine if this is a special catch
                const isRare = fishData.rarity === 'Rare' || fishData.rarity === 'Epic' || fishData.rarity === 'Legendary' || fishData.rarity === 'Trophy';
                const isHuge = weight > fishData.maxWeight * 0.8; // 80% of max weight
                const isLegendary = fishData.rarity === 'Legendary';
                const isTrophy = fishData.rarity === 'Trophy';
                
                // Play appropriate sound
                if (isLegendary || isTrophy) {
                    this.playSound('levelUp'); // Special celebration sound
                } else if (isRare || isHuge) {
                    this.playSound('bigCatch'); // Big fish sound
                } else {
                    this.playSound('catch'); // Regular fish sound
                }

                // Check for level up
                this.checkLevelUp();

                // Update leaderboard
                this.updateLeaderboard();

                // Show visual catch animation
                this.showCatchAnimation(fishData.name, weight);

                // Show catch message with rarity color
                let messageColor = '#00ff00'; // Default green
                let messageText = `Caught ${fishData.name}! ${weight.toFixed(1)}lbs, +$${value}`;
                
                // Special handling for tournament fish
                if (this.tournament && this.tournament.phase === 'active') {
                    const normalMax = fishData.maxWeight;
                    if (weight > normalMax * 1.5) {
                        messageColor = '#ff00ff'; // Magenta for MEGA tournament fish
                        messageText = `üé£ TOURNAMENT MEGA CATCH! ${fishData.name}! ${weight.toFixed(1)}lbs (${(weight/normalMax).toFixed(1)}x normal size!), +$${value}`;
                    } else if (weight > normalMax) {
                        messageColor = '#ffff00'; // Yellow for oversized tournament fish
                        messageText = `üé£ TOURNAMENT BIG CATCH! ${fishData.name}! ${weight.toFixed(1)}lbs, +$${value}`;
                    }
                } else {
                    // Normal fishing colors
                    if (isLegendary || isTrophy) messageColor = '#ff00ff'; // Magenta
                    else if (isRare) messageColor = '#00ffff'; // Cyan
                    else if (isHuge) messageColor = '#ffff00'; // Yellow
                }
                
                this.showMessage(messageText, messageColor);
                
                // Update tournament scores if in tournament
                if (this.tournament && this.tournament.phase === 'active') {
                    if (this.tournament.scores[this.player.name]) {
                        this.tournament.scores[this.player.name].totalWeight += weight;
                        this.tournament.scores[this.player.name].fishCount++;
                        if (weight > this.tournament.scores[this.player.name].biggestCatch) {
                            this.tournament.scores[this.player.name].biggestCatch = weight;
                        }
                        // Store the catch for tournament results
                        if (this.tournament.catches[this.player.name]) {
                            this.tournament.catches[this.player.name].push({
                                fish: fishData.name,
                                weight: weight,
                                value: value,
                                timestamp: Date.now()
                            });
                        }
                        // Update tournament display to show new stats
                        this.updateTournamentDisplay();
                    }
                }

                // Notify other players with special announcement for rare fish
                this.broadcastCatch(fishData, weight, value, isRare, isHuge, isLegendary, isTrophy);

                // Update mobile inventory
                const mobileRecentCatches = document.getElementById('mobile-recent-catches');
                if (mobileRecentCatches) {
                    this.renderRecentCatches(mobileRecentCatches);
                }

                this.updateDisplay();
                this.saveGameData(); // Auto-save after catching fish
            }

            checkLevelUp() {
                // Progressive experience requirements - MUCH higher for higher levels
                let expNeeded;
                if (this.player.level === 1) {
                    expNeeded = 100;
                } else if (this.player.level === 2) {
                    expNeeded = 150;
                } else if (this.player.level === 3) {
                    expNeeded = 225;
                } else if (this.player.level === 4) {
                    expNeeded = 350;
                } else if (this.player.level === 5) {
                    expNeeded = 500;
                } else if (this.player.level === 6) {
                    expNeeded = 750;
                } else if (this.player.level === 7) {
                    expNeeded = 1100;
                } else if (this.player.level === 8) {
                    expNeeded = 1600;
                } else if (this.player.level === 9) {
                    expNeeded = 2400;
                } else if (this.player.level === 10) {
                    expNeeded = 3500;
                } else if (this.player.level === 11) {
                    expNeeded = 5000;
                } else if (this.player.level === 12) {
                    expNeeded = 7000;
                } else if (this.player.level === 13) {
                    expNeeded = 10000;
                } else if (this.player.level === 14) {
                    expNeeded = 15000;
                } else {
                    // Level 15+: exponential increase
                    expNeeded = Math.floor(20000 * Math.pow(1.5, this.player.level - 15));
                }
                
                if (this.player.experience >= expNeeded) {
                    this.player.level++;
                    this.player.experience -= expNeeded;
                    
                    // Improve stats on level up
                    const statBonuses = this.improveStats();
                    
                    // Random funny level up messages
                    const levelUpMessages = [
                        `PURRFECT! You're now level ${this.player.level}! ${statBonuses} üê±`,
                        `LEVEL UP! Level ${this.player.level} achieved! You're the cat's pajamas! ${statBonuses} üò∏`,
                        `Pawsome! You leveled up to ${this.player.level}! ${statBonuses} üéâ`,
                        `Meowza! Level ${this.player.level} unlocked! ${statBonuses} üòπ`,
                        `Fur-real? Level ${this.player.level}? You're going places! ${statBonuses} üöÄ`,
                        `Purr-suasion level: ${this.player.level}! ${statBonuses} üí™`,
                        `You've clawed your way to level ${this.player.level}! ${statBonuses} üêæ`,
                        `That's a cat-ch! Level ${this.player.level} achieved! ${statBonuses} üèÜ`
                    ];
                    const randomLevelUpMsg = levelUpMessages[Math.floor(Math.random() * levelUpMessages.length)];
                    
                    this.showMessage(randomLevelUpMsg, '#ffff00');
                    this.addChatMessage('system', `${this.player.name} reached level ${this.player.level}! üéä`);
                    this.playSound('levelUp'); // Level up celebration sound
                    
                    // Check for new location unlocks
                    this.checkLocationUnlocks();
                    
                    // Check for new tackle unlocks
                    this.checkTackleUnlocks();
                    
                    // Check for achievements
                    this.checkAchievements();
                }
            }

            calculateExpForLevel(level) {
                // Progressive experience requirements - MUCH higher for higher levels
                if (level === 1) {
                    return 100;
                } else if (level === 2) {
                    return 150;
                } else if (level === 3) {
                    return 225;
                } else if (level === 4) {
                    return 350;
                } else if (level === 5) {
                    return 500;
                } else if (level === 6) {
                    return 750;
                } else if (level === 7) {
                    return 1100;
                } else if (level === 8) {
                    return 1600;
                } else if (level === 9) {
                    return 2400;
                } else if (level === 10) {
                    return 3500;
                } else if (level === 11) {
                    return 5000;
                } else if (level === 12) {
                    return 7000;
                } else if (level === 13) {
                    return 10000;
                } else if (level === 14) {
                    return 15000;
                } else {
                    // Level 15+: exponential increase
                    return Math.floor(20000 * Math.pow(1.5, level - 15));
                }
            }

            improveStats() {
                const bonuses = [];
                const level = this.player.level;
                
                // Every level: +1 to all stats
                this.player.stats.accuracy = Math.min(100, this.player.stats.accuracy + 1);
                this.player.stats.luck = Math.min(100, this.player.stats.luck + 1);
                this.player.stats.patience = Math.min(100, this.player.stats.patience + 1);
                this.player.stats.strength = Math.min(100, this.player.stats.strength + 1);
                bonuses.push('+1 All Stats');
                
                // Every 2 levels: +2 Accuracy
                if (level % 2 === 0) {
                    this.player.stats.accuracy = Math.min(100, this.player.stats.accuracy + 2);
                    bonuses.push('+2 Accuracy');
                }
                
                // Every 3 levels: +3 Luck
                if (level % 3 === 0) {
                    this.player.stats.luck = Math.min(100, this.player.stats.luck + 3);
                    bonuses.push('+3 Luck');
                }
                
                // Every 4 levels: +2 Patience
                if (level % 4 === 0) {
                    this.player.stats.patience = Math.min(100, this.player.stats.patience + 2);
                    bonuses.push('+2 Patience');
                }
                
                // Every 5 levels: +4 Strength
                if (level % 5 === 0) {
                    this.player.stats.strength = Math.min(100, this.player.stats.strength + 4);
                    bonuses.push('+4 Strength');
                }
                
                return bonuses.join(', ');
            }

            checkAchievements() {
                const achievements = [
                    {
                        id: 'first_catch',
                        name: 'üê± Purr-novice Angler',
                        description: 'Catch your first fish',
                        condition: () => this.player.totalCaught >= 1,
                        unlocked: this.player.achievements.includes('first_catch')
                    },
                    {
                        id: 'big_fish',
                        name: 'üêü Big Fish Hunter',
                        description: 'Catch a fish over 10 lbs',
                        condition: () => this.player.biggestCatch >= 10,
                        unlocked: this.player.achievements.includes('big_fish')
                    },
                    {
                        id: 'level_5',
                        name: '‚≠ê Rising Purr-star',
                        description: 'Reach level 5',
                        condition: () => this.player.level >= 5,
                        unlocked: this.player.achievements.includes('level_5')
                    },
                    {
                        id: 'level_10',
                        name: 'üåü Expert Purr-angler',
                        description: 'Reach level 10',
                        condition: () => this.player.level >= 10,
                        unlocked: this.player.achievements.includes('level_10')
                    },
                    {
                        id: 'money_maker',
                        name: 'üí∞ Purr-rize Winner',
                        description: 'Earn $1000',
                        condition: () => this.player.money >= 1000,
                        unlocked: this.player.achievements.includes('money_maker')
                    },
                    {
                        id: 'fish_master',
                        name: 'üê† Fish Meow-ster',
                        description: 'Catch 100 fish',
                        condition: () => this.player.totalCaught >= 100,
                        unlocked: this.player.achievements.includes('fish_master')
                    },
                    {
                        id: 'tournament_champ',
                        name: 'üèÜ Tournament Champ-purr',
                        description: 'Win a tournament',
                        condition: () => this.player.tournamentStats && this.player.tournamentStats.wins > 0,
                        unlocked: this.player.achievements.includes('tournament_champ')
                    },
                    {
                        id: 'gear_collector',
                        name: 'üéí Tackle Collector',
                        description: 'Own 10 pieces of tackle',
                        condition: () => {
                            let count = 0;
                            Object.values(this.player.tackleUnlocks).forEach(arr => count += arr.length);
                            return count >= 10;
                        },
                        unlocked: this.player.achievements.includes('gear_collector')
                    },
                    {
                        id: 'location_explorer',
                        name: 'üó∫Ô∏è Creek Explorer',
                        description: 'Unlock all locations',
                        condition: () => this.player.locationUnlocks.length >= this.locations.length,
                        unlocked: this.player.achievements.includes('location_explorer')
                    },
                    {
                        id: 'level_20',
                        name: '‚≠ê Meow-ster Angler',
                        description: 'Reach level 20',
                        condition: () => this.player.level >= 20,
                        unlocked: this.player.achievements.includes('level_20')
                    },
                    {
                        id: 'rare_catcher',
                        name: 'üíé Rare Fish Collector',
                        description: 'Catch 20 rare fish',
                        condition: () => {
                            const rareFish = this.player.recentCatches.filter(c => 
                                c.fish.rarity === 'Rare' || c.fish.rarity === 'Epic' || c.fish.rarity === 'Legendary'
                            ).length;
                            return rareFish >= 20;
                        },
                        unlocked: this.player.achievements.includes('rare_catcher')
                    },
                    {
                        id: 'biggest_bag',
                        name: 'üé£ Biggest Fish Bag',
                        description: 'Have a top 10 bag over 50 lbs',
                        condition: () => {
                            const top10Total = this.player.top10BiggestFish.reduce((sum, c) => sum + c.weight, 0);
                            return top10Total >= 50;
                        },
                        unlocked: this.player.achievements.includes('biggest_bag')
                    },
                    {
                        id: 'legendary_catch',
                        name: '‚ú® Legendary Purr-hunter',
                        description: 'Catch a legendary fish',
                        condition: () => {
                            return this.player.recentCatches.some(c => c.fish.rarity === 'Legendary');
                        },
                        unlocked: this.player.achievements.includes('legendary_catch')
                    },
                    {
                        id: 'tournament_legend',
                        name: 'üëë Tournament Legend',
                        description: 'Win 5 tournaments',
                        condition: () => this.player.tournamentStats && this.player.tournamentStats.wins >= 5,
                        unlocked: this.player.achievements.includes('tournament_legend')
                    },
                    {
                        id: 'wealthy_angler',
                        name: 'üíµ Wealthy Angler',
                        description: 'Earn $5000',
                        condition: () => this.player.money >= 5000,
                        unlocked: this.player.achievements.includes('wealthy_angler')
                    }
                ];

                achievements.forEach(achievement => {
                    if (!achievement.unlocked && achievement.condition()) {
                        this.player.achievements.push(achievement.id);
                        this.showMessage(`Achievement Unlocked: ${achievement.name}!`, '#ffd700');
                        this.addChatMessage('system', `${this.player.name} unlocked: ${achievement.name}!`);
                        this.updateAchievementsDisplay();
                    }
                });
            }

            updateAchievementsDisplay() {
                const achievementsContainer = document.getElementById('achievements');
                const mobileAchievementsContainer = document.getElementById('mobile-achievements');
                const achievements = [
                    { id: 'first_catch', name: 'üé£ Novice Angler', description: 'Catch your first fish' },
                    { id: 'big_fish', name: 'üêü Big Fish Hunter', description: 'Catch a fish over 10 lbs' },
                    { id: 'level_5', name: '‚≠ê Rising Star', description: 'Reach level 5' },
                    { id: 'level_10', name: 'üåü Expert Angler', description: 'Reach level 10' },
                    { id: 'money_maker', name: 'üí∞ Money Maker', description: 'Earn $1000' },
                    { id: 'fish_master', name: 'üê† Fish Master', description: 'Catch 100 fish' },
                    { id: 'tournament_champ', name: 'üèÜ Tournament Champion', description: 'Win a tournament' },
                    { id: 'gear_collector', name: 'üéí Gear Collector', description: 'Own 10 pieces of tackle' },
                    { id: 'location_explorer', name: 'üó∫Ô∏è Location Explorer', description: 'Unlock all locations' },
                    { id: 'level_20', name: '‚≠ê Master Angler', description: 'Reach level 20' },
                    { id: 'rare_catcher', name: 'üíé Rare Fish Collector', description: 'Catch 20 rare fish' },
                    { id: 'biggest_bag', name: 'üé£ Biggest Bag', description: 'Have a top 10 bag over 50 lbs' },
                    { id: 'legendary_catch', name: '‚ú® Legendary Hunter', description: 'Catch a legendary fish' },
                    { id: 'tournament_legend', name: 'üëë Tournament Legend', description: 'Win 5 tournaments' },
                    { id: 'wealthy_angler', name: 'üíµ Wealthy Angler', description: 'Earn $5000' }
                ];

                const achievementHTML = achievements.map(achievement => {
                    const unlocked = this.player.achievements.includes(achievement.id);
                    return `<div class="achievement-item ${unlocked ? '' : 'locked'}" title="${achievement.description}">${achievement.name}</div>`;
                }).join('');

                if (achievementsContainer) achievementsContainer.innerHTML = achievementHTML;
                if (mobileAchievementsContainer) mobileAchievementsContainer.innerHTML = achievementHTML;
            }

            checkLocationUnlocks() {
                let newUnlocks = [];
                this.locations.forEach((location, index) => {
                    if (!this.player.locationUnlocks.includes(index) && this.player.level >= location.unlockLevel) {
                        this.player.locationUnlocks.push(index);
                        newUnlocks.push(location.name);
                    }
                });
                
                if (newUnlocks.length > 0) {
                    this.showCongratulationsPopup('location', newUnlocks);
                    this.showMessage(`New locations unlocked: ${newUnlocks.join(', ')}!`, '#00ffff');
                    this.addChatMessage('system', `New locations unlocked: ${newUnlocks.join(', ')}!`);
                    this.updateLocationButtons(); // Refresh dropdown to show unlocked locations
                }
            }

            checkTackleUnlocks() {
                let newUnlocks = [];
                
                // Check rod unlocks
                this.tackle.rods.forEach((rod, index) => {
                    if (!this.player.tackleUnlocks.rods.includes(index) && this.player.level >= rod.unlockLevel) {
                        this.player.tackleUnlocks.rods.push(index);
                        newUnlocks.push(rod.name);
                    }
                });
                
                // Check reel unlocks
                this.tackle.reels.forEach((reel, index) => {
                    if (!this.player.tackleUnlocks.reels.includes(index) && this.player.level >= reel.unlockLevel) {
                        this.player.tackleUnlocks.reels.push(index);
                        newUnlocks.push(reel.name);
                    }
                });
                
                // Check line unlocks
                this.tackle.lines.forEach((line, index) => {
                    if (!this.player.tackleUnlocks.lines.includes(index) && this.player.level >= line.unlockLevel) {
                        this.player.tackleUnlocks.lines.push(index);
                        newUnlocks.push(line.name);
                    }
                });
                
                // Check hook unlocks
                this.tackle.hooks.forEach((hook, index) => {
                    if (!this.player.tackleUnlocks.hooks.includes(index) && this.player.level >= hook.unlockLevel) {
                        this.player.tackleUnlocks.hooks.push(index);
                        newUnlocks.push(hook.name);
                    }
                });
                
                // Check bait unlocks
                this.tackle.baits.forEach((bait, index) => {
                    if (!this.player.tackleUnlocks.baits.includes(index) && this.player.level >= bait.unlockLevel) {
                        this.player.tackleUnlocks.baits.push(index);
                        newUnlocks.push(bait.name);
                    }
                });
                
                if (newUnlocks.length > 0) {
                    this.showCongratulationsPopup('tackle', newUnlocks);
                    this.showMessage(`New tackle unlocked: ${newUnlocks.join(', ')}!`, '#ff00ff');
                    this.addChatMessage('system', `New tackle unlocked: ${newUnlocks.join(', ')}!`);
                }
                
                this.saveGameData(); // Auto-save after unlocking new content
            }

            changeLocation(index) {
                // Convert string to number if needed
                index = parseInt(index);
                
                if (isNaN(index) || index < 0 || index >= this.locations.length) {
                    this.showMessage('Invalid location!', '#ff0000');
                    return;
                }
                
                const location = this.locations[index];
                
                // Check if location is unlocked
                if (!this.player.locationUnlocks.includes(index)) {
                    this.showMessage(`Location locked! Reach level ${location.unlockLevel} to unlock.`, '#ff0000');
                    return;
                }
                
                if (this.player.money < location.cost) {
                    this.showMessage('Not enough money!', '#ff0000');
                    return;
                }

                this.currentLocation = index;
                this.player.money -= location.cost;
                
                // Update location buttons
                document.querySelectorAll('.location-btn').forEach((btn, i) => {
                    btn.classList.toggle('active', i === index);
                });

                this.updateDisplay();
                this.addChatMessage('system', `${this.player.name} moved to ${location.name}`);
                this.saveGameData(); // Auto-save after changing location
            }

            simulateMultiplayer() {
                // Simulate other players with unique AI names
                const aiNames = ['Tommy the Stray', 'Sly Sylvester', 'Felix the Feline', 'Whiskers McFluff', 'Captain Claw', 'Mittens the Master', 'Purr-fect Pete', 'Tabby the Tank'];
                
                // Add 3-6 random AI players (all cats!)
                const numPlayers = Math.floor(Math.random() * 4) + 3;
                for (let i = 0; i < numPlayers; i++) {
                    // Use cat rig system for AI players
                    const catCharacter = 'cat-rig';
                    
                    this.otherPlayers.push({
                        name: aiNames[i], // Use unique AI names
                        level: Math.floor(Math.random() * 10) + 1,
                        fishing: false,
                        catches: Math.floor(Math.random() * 50),
                        isCasting: false,
                        biggestCatch: Math.random() * 15, // Random biggest catch 0-15 lbs
                        recentCatches: this.generateSimulatedCatches(Math.floor(Math.random() * 20) + 5), // 5-25 catches
                        isSimulated: true, // Mark as AI player
                        character: catCharacter // Use cat rig system
                    });
                }

                // Simulate other players fishing (only AI players) - staggered timing
                // Start each AI player with a random delay to stagger their actions
                this.otherPlayers.forEach((player, index) => {
                    if (player.isSimulated) {
                        // Each AI player starts fishing at a different time
                        const initialDelay = index * 1000 + Math.random() * 2000; // Stagger: 1-3s apart per player
                        setTimeout(() => {
                            // Start the first cast for this AI player
                            if (Math.random() < 0.5) {
                                this.simulateOtherPlayerFishing(index);
                            }
                        }, initialDelay);
                    }
                });
                
                // Continuous simulation with random intervals
                setInterval(() => {
                    this.otherPlayers.forEach((player, index) => {
                        // Only simulate AI players, not real players
                        if (player.isSimulated && !player.isCasting && Math.random() < 0.15) {
                            // Random delay before casting (0-3 seconds)
                            const castDelay = Math.random() * 3000;
                            setTimeout(() => {
                                if (this.otherPlayers[index] && !this.otherPlayers[index].isCasting) {
                                    this.simulateOtherPlayerFishing(index);
                                }
                            }, castDelay);
                        }
                    });
                }, 4000 + Math.random() * 4000); // Check every 4-8 seconds

                // Update leaderboard periodically
                setInterval(() => {
                    this.updateLeaderboard();
                }, 5000); // Update every 5 seconds

                // Simulate other players catching fish
                setInterval(() => {
                    if (Math.random() < 0.2) {
                        const randomPlayer = this.otherPlayers[Math.floor(Math.random() * this.otherPlayers.length)];
                        const fishTypes = Object.keys(this.fishTypes);
                        const randomFish = fishTypes[Math.floor(Math.random() * fishTypes.length)];
                        const fishData = this.fishTypes[randomFish];
                        
                        // Add humor based on the cat's personality
                        const exclamations = ['üê± Meow!', 'üé£ Purrfect!', 'üò∏ Nice one!', 'üêü Fishy!', 'üí™ Get it!'];
                        const exclamation = exclamations[Math.floor(Math.random() * exclamations.length)];
                        this.addChatMessage('other', `${randomPlayer.name} caught a ${fishData.name}! ${exclamation}`);
                    }
                }, 5000 + Math.random() * 10000);

                this.updateOnlinePlayers();
            }

            simulateOtherPlayerFishing(playerIndex) {
                const player = this.otherPlayers[playerIndex];
                player.isCasting = true;
                player.fishing = true;
                
                // Add fishing line for this player
                this.addFishingLine(playerIndex + 1, true);
                
                // Update fisherman visual
                const fishermen = document.querySelectorAll('.fisherman');
                if (fishermen[playerIndex + 1]) {
                    fishermen[playerIndex + 1].classList.add('fishing');
                }
                
                // Show chat bubble with funny fishing sayings (only 30% of the time)
                if (player.isSimulated && Math.random() < 0.3) {
        const fishingSayings = [
            // Actually funny jokes
            'üê± Every day I wake up and choose violence... against fish.',
            'üò∏ They said fishing is relaxing... I\'ve been lied to.',
            'üêü I bet you can\'t name ONE fish that has thumbs.',
            'üé£ My therapy bill this year: $10,000. Catching fish: priceless.',
            'üò∫ I\'m not addicted to fishing... I can quit anytime I want!',
            'üê± If fish could scream, this lake would be unbearable.',
            'üé£ They told me to \'go fish\'... I went too far.',
            'üò∏ My Wi‚ÄëFi password? \'FishAreFriendsNotFood\'. My guilt? Immense.',
            'üêü A fish just swam by and gave me the middle fin. I respect that.',
            'üé£ I came here for fish. All I\'ve caught is depression.',
            'üò∫ My fish got away... must\'ve been a slick swimmer!',
            'üê± This is my 9th cast... call me NINE lives!',
            'üé£ I\'m fishing for compliments AND fish!',
            'üò∏ What do you call a fake noodle? An impasta!',
            'üêü I threw my rod in a lake once... came back with a trout!',
            'üé£ Why did the fish blush? It saw the ocean\'s bottom!',
            'üò∫ Want to hear a dirty joke? White cat fell in mud!',
            'üê± What do you call a sleeping fish? A SEA-scape artist!',
            'üé£ My fishing spot is the CAT\'s meow!',
            'üò∏ I told my cat a joke... his paws clapped!',
            'üêü What\'s a pirate\'s favorite fish? A SEA bass!',
            'üé£ Why are cats terrible at poker? They always show their PUNCH!',
            'üò∫ I saw a fish fight today... a SEA-saw battle!',
            'üê± What\'s a cat\'s favorite fish? A CATfish, duh!',
            'üé£ Want to hear a joke about pizza? Never mind, it\'s too cheesy!',
            'üò∏ What do you call a cat that catches fish? A SEA lion!',
            'üêü My fishing line is tangling... looks FISHY to me!',
            'üé£ Why don\'t cats like computer tech support? Because they keep saying PURR-TECH-no issues!',
            'üò∫ What\'s a fish\'s favorite dance? The fin dance!',
            'üê± I tried to catch a fish... ended up with a tackle BONUS!',
            'üé£ My cat tried to order sushi... it was a CAT-astrophic idea!',
            'üò∏ What do you call a fish with a tie? Sashimi-chic!',
            'üêü Why are fish smart? They swim in SCHOOLS!',
            'üé£ My fishing pole broke... must be my fin-al one!',
            'üò∫ What do you call a bear with no teeth? A gummy bear!',
            'üê± I asked my fish for a loan... he gave me SEA-surance!',
            'üé£ Why did the catfish go to prison? Because it was an accessory to mullet!',
            'üò∏ My cat caught a shark... now he\'s JAW-some!',
            'üêü What\'s the best kind of fish? An OCEAN addict!',
            'üé£ Fish are my therapy... they really SCHOOL me!',
            'üò∫ My cat went fishing... came back with PURR-chains!',
            'üê± What did the fish say when it hit the wall? DAAAAAAAM!',
            'üé£ I hooked a fish... it said "REEL-y?! Come on!"',
            'üò∏ What do you call a fish with no eyes? Fsh...',
            'üêü My tackle box is organized... I\'m HOOK-ed on fishing!',
            'üé£ Why don\'t fish play basketball? They\'re afraid of the NET!',
            'üò∫ My fish told a joke... it was FISHY but funny!',
            'üê± What\'s a cat\'s favorite game? Hide and SEEK-roi!',
            'üé£ My fishing buddy won\'t stop talking... he\'s FISHY social!',
            'üò∏ What do you call a fish wearing a crown? KING fish!',
            'üêü I tried to catch a fish with sand... got me a SEA-wich!',
            'üé£ Why did the fish get bad grades? Because it was BELOW C level!',
            'üò∫ My cat is a professional... he\'s CLAAAWW-some!',
            'üê± What do cats use to catch fish? PAW-ers!',
            'üé£ My fishing line snapped... it\'s my last STRAW!'
        ];
                    const saying = fishingSayings[Math.floor(Math.random() * fishingSayings.length)];
                    this.showChatBubble(playerIndex + 1, saying);
                }
                
                // Simulate fishing duration - randomized between 2-5 seconds
                const fishingDuration = 2000 + Math.random() * 3000;
                setTimeout(() => {
                    if (!this.otherPlayers[playerIndex]) return; // Player might have left
                    
                    player.isCasting = false;
                    player.fishing = false;
                    
                    // Remove fishing line and splash - use player name for reliable removal
                    const lake = document.getElementById('fishing-lake');
                    const mobileLake = document.getElementById('mobile-fishing-lake');
                    const activeLake = window.innerWidth <= 768 ? mobileLake : lake;
                    
                    if (activeLake) {
                        const lines = activeLake.querySelectorAll('.fishing-line');
                        lines.forEach(line => {
                            // Match by player index or name
                            if (line.dataset.playerIndex == (playerIndex + 1).toString() || 
                                line.dataset.playerName === player.name) {
                                // Remove associated splash
                                const splashId = line.dataset.splashId;
                                if (splashId) {
                                    const splash = document.getElementById(splashId);
                                    if (splash) splash.remove();
                                }
                                line.remove();
                            }
                        });
                        
                        // Clean up any remaining splashes
                        const splashes = activeLake.querySelectorAll('.hook-splash');
                        splashes.forEach(splash => splash.remove());
                    }
                    
                    // Update fisherman visual
                    const fishermen = document.querySelectorAll('.fisherman, .mobile-fisherman');
                    if (fishermen[playerIndex + 1]) {
                        fishermen[playerIndex + 1].classList.remove('fishing');
                    }
                    
                    // Random chance to catch fish
                    if (Math.random() < 0.6) {
                        const randomFishType = Math.floor(Math.random() * this.fishTypes.length);
                        const fishData = this.fishTypes[randomFishType];
                        
                        const weight = fishData.minWeight + Math.random() * (fishData.maxWeight - fishData.minWeight);
                        const value = Math.floor(fishData.value * (1 + weight / fishData.maxWeight));
                        
                        // Add catch to player's recent catches
                        const catchData = {
                            fish: fishData,
                            weight: weight,
                            value: value,
                            experience: Math.floor(fishData.experience * (1 + weight / fishData.maxWeight)),
                            location: this.locations[Math.floor(Math.random() * this.locations.length)].name,
                            timestamp: Date.now()
                        };
                        
                        player.recentCatches.push(catchData);
                        
                        // Keep only last 50 catches
                        if (player.recentCatches.length > 50) {
                            player.recentCatches = player.recentCatches.slice(-50);
                        }
                        
                        // Update biggest catch
                        if (weight > player.biggestCatch) {
                            player.biggestCatch = weight;
                        }
                        
                        // Only show chat message for simulated (AI) players, not real players
                        if (player.isSimulated) {
                            // Add funny reactions for bot cats
                            const reactions = ['üê± Meow!', 'üé£ Purrfect catch!', 'üò∏ Look at that!', 'üêü Fishy business!', 'üí™ Pawsome!'];
                            const reaction = reactions[Math.floor(Math.random() * reactions.length)];
                            this.addChatMessage('other', `${player.name} caught a ${fishData.name} (${weight.toFixed(1)} lbs)! ${reaction}`);
                        }
                    }
                }, 2000 + Math.random() * 3000);
            }

            updateOnlinePlayers() {
                const container = document.getElementById('online-players');
                container.innerHTML = '';
                
                // Add current player
                const playerItem = document.createElement('div');
                playerItem.className = 'player-item';
                playerItem.innerHTML = `${this.player.name} (You) - Level ${this.player.level}`;
                container.appendChild(playerItem);

                // Add other players
                this.otherPlayers.forEach(player => {
                    const item = document.createElement('div');
                    item.className = `player-item ${player.fishing ? 'fishing' : ''}`;
                    item.innerHTML = `${player.name} - Level ${player.level} ${player.fishing ? '(Fishing)' : ''}`;
                    container.appendChild(item);
                });
            }

            broadcastCatch(fishData, weight, value, isRare = false, isHuge = false, isLegendary = false, isTrophy = false) {
                const fishName = fishData.name;
                const rarity = fishData.rarity;
                
                // MUCH STRICTER: Only broadcast TOP 1-2% catches
                // - Legendary/Trophy fish (automatic broadcast)
                // - Fish that are 95%+ of their max weight (truly HUGE)
                // - RARE/EPIC fish over 90% of max weight
                const percentOfMax = weight / fishData.maxWeight;
                const trulyExceptional = isLegendary || isTrophy || 
                                        (percentOfMax >= 0.95 && isHuge) ||
                                        (rarity === 'Rare' || rarity === 'Epic') && percentOfMax >= 0.90;
                
                // Only broadcast truly exceptional catches or tournament catches
                if (this.socket && this.connected && (trulyExceptional || (this.tournament && this.tournament.active))) {
                    this.socket.emit('catch-fish', {
                        fish: fishData,
                        weight: weight,
                        value: value,
                        isRare: isRare,
                        isHuge: isHuge,
                        isLegendary: isLegendary,
                        isTrophy: isTrophy,
                        tournamentId: this.tournament && this.tournament.active ? this.tournament.tournamentId : null
                    });
                }
                
                // Always show personal notification for your own catches
                // Create special announcement for rare fish
                if (isLegendary || isTrophy) {
                    this.addChatMessage('legendary', `üèÜ LEGENDARY CATCH! ${this.player.name} caught a ${fishName}! ${weight.toFixed(1)}lbs, +$${value} üèÜ`);
                    this.showGlobalAnnouncement(`üèÜ LEGENDARY CATCH! ${this.player.name} caught a ${fishName}! ${weight.toFixed(1)}lbs üèÜ`, '#ff00ff');
                } else if (isRare) {
                    this.addChatMessage('rare', `üíé RARE CATCH! ${this.player.name} caught a ${fishName}! ${weight.toFixed(1)}lbs, +$${value} üíé`);
                    this.showGlobalAnnouncement(`üíé RARE CATCH! ${this.player.name} caught a ${fishName}! ${weight.toFixed(1)}lbs üíé`, '#00ffff');
                } else if (isHuge) {
                    this.addChatMessage('huge', `üêü HUGE FISH! ${this.player.name} caught a massive ${fishName}! ${weight.toFixed(1)}lbs, +$${value} üêü`);
                    this.showGlobalAnnouncement(`üêü HUGE FISH! ${this.player.name} caught a massive ${fishName}! ${weight.toFixed(1)}lbs üêü`, '#ffff00');
                } else {
                    // Regular catch - only show personal message, not broadcast to others
                    this.addChatMessage('own', `You caught a ${fishName}! ${weight.toFixed(1)}lbs, +$${value}`);
                }
            }

            showRareFishBanner(fishData, weight, value, isLegendary, isTrophy) {
                const banner = document.createElement('div');
                banner.className = 'rare-fish-banner';
                
                let bannerClass = 'rare';
                let icon = 'üíé';
                let title = 'RARE CATCH!';
                
                if (isLegendary) {
                    bannerClass = 'legendary';
                    icon = 'üèÜ';
                    title = 'LEGENDARY CATCH!';
                } else if (isTrophy) {
                    bannerClass = 'trophy';
                    icon = 'üèÖ';
                    title = 'TROPHY CATCH!';
                }
                
                banner.innerHTML = `
                    <div class="banner-content ${bannerClass}">
                        <div class="banner-icon">${icon}</div>
                        <div class="banner-text">
                            <h2>${title}</h2>
                            <p>${fishData.name} - ${weight.toFixed(1)}lbs</p>
                            <p>+$${value} | ${fishData.rarity}</p>
                        </div>
                        <div class="banner-icon">${icon}</div>
                    </div>
                `;
                
                // Add CSS for the banner
                const style = document.createElement('style');
                style.textContent = `
                    .rare-fish-banner {
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        z-index: 10001;
                        animation: bannerSlideIn 0.8s ease-out;
                    }
                    
                    .banner-content {
                        background: linear-gradient(135deg, #001100, #003300);
                        border: 4px solid;
                        border-radius: 20px;
                        padding: 30px 50px;
                        text-align: center;
                        box-shadow: 0 0 40px;
                        display: flex;
                        align-items: center;
                        gap: 20px;
                        min-width: 400px;
                    }
                    
                    .banner-content.legendary {
                        border-color: #ff00ff;
                        box-shadow: 0 0 40px rgba(255, 0, 255, 0.8);
                    }
                    
                    .banner-content.rare {
                        border-color: #64b5f6;
                        box-shadow: 0 0 40px rgba(0, 255, 255, 0.8);
                    }
                    
                    .banner-content.trophy {
                        border-color: #ffff00;
                        box-shadow: 0 0 40px rgba(255, 255, 0, 0.8);
                    }
                    
                    .banner-icon {
                        font-size: 48px;
                        animation: bounce 1s infinite;
                    }
                    
                    .banner-text h2 {
                        margin: 0 0 10px 0;
                        font-size: 28px;
                        text-shadow: 0 0 10px;
                    }
                    
                    .banner-text p {
                        margin: 5px 0;
                        font-size: 18px;
                    }
                    
                    .banner-content.legendary h2 {
                        color: #ff00ff;
                    }
                    
                    .banner-content.rare h2 {
                        color: #64b5f6;
                    }
                    
                    .banner-content.trophy h2 {
                        color: #ffff00;
                    }
                    
                    @keyframes bannerSlideIn {
                        from { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
                        to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                    }
                    
                    @keyframes bounce {
                        0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
                        40% { transform: translateY(-10px); }
                        60% { transform: translateY(-5px); }
                    }
                    
                    .new-fish-banner {
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        z-index: 10001;
                        animation: bannerSlideIn 0.8s ease-out;
                    }
                    
                    .new-fish-content {
                        background: linear-gradient(135deg, #003300, #004400);
                        border: 4px solid #00ff00;
                        border-radius: 20px;
                        padding: 30px 50px;
                        text-align: center;
                        box-shadow: 0 0 40px rgba(0, 255, 0, 0.8);
                        min-width: 400px;
                    }
                    
                    .new-fish-image-container {
                        width: 150px;
                        height: 150px;
                        margin: 20px auto;
                        background: rgba(0, 0, 0, 0.3);
                        border: 3px solid #00ff00;
                        border-radius: 15px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        overflow: hidden;
                    }
                    
                    .new-fish-image-container img {
                        width: 100%;
                        height: 100%;
                        object-fit: contain;
                    }
                    
                    .new-fish-content h2 {
                        color: #00ff00;
                        font-size: 28px;
                        margin-bottom: 10px;
                        text-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
                    }
                    
                    .new-fish-content p {
                        color: #64b5f6;
                        font-size: 18px;
                        margin: 5px 0;
                    }
                    
                    @media (max-width: 768px) {
                        .new-fish-banner {
                            width: 90vw;
                            max-width: 350px;
                        }
                        
                        .new-fish-content {
                            min-width: auto;
                            padding: 20px 15px;
                            border: 3px solid #00ff00;
                            border-radius: 15px;
                        }
                        
                        .new-fish-image-container {
                            width: 80px;
                            height: 80px;
                            margin: 10px auto;
                        }
                        
                        .new-fish-content h2 {
                            font-size: 18px;
                            margin-bottom: 5px;
                        }
                        
                        .new-fish-content p {
                            font-size: 12px;
                            margin: 3px 0;
                        }
                    }
                `;
                
                document.head.appendChild(style);
                document.body.appendChild(banner);
                
                // Auto-remove after 5 seconds
                setTimeout(() => {
                    if (banner.parentElement) {
                        banner.style.animation = 'bannerSlideIn 0.5s ease-in reverse';
                        setTimeout(() => {
                            banner.remove();
                            style.remove();
                        }, 500);
                    }
                }, 5000);
            }

            showNewFishBanner(fishData) {
                // Remove any existing new fish banners to prevent duplicates
                const existing = document.querySelectorAll('.new-fish-banner');
                existing.forEach(el => el.remove());
                
                const banner = document.createElement('div');
                banner.className = 'new-fish-banner';
                
                const fishImage = `images/${fishData.name}.png`;
                
                banner.innerHTML = `
                    <div class="new-fish-content">
                        <h2>üéâ NEW FISH!</h2>
                        <div class="new-fish-image-container">
                            <img src="${fishImage}" alt="${fishData.name}" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=\\'http://www.w3.org/2000/svg\\' viewBox=\\'0 0 100 100\\'%3E%3Ctext y=\\'.9em\\' font-size=\\'60\\'%3Eüêü%3C/text%3E%3C/svg%3E';">
                        </div>
                        <p><strong>${fishData.name}</strong></p>
                        <p>${fishData.rarity}</p>
                    </div>
                `;
                
                // Add CSS for the new fish banner
                const style = document.createElement('style');
                style.textContent = `
                    .new-fish-banner {
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        z-index: 10001;
                        animation: bannerSlideIn 0.8s ease-out;
                    }
                    
                    .new-fish-content {
                        background: linear-gradient(135deg, #003300, #004400);
                        border: 4px solid #00ff00;
                        border-radius: 20px;
                        padding: 30px 50px;
                        text-align: center;
                        box-shadow: 0 0 40px rgba(0, 255, 0, 0.8);
                        min-width: 400px;
                    }
                    
                    .new-fish-image-container {
                        width: 150px;
                        height: 150px;
                        margin: 20px auto;
                        background: rgba(0, 0, 0, 0.3);
                        border: 3px solid #00ff00;
                        border-radius: 15px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        overflow: hidden;
                    }
                    
                    .new-fish-image-container img {
                        width: 100%;
                        height: 100%;
                        object-fit: contain;
                    }
                    
                    .new-fish-content h2 {
                        color: #00ff00;
                        font-size: 28px;
                        margin-bottom: 10px;
                        text-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
                    }
                    
                    .new-fish-content p {
                        color: #64b5f6;
                        font-size: 18px;
                        margin: 5px 0;
                    }
                    
                    @media (max-width: 768px) {
                        .new-fish-banner {
                            width: 90vw;
                            max-width: 350px;
                        }
                        
                        .new-fish-content {
                            min-width: auto;
                            padding: 20px 15px;
                            border: 3px solid #00ff00;
                            border-radius: 15px;
                        }
                        
                        .new-fish-image-container {
                            width: 80px;
                            height: 80px;
                            margin: 10px auto;
                        }
                        
                        .new-fish-content h2 {
                            font-size: 18px;
                            margin-bottom: 5px;
                        }
                        
                        .new-fish-content p {
                            font-size: 12px;
                            margin: 3px 0;
                        }
                    }
                    
                    @keyframes bannerSlideIn {
                        from { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
                        to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                    }
                `;
                
                document.head.appendChild(style);
                document.body.appendChild(banner);
                
                // Auto-remove after 5 seconds
                setTimeout(() => {
                    if (banner.parentElement) {
                        banner.style.animation = 'bannerSlideIn 0.5s ease-in reverse';
                        setTimeout(() => {
                            banner.remove();
                            style.remove();
                        }, 500);
                    }
                }, 5000);
            }

            showGlobalAnnouncement(message, color) {
                // Remove any existing announcements to prevent duplicates
                const existing = document.querySelectorAll('.global-announcement');
                existing.forEach(el => el.remove());
                
                const announcement = document.createElement('div');
                announcement.className = 'global-announcement';
                announcement.innerHTML = `
                    <div class="announcement-content" style="color: ${color}; border-color: ${color}; box-shadow: 0 0 20px ${color}40;">
                        ${message}
                    </div>
                `;
                
                // Add CSS for the announcement
                const style = document.createElement('style');
                style.textContent = `
                    .global-announcement {
                        position: fixed;
                        bottom: 120px;
                        left: 50%;
                        transform: translateX(-50%);
                        z-index: 10000;
                        animation: announcementSlideUp 0.6s ease-out;
                    }
                    
                    .announcement-content {
                        background: linear-gradient(135deg, #001100, #003300);
                        border: 3px solid;
                        border-radius: 10px;
                        padding: 15px 30px;
                        text-align: center;
                        font-size: 18px;
                        font-weight: bold;
                        text-shadow: 0 0 10px;
                        max-width: 90vw;
                        word-wrap: break-word;
                        overflow-wrap: break-word;
                    }
                    
                    @media (max-width: 768px) {
                        .global-announcement {
                            bottom: 160px; /* Above mobile controls */
                        }
                        .announcement-content {
                            font-size: 12px;
                            padding: 10px 16px;
                            white-space: normal;
                            line-height: 1.4;
                            max-width: 90vw;
                        }
                    }
                    
                    @keyframes announcementSlideUp {
                        from { transform: translateX(-50%) translateY(100px); opacity: 0; }
                        to { transform: translateX(-50%) translateY(0); opacity: 1; }
                    }
                `;
                
                document.head.appendChild(style);
                document.body.appendChild(announcement);
                
                // Auto-remove after 4 seconds
                setTimeout(() => {
                    if (announcement.parentElement) {
                        announcement.style.animation = 'announcementSlideUp 0.4s ease-in reverse';
                        setTimeout(() => {
                            announcement.remove();
                            style.remove();
                        }, 400);
                    }
                }, 4000);
            }

            showFishInfo(fishName) {
                const fishData = this.fishTypes.find(f => f.name === fishName);
                if (!fishData) return;
                
                const facts = this.fishFacts[fishName] || { fact: 'A mysterious fish.', fun: 'Full of surprises!', real: 'Still being studied.' };
                
                // Remove any existing fish info modal
                const existing = document.querySelector('.fish-info-modal');
                if (existing) existing.remove();
                
                const modal = document.createElement('div');
                modal.className = 'fish-info-modal';
                modal.innerHTML = `
                    <div class="fish-info-content">
                        <div class="fish-info-header">
                            <button class="fish-info-close" onclick="this.closest('.fish-info-modal').remove()">‚úï</button>
                            <h2>${fishData.name}</h2>
                            <div style="color: #64b5f6; font-size: 12px;">${fishData.rarity}</div>
                        </div>
                        <div class="fish-info-image">
                            <img src="images/${fishData.name}.png" alt="${fishData.name}" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=\\'http://www.w3.org/2000/svg\\' viewBox=\\'0 0 100 100\\'%3E%3Ctext y=\\'.9em\\' font-size=\\'60\\'%3Eüêü%3C/text%3E%3C/svg%3E';">
                        </div>
                        <div class="fish-info-stats">
                            <div class="fish-stat"><strong>Weight:</strong> ${fishData.minWeight.toFixed(1)} - ${fishData.maxWeight.toFixed(1)} lbs</div>
                            <div class="fish-stat"><strong>Value:</strong> $${fishData.value}</div>
                            <div class="fish-stat"><strong>Experience:</strong> ${fishData.experience} XP</div>
                            <div class="fish-stat"><strong>Season:</strong> ${fishData.season}</div>
                        </div>
                        <div class="fish-info-facts">
                            <div class="fish-fact"><strong>üêü Fish Fact:</strong> ${facts.fact}</div>
                            <div class="fish-fact"><strong>üò∏ Fun Fact:</strong> ${facts.fun}</div>
                            <div class="fish-fact"><strong>üìö Cool Fact:</strong> ${facts.real}</div>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Add CSS
                const style = document.createElement('style');
                style.textContent = `
                    .fish-info-modal {
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.8);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        z-index: 10002;
                        animation: fadeIn 0.3s ease-out;
                    }
                    
                    .fish-info-content {
                        background: linear-gradient(135deg, #001122, #003344);
                        border: 3px solid #00ffff;
                        border-radius: 20px;
                        padding: 30px;
                        max-width: 500px;
                        width: 90%;
                        max-height: 90vh;
                        overflow-y: auto;
                        box-shadow: 0 0 40px rgba(0, 255, 255, 0.5);
                        animation: slideIn 0.3s ease-out;
                    }
                    
                    .fish-info-header {
                        text-align: center;
                        margin-bottom: 20px;
                        position: relative;
                    }
                    
                    .fish-info-close {
                        position: absolute;
                        top: -5px;
                        right: -5px;
                        background: #ff0000;
                        border: none;
                        color: white;
                        width: 30px;
                        height: 30px;
                        border-radius: 50%;
                        cursor: pointer;
                        font-size: 18px;
                        font-weight: bold;
                        transition: transform 0.2s;
                    }
                    
                    .fish-info-close:hover {
                        transform: scale(1.1);
                    }
                    
                    .fish-info-header h2 {
                        color: #00ffff;
                        margin: 10px 0 5px 0;
                        text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
                    }
                    
                    .fish-info-image {
                        text-align: center;
                        margin: 20px 0;
                    }
                    
                    .fish-info-image img {
                        width: 150px;
                        height: 150px;
                        object-fit: contain;
                        border: 3px solid #00ffff;
                        border-radius: 15px;
                        background: rgba(0, 0, 0, 0.3);
                        padding: 10px;
                    }
                    
                    .fish-info-stats {
                        background: rgba(0, 0, 0, 0.3);
                        padding: 15px;
                        border-radius: 10px;
                        margin: 20px 0;
                    }
                    
                    .fish-stat {
                        color: #64b5f6;
                        margin: 8px 0;
                        font-size: 14px;
                    }
                    
                    .fish-info-facts {
                        margin-top: 20px;
                    }
                    
                    .fish-fact {
                        background: rgba(0, 255, 255, 0.1);
                        padding: 12px;
                        border-radius: 8px;
                        margin: 10px 0;
                        color: #ffffff;
                        font-size: 13px;
                        line-height: 1.6;
                        border-left: 3px solid #00ffff;
                    }
                    
                    @keyframes fadeIn {
                        from { opacity: 0; }
                        to { opacity: 1; }
                    }
                    
                    @keyframes slideIn {
                        from { transform: scale(0.8); opacity: 0; }
                        to { transform: scale(1); opacity: 1; }
                    }
                    
                    @media (max-width: 768px) {
                        .fish-info-content {
                            padding: 20px;
                            max-width: 95%;
                        }
                        
                        .fish-info-image img {
                            width: 120px;
                            height: 120px;
                        }
                        
                        .fish-stat {
                            font-size: 12px;
                        }
                        
                        .fish-fact {
                            font-size: 11px;
                        }
                    }
                `;
                
                document.head.appendChild(style);
                
                // Close on background click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                        style.remove();
                    }
                });
            }

            addChatMessage(type, message) {
                const chatArea = document.getElementById('chat-area');
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${type}`;
                messageDiv.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                
                if (chatArea) {
                    chatArea.appendChild(messageDiv.cloneNode(true));
                    chatArea.scrollTop = chatArea.scrollHeight;
                }
            }

            sendMessage(message) {
                this.addChatMessage('own', message);
                // Show own message in banner too
                this.showChatBanner(`${this.player.name}: ${message}`);
                // Send to server for multiplayer
                if (this.socket && this.connected) {
                    this.socket.emit('chat-message', message);
                }
            }

            toggleTournament() {
                if (!this.tournament) {
                    this.startTournament();
                } else {
                    this.leaveTournament();
                }
            }

            startTournament() {
                this.tournament = {
                    active: true,
                    phase: 'joining',
                    participants: [this.player.name, ...this.otherPlayers.slice(0, 3).map(p => p.name)],
                    startTime: Date.now(),
                    duration: 5 * 60 * 1000, // 5 minutes
                    joinPeriod: 60 * 1000, // 60 seconds to join
                    scores: {},
                    tournamentId: Date.now().toString(),
                    catches: {} // Store individual catches for tournament
                };

                this.tournament.participants.forEach(name => {
                    this.tournament.scores[name] = {
                        totalWeight: 0,
                        fishCount: 0,
                        biggestCatch: 0
                    };
                    this.tournament.catches[name] = []; // Initialize catches array
                });

                this.updateTournamentDisplay();
                this.showGlobalAnnouncement('üê± KITTY CREEK TOURNAMENT STARTING! üé£', '#ffff00');
                this.addChatMessage('system', 'üê± TOURNAMENT STARTING! 60 seconds to join!');
                
                // Broadcast tournament start to all players
                if (this.socket && this.connected) {
                    this.socket.emit('tournament-start', {
                        tournamentId: this.tournament.tournamentId,
                        participants: this.tournament.participants,
                        elapsedTime: Date.now() - this.tournament.startTime
                    });
                }
                
                // Start countdown
                this.startTournamentCountdown();
            }

            startTournamentCountdown() {
                let countdown = 60;
                this.tournament.countdownInterval = setInterval(() => {
                    countdown--;
                    
                    // Update display with countdown
                    this.updateTournamentDisplay();
                    
                    if (countdown > 0 && countdown <= 10) {
                        // Show countdown for last 10 seconds
                        this.showGlobalAnnouncement(`üê± TOURNAMENT STARTS IN ${countdown} SECONDS! üé£`, '#ff00ff');
                        this.addChatMessage('system', `Tournament starts in ${countdown} seconds!`);
                        
                        // Broadcast countdown to all players
                        if (this.socket && this.connected) {
                            this.socket.emit('tournament-countdown', { seconds: countdown });
                        }
                    }
                    
                    if (countdown <= 0) {
                        clearInterval(this.tournament.countdownInterval);
                        this.startTournamentFishing();
                    }
                }, 1000);
            }

            startTournamentFishing() {
                this.tournament.phase = 'active';
                this.tournament.startTime = Date.now();
                this.updateTournamentDisplay();
                this.showGlobalAnnouncement('üé£ TOURNAMENT FISHING HAS BEGUN! üé£', '#00ff00');
                this.addChatMessage('system', 'üé£ TOURNAMENT FISHING HAS BEGUN! 5 minutes to catch the biggest fish!');
                this.addChatMessage('system', '‚öñÔ∏è Tournament Mode: Everyone has equal catch chances (equipment/stats disabled)!');
                this.addChatMessage('system', 'üêü TOURNAMENT FISH: Fish can be up to 3x bigger than normal! MEGA catches possible!');
                
                // Broadcast tournament start to all players
                if (this.socket && this.connected) {
                    this.socket.emit('tournament-active', {
                        tournamentId: this.tournament.tournamentId
                    });
                }
                
                // End tournament after duration
                setTimeout(() => {
                    this.endTournament();
                }, this.tournament.duration);
            }

            endTournament() {
                this.tournament.phase = 'ended';
                this.tournament.active = false;
                
                // Clear update intervals
                if (this.tournament.updateInterval) {
                    clearTimeout(this.tournament.updateInterval);
                }
                if (this.tournament.countdownInterval) {
                    clearInterval(this.tournament.countdownInterval);
                }
                
                // Calculate winner
                let winner = null;
                let highestWeight = 0;
                
                Object.entries(this.tournament.scores).forEach(([name, score]) => {
                    if (score.totalWeight > highestWeight) {
                        highestWeight = score.totalWeight;
                        winner = name;
                    }
                });
                
                // Award prize money to winner (only if playing against other real players)
                const realPlayerCount = this.tournament.participants.filter(name => 
                    !this.otherPlayers.find(p => p.name === name && p.isSimulated)
                ).length;
                
                if (winner && winner === this.player.name && realPlayerCount > 1) {
                    const prizeMoney = 500;
                    this.player.money += prizeMoney;
                    this.addChatMessage('system', `üèÜ Congratulations! You won $${prizeMoney} prize money!`);
                    this.showMessage(`üèÜ Tournament Win: +$${prizeMoney}!`, '#ffd700');
                    this.saveGameData();
                } else if (winner && winner === this.player.name && realPlayerCount === 1) {
                    this.addChatMessage('system', 'üí° No prize money - you were playing solo! Need other players for prizes.');
                }
                
                this.addChatMessage('system', 'üé£ Returning to normal fishing mode - your equipment and stats are active again!');
                
                // Broadcast tournament end to all players
                if (this.socket && this.connected) {
                    this.socket.emit('tournament-end', {
                        tournamentId: this.tournament.tournamentId,
                        winner: winner,
                        scores: this.tournament.scores,
                        catches: this.tournament.catches,
                        prizeAmount: realPlayerCount > 1 ? 500 : 0
                    });
                }
                
                // Show tournament results (broadcasts top 3)
                this.showTournamentResults();
                
                // Keep tournament results visible for 1 minute, then clear
                setTimeout(() => {
                    this.tournament = null;
                    this.updateTournamentDisplay();
                }, 60000); // 60 seconds
            }

            showTournamentResults() {
                // Calculate biggest bags (top 10 fish) for each player
                const playersWithBags = Object.entries(this.tournament.catches).map(([name, catches]) => {
                    const top10Fish = [...catches]
                        .sort((a, b) => b.weight - a.weight)
                        .slice(0, 10);
                    
                    const bagWeight = top10Fish.reduce((total, catchData) => total + catchData.weight, 0);
                    
                    return {
                        name: name,
                        bagWeight: bagWeight,
                        top10Fish: top10Fish,
                        biggestFish: this.tournament.scores[name].biggestCatch,
                        totalWeight: this.tournament.scores[name].totalWeight
                    };
                }).filter(player => player.bagWeight > 0);

                // Sort by total weight (tournament winner)
                const top3Players = playersWithBags
                    .sort((a, b) => b.totalWeight - a.totalWeight)
                    .slice(0, 3);
                
                // BROADCAST TOP 3 ON MAIN SCREEN
                if (top3Players.length > 0) {
                    let podiumText = '<div style="font-size: 18px; font-weight: bold; margin-bottom: 10px;">üèÜ TOURNAMENT RESULTS üèÜ</div>';
                    top3Players.forEach((player, index) => {
                        const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : 'ü•â';
                        podiumText += `<div style="font-size: 16px; margin: 5px 0;">${medal} ${player.name}: ${player.totalWeight.toFixed(2)} lbs</div>`;
                    });
                    
                    // Show as global announcement for 5 seconds
                    const announcement = document.createElement('div');
                    announcement.className = 'global-announcement';
                    announcement.innerHTML = `
                        <div class="announcement-content" style="color: #ffd700; border-color: #ffd700; box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); padding: 20px; text-align: center;">
                            ${podiumText}
                        </div>
                    `;
                    
                    const style = document.createElement('style');
                    style.textContent = `
                        .global-announcement {
                            position: fixed;
                            bottom: 120px;
                            left: 50%;
                            transform: translateX(-50%);
                            z-index: 10000;
                            animation: announcementSlideUp 0.6s ease-out;
                        }
                        
                        @keyframes announcementSlideUp {
                            from {
                                opacity: 0;
                                transform: translate(-50%, 20px);
                            }
                            to {
                                opacity: 1;
                                transform: translate(-50%, 0);
                            }
                        }
                    `;
                    
                    if (!document.getElementById('announcement-style')) {
                        style.id = 'announcement-style';
                        document.head.appendChild(style);
                    }
                    
                    document.body.appendChild(announcement);
                    
                    // Remove after 5 seconds
                    setTimeout(() => {
                        announcement.remove();
                    }, 5000);
                    
                    // Also show in chat
                    this.addChatMessage('system', `üèÜ Tournament Results:`);
                    top3Players.forEach((player, index) => {
                        const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : 'ü•â';
                        this.addChatMessage('system', `${medal} ${player.name}: ${player.totalWeight.toFixed(2)} lbs`);
                    });
                }

                // Sort by bag weight for modal display
                const biggestBags = playersWithBags
                    .sort((a, b) => b.bagWeight - a.bagWeight)
                    .slice(0, 3);

                // Sort by biggest single fish
                const topFish = playersWithBags
                    .sort((a, b) => b.biggestFish - a.biggestFish)
                    .slice(0, 3);

                // Show detailed results in chat
                this.addChatMessage('system', '==================== TOURNAMENT RESULTS ====================');
                
                // Biggest Bags (Top 10 Total Weight)
                this.addChatMessage('system', 'üèÜ BIGGEST BAGS (Top 10 Fish Total Weight):');
                if (biggestBags.length > 0) {
                    biggestBags.forEach((player, index) => {
                        const rank = index + 1;
                        const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : 'ü•â';
                        this.addChatMessage('system', `${medal} ${rank}. ${player.name}: ${player.bagWeight.toFixed(2)} lbs (${player.top10Fish.length} fish)`);
                    });
                } else {
                    this.addChatMessage('system', 'No catches recorded');
                }
                
                this.addChatMessage('system', '');
                
                // Top Fish Overall
                this.addChatMessage('system', 'üêü TOP FISH OVERALL:');
                if (topFish.length > 0) {
                    topFish.forEach((player, index) => {
                        const rank = index + 1;
                        const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : 'ü•â';
                        this.addChatMessage('system', `${medal} ${rank}. ${player.name}: ${player.biggestFish.toFixed(2)} lbs`);
                    });
                } else {
                    this.addChatMessage('system', 'No catches recorded');
                }
                
                this.addChatMessage('system', '============================================================');
            }

            leaveTournament() {
                this.tournament = null;
                this.updateTournamentDisplay();
                this.addChatMessage('system', 'Tournament ended.');
            }

            updateTournamentDisplay() {
                const container = document.getElementById('tournament-info');
                const mobileContainer = document.getElementById('mobile-tournament-stats');
                
                if (!this.tournament) {
                    const message = `
                        <div style="color: #888;">No Active Tournament</div>
                        <div style="font-size: 9px; color: #666; margin-top: 5px;">Join a tournament to compete!</div>
                    `;
                    if (container) container.innerHTML = `<h4>No Active Tournament</h4><div class="tournament-timer">Join a tournament to compete!</div>`;
                    if (mobileContainer) mobileContainer.innerHTML = message;
                    
                    // Hide mobile tournament banner
                    const mobileBanner = document.getElementById('mobile-tournament-banner');
                    if (mobileBanner) {
                        mobileBanner.style.display = 'none';
                    }
                    return;
                }

                // Show countdown during joining phase
                if (this.tournament.phase === 'joining') {
                    const countdownStart = this.tournament.startTime;
                    const countdownElapsed = Date.now() - countdownStart;
                    const countdown = Math.max(0, 60 - Math.floor(countdownElapsed / 1000));
                    
                    const desktopHtml = `
                        <h4>üê± TOURNAMENT STARTING</h4>
                        <div class="tournament-timer" style="font-size: 18px; font-weight: bold; color: #ffff00;">
                            Starts in: ${countdown} seconds
                        </div>
                        <div style="margin-top: 10px;">Participants: ${this.tournament.participants.length}</div>
                        <div style="margin-top: 5px; font-size: 12px; color: #64b5f6;">Get ready to fish!</div>
                    `;
                    
                    const mobileHtml = `
                        <div style="color: #ffff00; font-weight: bold; font-size: 12px;">üê± TOURNAMENT STARTING</div>
                        <div style="font-size: 16px; font-weight: bold; color: #ffff00; margin-top: 8px; padding: 8px; background: rgba(255,255,0,0.15); border-radius: 4px; text-align: center;">
                            ‚è±Ô∏è STARTS IN ${countdown}s
                        </div>
                        <div style="font-size: 10px; color: #aaa; margin-top: 8px;">üë• ${this.tournament.participants.length} participants ready</div>
                    `;
                    
                    if (container) container.innerHTML = desktopHtml;
                    if (mobileContainer) mobileContainer.innerHTML = mobileHtml;
                    
                    // Hide mobile tournament banner during countdown (show when active)
                    const mobileBanner = document.getElementById('mobile-tournament-banner');
                    if (mobileBanner) {
                        mobileBanner.style.display = 'none';
                    }
                    return;
                }

                // Show active tournament stats
                if (this.tournament.phase === 'active') {
                    const timeLeft = Math.max(0, this.tournament.duration - (Date.now() - this.tournament.startTime));
                    const minutes = Math.floor(timeLeft / 60000);
                    const seconds = Math.floor((timeLeft % 60000) / 1000);

                    // Find biggest fish caught so far
                    let biggestFish = 0;
                    let biggestFishPlayer = 'None';
                    Object.entries(this.tournament.scores).forEach(([name, score]) => {
                        if (score.biggestCatch > biggestFish) {
                            biggestFish = score.biggestCatch;
                            biggestFishPlayer = name;
                        }
                    });

                    // Calculate total fish caught
                    let totalFish = 0;
                    Object.values(this.tournament.scores).forEach(score => {
                        totalFish += score.fishCount;
                    });

                    const desktopHtml = `
                        <h4>üê± TOURNAMENT ACTIVE</h4>
                        <div class="tournament-timer" style="font-size: 16px; font-weight: bold; color: #00ff00;">
                            Time: ${minutes}:${seconds.toString().padStart(2, '0')}
                        </div>
                        <div style="margin-top: 10px;">
                            <div style="font-size: 12px; color: #ffff00;">üêü Biggest Fish:</div>
                            <div style="font-size: 11px; color: #64b5f6; margin-left: 10px;">
                                ${biggestFishPlayer}: ${biggestFish.toFixed(1)} lbs
                            </div>
                        </div>
                        <div style="margin-top: 8px;">
                            <div style="font-size: 12px; color: #ffff00;">üë• Participants:</div>
                            <div style="font-size: 11px; color: #64b5f6; margin-left: 10px;">
                                ${this.tournament.participants.length} players | ${totalFish} fish caught
                            </div>
                        </div>
                    `;
                    
                    const mobileHtml = `
                        <div style="color: #00ff00; font-weight: bold; font-size: 12px;">üê± TOURNAMENT ACTIVE</div>
                        <div style="font-size: 14px; font-weight: bold; color: #ffff00; margin-top: 8px; padding: 5px; background: rgba(0,255,0,0.1); border-radius: 4px; text-align: center;">
                            ‚è±Ô∏è ${minutes}:${seconds.toString().padStart(2, '0')} LEFT
                        </div>
                        <div style="font-size: 10px; color: #aaa; margin-top: 8px;">üêü Biggest: ${biggestFishPlayer} (${biggestFish.toFixed(1)} lbs)</div>
                        <div style="font-size: 10px; color: #aaa; margin-top: 3px;">üë• ${this.tournament.participants.length} players | ${totalFish} fish</div>
                    `;
                    
                    if (container) container.innerHTML = desktopHtml;
                    if (mobileContainer) mobileContainer.innerHTML = mobileHtml;
                    
                    // Show and update mobile tournament banner
                    const mobileBanner = document.getElementById('mobile-tournament-banner');
                    const mobileTimer = document.getElementById('mobile-tournament-timer');
                    if (mobileBanner && mobileTimer) {
                        mobileBanner.style.display = 'block';
                        mobileTimer.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                    
                    // Update every second during active phase
                    if (this.tournament.updateInterval) {
                        clearInterval(this.tournament.updateInterval);
                    }
                    this.tournament.updateInterval = setTimeout(() => {
                        if (this.tournament && this.tournament.phase === 'active') {
                            this.updateTournamentDisplay();
                        }
                    }, 1000);
                    return;
                }

                // Show ended tournament
                if (this.tournament.phase === 'ended') {
                    container.innerHTML = `
                        <h4>üèÜ TOURNAMENT ENDED</h4>
                        <div class="tournament-timer">Check results below!</div>
                    `;
                }
            }

            openHelp() {
                const modal = document.getElementById('help-modal');
                if (modal) modal.style.display = 'block';
            }

            closeHelp() {
                const modal = document.getElementById('help-modal');
                if (modal) modal.style.display = 'none';
            }

            openShop() {
                document.getElementById('tackle-shop-modal').style.display = 'block';
                this.switchShopTab('rods'); // Start with rods tab
            }

            closeShop() {
                document.getElementById('tackle-shop-modal').style.display = 'none';
            }

            switchShopTab(tabName) {
                // Update tab buttons (only shop tabs)
                document.querySelectorAll('#tackle-shop-modal .tab-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.tab === tabName);
                });

                // Update content
                this.renderShopContent(tabName);
            }

            renderShopContent(tabName) {
                const content = document.getElementById('shop-content');
                
                // Only handle tackle shop tabs
                const validTabs = ['rods', 'reels', 'lines', 'hooks', 'baits'];
                if (!validTabs.includes(tabName)) {
                    return; // Not a tackle shop tab, ignore
                }
                
                const tackle = this.tackle[tabName];
                
                content.innerHTML = '';
                
                // Safety check for tackle array
                if (!tackle || !Array.isArray(tackle)) {
                    content.innerHTML = '<p style="color: #ff0000;">Error loading tackle items. Please refresh the page.</p>';
                    console.error('Tackle not found for tab:', tabName, 'Available:', Object.keys(this.tackle));
                    return;
                }
                
                tackle.forEach((item, index) => {
                    const isUnlocked = this.player.tackleUnlocks[tabName].includes(index);
                    const isOwned = this.player.gear[tabName.toLowerCase()] === item.name;
                    const canAfford = this.player.money >= item.cost;
                    
                    const itemDiv = document.createElement('div');
                    itemDiv.className = `tackle-item ${isOwned ? 'equipped' : ''} ${!isUnlocked ? 'locked' : ''}`;
                    
                    let statsText = '';
                    if (tabName === 'rods') {
                        statsText = `+${item.catchBonus}% catch, ${item.strength} strength`;
                    } else if (tabName === 'reels') {
                        statsText = `+${item.speedBonus}% speed, ${item.smoothness} smoothness`;
                    } else if (tabName === 'lines') {
                        statsText = `${item.strength} strength, ${item.visibility} visibility`;
                    } else if (tabName === 'hooks') {
                        statsText = `+${item.catchBonus}% catch, size ${item.size}`;
                    } else if (tabName === 'baits') {
                        statsText = `+${item.catchBonus}% catch, ${item.durability} durability`;
                    }
                    
                    itemDiv.innerHTML = `
                        <div class="tackle-info">
                            <div class="tackle-name">${item.name}</div>
                            <div class="tackle-stats">${statsText}</div>
                            <div class="tackle-description">${item.description}</div>
                        </div>
                        <div class="tackle-actions">
                            ${!isUnlocked ? 
                                `<div style="color: #666; font-size: 12px;">Locked - Level ${item.unlockLevel}</div>` :
                                isOwned ? 
                                    `<div style="color: #ffff00; font-size: 12px;">EQUIPPED</div>` :
                                    canAfford ?
                                        `<button class="tackle-btn buy" data-action="buy" data-category="${tabName}" data-index="${index}">BUY $${item.cost}</button>` :
                                        `<div style="color: #ff6666; font-size: 12px;">Need $${item.cost}</div>`
                            }
                            ${isOwned && !isUnlocked ? '' : isOwned ? '' : isUnlocked && this.player.gear[tabName.toLowerCase()] !== item.name ? 
                                `<button class="tackle-btn equip" data-action="equip" data-category="${tabName}" data-index="${index}">EQUIP</button>` : ''
                            }
                        </div>
                    `;
                    
                    content.appendChild(itemDiv);
                });
            }

            buyTackle(category, index) {
                const item = this.tackle[category][index];
                
                if (this.player.money < item.cost) {
                    this.showMessage('Not enough money!', '#ff0000');
                    return;
                }
                
                this.player.money -= item.cost;
                this.player.gear[category.toLowerCase()] = item.name;
                
                // Random funny purchase messages
                const purchaseMessages = [
                    `Nice! ${item.name} purchased! Fish will fear you now! üêü`,
                    `PURCHASED: ${item.name}! You're ready to cat-ch some fish! üê±`,
                    `Money well spent! You just got ${item.name}! Time to dominate! üí™`,
                    `CHA-CHING! ${item.name} is yours! Go get 'em, tiger! üêÖ`,
                    `Meeeow! ${item.name} acquired! The fish don't stand a chance! üé£`,
                    `Shut up and take my money! ${item.name} purchased! üí∏`,
                    `That ${item.name} cost you a pretty penny, but it's worth it! üí∞`
                ];
                const randomPurchaseMsg = purchaseMessages[Math.floor(Math.random() * purchaseMessages.length)];
                
                this.showMessage(randomPurchaseMsg, '#00ff00');
                this.addChatMessage('system', `${this.player.name} bought ${item.name}! üõí`);
                
                this.updateDisplay();
                this.renderShopContent(category);
                this.saveGameData();
            }

            equipTackle(category, index) {
                const item = this.tackle[category][index];
                this.player.gear[category.toLowerCase()] = item.name;
                
                this.showMessage(`Equipped ${item.name}!`, '#00ff00');
                this.addChatMessage('system', `${this.player.name} equipped ${item.name}!`);
                
                this.updateDisplay();
                this.renderShopContent(category);
                this.saveGameData();
            }

            openInventory() {
                document.getElementById('inventory-modal').style.display = 'block';
                // Refresh gear display to ensure current values are shown
                const currentTab = document.querySelector('.inventory-tabs .tab-btn.active')?.dataset.tab || 'recent';
                this.switchInventoryTab(currentTab);
            }

            closeInventory() {
                document.getElementById('inventory-modal').style.display = 'none';
            }

            switchInventoryTab(tabName) {
                // Update tab buttons
                document.querySelectorAll('.inventory-tabs .tab-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.tab === tabName) {
                        btn.classList.add('active');
                    }
                });

                // Render content
                this.renderInventoryContent(tabName);
            }

            renderInventoryContent(tabName) {
                const content = document.getElementById('inventory-content');
                
                switch(tabName) {
                    case 'recent':
                        this.renderRecentCatches(content);
                        break;
                    case 'top10':
                    case 'biggest':
                        this.renderBiggestFish(content);
                        break;
                    case 'gear':
                        this.renderEquippedGear(content);
                        break;
                    case 'stats':
                        this.renderStatistics(content);
                        break;
                    default:
                        // Default to recent catches if unknown tab
                        this.renderRecentCatches(content);
                        break;
                }
            }

            renderRecentCatches(container) {
                if (this.player.recentCatches.length === 0) {
                    container.innerHTML = '<div class="no-data">No fish caught yet!</div>';
                    return;
                }

                const html = this.player.recentCatches.slice(-10).reverse().map(catchData => `
                    <div class="catch-item">
                        <div class="fish-name">${catchData.fish.name}</div>
                        <div class="fish-details">
                            <span class="weight">${catchData.weight.toFixed(1)} lbs</span>
                            <span class="value">$${catchData.value}</span>
                            <span class="location">${catchData.location}</span>
                            <span class="time">${new Date(catchData.timestamp).toLocaleTimeString()}</span>
                        </div>
                    </div>
                `).join('');

                container.innerHTML = html;
            }

            renderBiggestFish(container) {
                const biggestFish = this.player.recentCatches
                    .sort((a, b) => b.weight - a.weight)
                    .slice(0, 10);

                if (biggestFish.length === 0) {
                    container.innerHTML = '<div class="no-data">No fish caught yet!</div>';
                    return;
                }

                const html = biggestFish.map((catchData, index) => `
                    <div class="catch-item">
                        <div class="rank">#${index + 1}</div>
                        <div class="fish-name">${catchData.fish.name}</div>
                        <div class="fish-details">
                            <span class="weight">${catchData.weight.toFixed(1)} lbs</span>
                            <span class="value">$${catchData.value}</span>
                            <span class="location">${catchData.location}</span>
                        </div>
                    </div>
                `).join('');

                container.innerHTML = html;
            }

            renderStatistics(container) {
                const stats = {
                    totalFish: this.player.totalCaught,
                    totalWeight: this.player.totalWeight.toFixed(1),
                    biggestCatch: this.player.biggestCatch.toFixed(1),
                    totalMoney: this.player.money,
                    level: this.player.level,
                    experience: this.player.experience,
                    tournamentsPlayed: this.player.tournamentStats.tournamentsPlayed,
                    tournamentsWon: this.player.tournamentStats.tournamentsWon
                };

                const html = `
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-label">Total Fish</div>
                            <div class="stat-value">${stats.totalFish}</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Total Weight</div>
                            <div class="stat-value">${stats.totalWeight} lbs</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Biggest Catch</div>
                            <div class="stat-value">${stats.biggestCatch} lbs</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Total Money</div>
                            <div class="stat-value">$${stats.totalMoney}</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Level</div>
                            <div class="stat-value">${stats.level}</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Experience</div>
                            <div class="stat-value">${stats.experience}</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Tournaments Played</div>
                            <div class="stat-value">${stats.tournamentsPlayed}</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Tournaments Won</div>
                            <div class="stat-value">${stats.tournamentsWon}</div>
                        </div>
                    </div>
                `;

                container.innerHTML = html;
            }

            renderEquippedGear(container) {
                // Get actual equipped gear - check both singular and plural keys for compatibility
                const rod = this.player.gear?.rods || this.player.gear?.rod || 'None';
                const reel = this.player.gear?.reels || this.player.gear?.reel || 'None';
                const line = this.player.gear?.lines || this.player.gear?.line || 'None';
                const hook = this.player.gear?.hooks || this.player.gear?.hook || 'None';
                const bait = this.player.gear?.baits || this.player.gear?.bait || 'None';
                
                const html = `
                    <div style="padding: 20px;">
                        <div style="margin-bottom: 15px; padding: 12px; background: rgba(20, 30, 50, 0.6); border-radius: 8px; border-left: 4px solid rgba(100, 200, 255, 0.5);">
                            <div style="font-weight: bold; color: #64b5f6; margin-bottom: 5px;">üé£ Rod</div>
                            <div style="color: #ffffff; font-size: 14px;">${rod}</div>
                        </div>
                        <div style="margin-bottom: 15px; padding: 12px; background: rgba(20, 30, 50, 0.6); border-radius: 8px; border-left: 4px solid rgba(100, 200, 255, 0.5);">
                            <div style="font-weight: bold; color: #64b5f6; margin-bottom: 5px;">üé£ Reel</div>
                            <div style="color: #ffffff; font-size: 14px;">${reel}</div>
                        </div>
                        <div style="margin-bottom: 15px; padding: 12px; background: rgba(20, 30, 50, 0.6); border-radius: 8px; border-left: 4px solid rgba(100, 200, 255, 0.5);">
                            <div style="font-weight: bold; color: #64b5f6; margin-bottom: 5px;">ü™ù Line</div>
                            <div style="color: #ffffff; font-size: 14px;">${line}</div>
                        </div>
                        <div style="margin-bottom: 15px; padding: 12px; background: rgba(20, 30, 50, 0.6); border-radius: 8px; border-left: 4px solid rgba(100, 200, 255, 0.5);">
                            <div style="font-weight: bold; color: #64b5f6; margin-bottom: 5px;">ü™ù Hook</div>
                            <div style="color: #ffffff; font-size: 14px;">${hook}</div>
                        </div>
                        <div style="padding: 12px; background: rgba(20, 30, 50, 0.6); border-radius: 8px; border-left: 4px solid rgba(100, 200, 255, 0.5);">
                            <div style="font-weight: bold; color: #64b5f6; margin-bottom: 5px;">üêõ Bait</div>
                            <div style="color: #ffffff; font-size: 14px;">${bait}</div>
                        </div>
                    </div>
                `;
                
                container.innerHTML = html;
            }

            renderFishCollection() {
                const collectionGrid = document.getElementById('fish-collection-grid');
                if (!collectionGrid) return;
                
                // Group fish by rarity
                const fishByRarity = {
                    'Common': [],
                    'Uncommon': [],
                    'Rare': [],
                    'Epic': [],
                    'Legendary': [],
                    'Trophy': []
                };
                
                // Group all fish by rarity
                this.fishTypes.forEach((fish, index) => {
                    const rarity = fish.rarity || 'Common';
                    if (fishByRarity[rarity]) {
                        fishByRarity[rarity].push({ ...fish, index });
                    }
                });
                
                let html = '';
                
                // Render each rarity group
                Object.entries(fishByRarity).forEach(([rarity, fishList]) => {
                    if (fishList.length === 0) return;
                    
                    html += `<div style="grid-column: 1 / -1; margin-top: 10px; margin-bottom: 5px; color: #64b5f6; font-weight: bold; font-size: 12px;">${rarity}</div>`;
                    
                    fishList.forEach(fish => {
                        const isCaught = this.player.caughtFish && this.player.caughtFish[fish.name];
                        const opacity = isCaught ? '1' : '0.3';
                        const clickable = isCaught ? 'cursor: pointer; transition: transform 0.2s;' : '';
                        
                        html += `
                            <div data-fish-name="${fish.name}" style="text-align: center; padding: 8px; background: rgba(15, 25, 40, 0.5); border-radius: 8px; opacity: ${opacity}; ${clickable}" ${isCaught ? 'onclick="game.showFishInfo(\'' + fish.name + '\')"' : ''}>
                                <img src="images/${fish.name}.png" 
                                     alt="${fish.name}" 
                                     onerror="this.src='data:image/svg+xml,%3Csvg xmlns=\\'http://www.w3.org/2000/svg\\' viewBox=\\'0 0 100 100\\'%3E%3Ctext y=\\'.9em\\' font-size=\\'60\\'%3Eüêü%3C/text%3E%3C/svg%3E';"
                                     style="width: 100%; aspect-ratio: 1; object-fit: contain;">
                                <div style="font-size: 9px; color: #64b5f6; margin-top: 4px; word-break: break-word;">${fish.name}</div>
                                ${!isCaught ? '<div style="font-size: 8px; color: #888;">???</div>' : ''}
                            </div>
                        `;
                    });
                });
                
                if (html === '') {
                    html = '<div style="grid-column: 1 / -1; text-align: center; color: #888; padding: 20px;">Start fishing to build your collection!</div>';
                }
                
                collectionGrid.innerHTML = html;
            }

            renderDesktopCollection() {
                const container = document.getElementById('desktop-fish-collection');
                if (!container) return;
                
                // Reuse the renderFishCollection logic but with different styling
                const fishByRarity = {
                    'Common': [], 'Uncommon': [], 'Rare': [], 'Epic': [], 'Legendary': [], 'Trophy': []
                };
                
                this.fishTypes.forEach((fish, index) => {
                    const rarity = fish.rarity || 'Common';
                    if (fishByRarity[rarity]) {
                        fishByRarity[rarity].push({ ...fish, index });
                    }
                });
                
                let html = '';
                Object.entries(fishByRarity).forEach(([rarity, fishList]) => {
                    if (fishList.length === 0) return;
                    html += `<div style="font-weight: bold; color: #64b5f6; margin: 10px 0 5px 0; font-size: 12px;">${rarity}</div>`;
                    html += `<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 10px;">`;
                    fishList.forEach(fish => {
                        const isCaught = this.player.caughtFish && this.player.caughtFish[fish.name];
                        const clickable = isCaught ? 'cursor: pointer; transition: transform 0.2s;' : '';
                        html += `
                            <div data-fish-name="${fish.name}" style="text-align: center; padding: 6px; background: rgba(15, 25, 40, 0.5); border-radius: 6px; opacity: ${isCaught ? '1' : '0.3'}; ${clickable}" ${isCaught ? 'onclick="game.showFishInfo(\'' + fish.name + '\')"' : ''}>
                                <img src="images/${fish.name}.png" alt="${fish.name}" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=\\'http://www.w3.org/2000/svg\\' viewBox=\\'0 0 100 100\\'%3E%3Ctext y=\\'.9em\\' font-size=\\'60\\'%3Eüêü%3C/text%3E%3C/svg%3E';" style="width: 100%; aspect-ratio: 1; object-fit: contain;">
                                <div style="font-size: 8px; color: #64b5f6; margin-top: 2px;">${fish.name}</div>
                            </div>
                        `;
                    });
                    html += `</div>`;
                });
                
                container.innerHTML = html || '<div style="text-align: center; color: #888; padding: 20px;">Start fishing!</div>';
            }

            renderDesktopStats() {
                const container = document.getElementById('desktop-stats-display');
                if (!container) return;
                container.innerHTML = `
                    <div style="color: #64b5f6; font-size: 11px;">
                        <div style="margin: 5px 0;">Accuracy: <span style="color: #fff;">${this.player.stats.accuracy}/100</span></div>
                        <div style="margin: 5px 0;">Luck: <span style="color: #fff;">${this.player.stats.luck}/100</span></div>
                        <div style="margin: 5px 0;">Patience: <span style="color: #fff;">${this.player.stats.patience}/100</span></div>
                        <div style="margin: 5px 0;">Strength: <span style="color: #fff;">${this.player.stats.strength}/100</span></div>
                    </div>
                `;
            }

            renderDesktopRecent() {
                const container = document.getElementById('desktop-recent-display');
                if (!container) return;
                const html = this.player.recentCatches.slice(-10).reverse().map(c => `
                    <div style="font-size: 10px; color: #64b5f6; margin: 5px 0; padding: 5px; background: rgba(15, 25, 40, 0.5); border-radius: 4px;">
                        ${c.fish.name} - ${c.weight.toFixed(1)}lbs - $${c.value}
                    </div>
                `).join('');
                container.innerHTML = html || '<div style="color: #888; padding: 10px;">No recent catches</div>';
            }

            showMessage(text, color) {
                const messageEl = document.getElementById('catch-text');
                const messageContainer = document.getElementById('catch-message');
                
                if (!messageEl || !messageContainer) {
                    console.error('Catch message elements not found!', { messageEl, messageContainer });
                    return;
                }
                
                // Clear any existing timeouts to prevent conflicts
                if (this.messageTimeout) {
                    clearTimeout(this.messageTimeout);
                }
                if (this.messageHideTimeout) {
                    clearTimeout(this.messageHideTimeout);
                }
                
                messageEl.textContent = text;
                messageEl.style.color = color;
                
                // Force visibility - remove any conflicting classes first
                messageContainer.classList.remove('show');
                messageContainer.style.display = 'none';
                
                // Force a reflow to ensure styles are applied
                void messageContainer.offsetHeight;
                
                // Now show the message
                messageContainer.style.display = 'block';
                messageContainer.style.visibility = 'visible';
                messageContainer.style.opacity = '1';
                messageContainer.style.zIndex = '10000';
                messageContainer.classList.add('show');
                
                // Hide after 3 seconds
                this.messageTimeout = setTimeout(() => {
                    messageContainer.classList.remove('show');
                    this.messageHideTimeout = setTimeout(() => {
                        messageContainer.style.display = 'none';
                    }, 500);
                }, 3000);
            }

            showChatBanner(message) {
                // Use the same announcement system as big fish catches
                this.showGlobalAnnouncement(message, '#64b5f6');
            }

            showChatBubble(playerIndex, message) {
                const player = this.otherPlayers[playerIndex - 1];
                if (!player) return;
                
                // On mobile, show in ticker at bottom of lake
                if (window.innerWidth <= 768) {
                    const ticker = document.getElementById('bot-cat-ticker');
                    if (!ticker) {
                        // Create ticker if it doesn't exist
                        const tickerDiv = document.createElement('div');
                        tickerDiv.id = 'bot-cat-ticker';
                        tickerDiv.className = 'bot-cat-ticker';
                        tickerDiv.innerHTML = '<div class="ticker-content"></div>';
                        document.body.appendChild(tickerDiv);
                        
                        // Add CSS for ticker
                        const style = document.createElement('style');
                        style.id = 'bot-cat-ticker-styles';
                        style.textContent = `
                            .bot-cat-ticker {
                                position: fixed;
                                bottom: 60px;
                                left: 50%;
                                transform: translateX(-50%);
                                width: 90%;
                                max-width: 500px;
                                background: linear-gradient(135deg, rgba(15, 25, 40, 0.95), rgba(25, 35, 50, 0.95));
                                border: 2px solid #00ffff;
                                border-radius: 10px;
                                padding: 8px 15px;
                                z-index: 999;
                                box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
                            }
                            .ticker-content {
                                color: #64b5f6;
                                font-size: 11px;
                                text-align: center;
                                font-weight: bold;
                            }
                            @media (min-width: 769px) {
                                .bot-cat-ticker { display: none; }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                    
                    const tickerContent = document.querySelector('#bot-cat-ticker .ticker-content');
                    if (tickerContent) {
                        tickerContent.textContent = `${player.name}: ${message}`;
                        tickerContent.style.animation = 'none';
                        setTimeout(() => tickerContent.style.animation = 'fadeInOut 0.3s', 10);
                    }
                    return;
                }
                
                // On desktop, show bubble above fisherman
                const existing = document.querySelectorAll(`.bot-chat-bubble[data-player-index="${playerIndex}"]`);
                existing.forEach(el => el.remove());
                
                const fishermen = document.querySelectorAll('.fisherman');
                if (!fishermen[playerIndex]) return;
                
                const fisher = fishermen[playerIndex];
                const fisherRect = fisher.getBoundingClientRect();
                
                const bubble = document.createElement('div');
                bubble.className = 'bot-chat-bubble';
                bubble.setAttribute('data-player-index', playerIndex);
                bubble.textContent = message;
                
                bubble.style.position = 'fixed';
                bubble.style.left = (fisherRect.left + fisherRect.width / 2) + 'px';
                bubble.style.bottom = (window.innerHeight - fisherRect.top + 10) + 'px';
                bubble.style.transform = 'translateX(-50%)';
                bubble.style.zIndex = '1000';
                
                document.body.appendChild(bubble);
                
                setTimeout(() => {
                    if (bubble.parentElement) {
                        bubble.style.opacity = '0';
                        bubble.style.transform = 'translateX(-50%) translateY(-10px)';
                        setTimeout(() => bubble.remove(), 300);
                    }
                }, 3000);
                
                if (!document.getElementById('bot-chat-bubble-styles')) {
                    const style = document.createElement('style');
                    style.id = 'bot-chat-bubble-styles';
                    style.textContent = `
                        .bot-chat-bubble {
                            background: rgba(15, 25, 40, 0.95);
                            border: 2px solid #00ffff;
                            border-radius: 15px;
                            padding: 8px 15px;
                            color: #ffffff;
                            font-size: 12px;
                            max-width: 200px;
                            word-wrap: break-word;
                            text-align: center;
                            box-shadow: 0 2px 10px rgba(0, 255, 255, 0.3);
                            animation: chatBubbleSlideUp 0.3s ease-out;
                        }
                        @keyframes chatBubbleSlideUp {
                            from { opacity: 0; transform: translateX(-50%) translateY(10px); }
                            to { opacity: 1; transform: translateX(-50%) translateY(0); }
                        }
                        .bot-chat-bubble::before {
                            content: '';
                            position: absolute;
                            bottom: -8px;
                            left: 50%;
                            transform: translateX(-50%);
                            width: 0;
                            height: 0;
                            border-left: 8px solid transparent;
                            border-right: 8px solid transparent;
                            border-top: 8px solid #00ffff;
                        }
                        @keyframes fadeInOut {
                            from { opacity: 0; }
                            to { opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                }
            }

            handleAdClick(location) {
                // Mock ad click handler for testing
                const adMessages = {
                    'desktop-bottom': 'üé£ Desktop Ad Clicked! Premium Fishing Gear Sale - 50% Off!',
                    'mobile-bottom': 'üê± Mobile Ad Clicked! Upgrade Your Gear Now!'
                };
                
                this.showMessage(adMessages[location] || 'Ad clicked!', '#ffd700');
                this.addChatMessage('system', `Mock ad clicked at ${location} - Testing ad functionality`);
                
                // In production, this would track the ad click and redirect to advertiser
                console.log(`Ad clicked at: ${location}`);
            }

            initMockAds() {
                // Array of realistic mock banner ads to rotate through
                this.mockAds = {
                    desktop: [
                        {
                            bg: 'linear-gradient(135deg, #1e88e5, #1976d2)',
                            logo: 'üé£',
                            headline: 'Premium Fishing Gear',
                            subtext: 'Best Rods & Reels ‚Ä¢ 50% Off Sale',
                            cta: 'Shop Now ‚Üí'
                        },
                        {
                            bg: 'linear-gradient(135deg, #f57c00, #e65100)',
                            logo: 'üêü',
                            headline: 'Fishing Tackle Warehouse',
                            subtext: 'Free Shipping on Orders $50+',
                            cta: 'Buy Now ‚Üí'
                        },
                        {
                            bg: 'linear-gradient(135deg, #7b1fa2, #6a1b9a)',
                            logo: '‚öì',
                            headline: 'Marine Supply Co',
                            subtext: 'Professional Equipment ‚Ä¢ Best Prices',
                            cta: 'Learn More ‚Üí'
                        },
                        {
                            bg: 'linear-gradient(135deg, #00897b, #00695c)',
                            logo: 'üé£',
                            headline: 'Tackle Pro Shop',
                            subtext: 'Elite Gear for Serious Anglers',
                            cta: 'Explore ‚Üí'
                        },
                        {
                            bg: 'linear-gradient(135deg, #42a5f5, #2196f3)',
                            logo: 'üê±',
                            headline: 'Kitty Creek Pro Shop',
                            subtext: 'Exclusive Fisher-Cat Equipment',
                            cta: 'Upgrade ‚Üí'
                        }
                    ],
                    mobile: [
                        {
                            bg: 'linear-gradient(135deg, #1e88e5, #1976d2)',
                            text: 'üé£ Premium Gear ‚Ä¢ 50% Off',
                            cta: 'Shop ‚Üí'
                        },
                        {
                            bg: 'linear-gradient(135deg, #f57c00, #e65100)',
                            text: 'üêü Tackle Sale ‚Ä¢ Free Shipping',
                            cta: 'Buy ‚Üí'
                        },
                        {
                            bg: 'linear-gradient(135deg, #7b1fa2, #6a1b9a)',
                            text: '‚öì Pro Equipment ‚Ä¢ Best Deals',
                            cta: 'Tap ‚Üí'
                        },
                        {
                            bg: 'linear-gradient(135deg, #42a5f5, #2196f3)',
                            text: 'üê± Kitty Creek Shop ‚Ä¢ Upgrades',
                            cta: 'Tap ‚Üí'
                        }
                    ]
                };

                // Update ads every 10 seconds
                this.rotateAds();
                setInterval(() => {
                    this.rotateAds();
                }, 10000); // Change every 10 seconds
            }

            rotateAds() {
                // Rotate desktop ad (728x90 standard banner)
                const desktopAd = document.getElementById('desktop-ad-bottom');
                if (desktopAd) {
                    const ad = this.mockAds.desktop[Math.floor(Math.random() * this.mockAds.desktop.length)];
                    desktopAd.innerHTML = `
                        <a href="#" class="mock-ad" onclick="event.preventDefault(); game.handleAdClick('desktop-bottom'); return false;" style="display: block; text-decoration: none; color: inherit; width: 100%; height: 100%; min-height: 90px;">
                            <div style="background: ${ad.bg}; border-radius: 6px; padding: 12px 20px; display: flex; align-items: center; justify-content: space-between; height: 100%; min-height: 90px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">
                                <div style="display: flex; align-items: center; gap: 15px; flex: 1;">
                                    <div style="font-size: 36px; line-height: 1;">${ad.logo}</div>
                                    <div style="color: white;">
                                        <div style="font-size: 18px; font-weight: bold; margin-bottom: 4px; text-shadow: 0 1px 3px rgba(0,0,0,0.3);">${ad.headline}</div>
                                        <div style="font-size: 13px; opacity: 0.95;">${ad.subtext}</div>
                                    </div>
                                </div>
                                <div style="background: rgba(255,255,255,0.25); color: white; padding: 8px 20px; border-radius: 20px; font-weight: bold; font-size: 14px; white-space: nowrap; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.3);">
                                    ${ad.cta}
                                </div>
                            </div>
                        </a>
                    `;
                }

                // Rotate mobile ad (320x50 standard mobile banner)
                const mobileAd = document.getElementById('mobile-ad-bottom');
                if (mobileAd) {
                    const ad = this.mockAds.mobile[Math.floor(Math.random() * this.mockAds.mobile.length)];
                    mobileAd.innerHTML = `
                        <a href="#" class="mock-ad" onclick="event.preventDefault(); game.handleAdClick('mobile-bottom'); return false;" style="display: block; text-decoration: none; color: inherit; width: 100%; height: 50px;">
                            <div style="background: ${ad.bg}; border-radius: 6px; padding: 0 12px; display: flex; align-items: center; justify-content: space-between; height: 50px; max-height: 50px; box-shadow: 0 2px 6px rgba(0,0,0,0.3); overflow: hidden; position: relative; top: 0;">
                                <div style="display: flex; align-items: center; gap: 8px; flex: 1; color: white; height: 50px; line-height: 50px;">
                                    <div style="font-size: 18px; line-height: 50px; vertical-align: middle;">${ad.text.split('‚Ä¢')[0]}</div>
                                    <div style="font-size: 10px; opacity: 0.9; line-height: 50px; vertical-align: middle;">${ad.text.split('‚Ä¢')[1] || ''}</div>
                                </div>
                                <div style="background: rgba(255,255,255,0.25); color: white; padding: 4px 10px; border-radius: 12px; font-weight: bold; font-size: 10px; white-space: nowrap; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.3); flex-shrink: 0; line-height: 20px; height: 24px; display: flex; align-items: center;">
                                    ${ad.cta}
                                </div>
                            </div>
                        </a>
                    `;
                }
            }


            showCatchAnimation(fishName, weight) {
                const fishermanRow = document.getElementById('fisherman-row');
                const playerFisher = document.getElementById('player-fisher');
                
                if (!playerFisher) return;
                
                const fishIcon = document.createElement('div');
                fishIcon.className = 'fish-catch-animation';
                fishIcon.textContent = 'üêü';
                fishIcon.style.position = 'absolute';
                fishIcon.style.left = (playerFisher.getBoundingClientRect().left - fishermanRow.getBoundingClientRect().left) + 'px';
                fishIcon.style.top = (playerFisher.getBoundingClientRect().top - fishermanRow.getBoundingClientRect().top) + 'px';
                fishIcon.style.fontSize = '24px';
                fishIcon.style.zIndex = '1000';
                fishIcon.style.pointerEvents = 'none';
                
                fishermanRow.appendChild(fishIcon);
                
                // Animate the fish icon
                setTimeout(() => {
                    fishIcon.style.transition = 'all 1s ease-out';
                    fishIcon.style.transform = 'translateY(-50px) scale(1.5)';
                    fishIcon.style.opacity = '0';
                    
                    setTimeout(() => {
                        fishIcon.remove();
                    }, 1000);
                }, 50);
            }

            updateDisplay() {
                document.getElementById('player-name').textContent = this.player.name;
                document.getElementById('player-level').textContent = this.player.level;
                document.getElementById('player-money').textContent = this.player.money;
                document.getElementById('fish-caught').textContent = this.player.totalCaught;
                document.getElementById('total-weight').textContent = this.player.totalWeight.toFixed(1);

                // Update experience display
                // Calculate expNeeded based on current level (same logic as checkLevelUp)
                const expNeeded = this.calculateExpForLevel(this.player.level);
                document.getElementById('player-exp').textContent = this.player.experience;
                document.getElementById('next-level-exp').textContent = expNeeded;

                // Update player stats
                document.getElementById('stat-accuracy').textContent = this.player.stats.accuracy;
                document.getElementById('stat-luck').textContent = this.player.stats.luck;
                document.getElementById('stat-patience').textContent = this.player.stats.patience;
                document.getElementById('stat-strength').textContent = this.player.stats.strength;

                // Update mobile layout elements
                const mobilePlayerName = document.getElementById('mobile-player-name');
                const mobilePlayerLevel = document.getElementById('mobile-player-level');
                const mobilePlayerMoney = document.getElementById('mobile-player-money');
                const mobilePlayerExp = document.getElementById('mobile-player-exp');
                const mobileNextExp = document.getElementById('mobile-next-exp');
                const mobileFishCount = document.getElementById('mobile-fish-count');
                const mobileTotalWeight = document.getElementById('mobile-total-weight');
                const mobileStatAccuracy = document.getElementById('mobile-stat-accuracy');
                const mobileStatLuck = document.getElementById('mobile-stat-luck');
                const mobileStatPatience = document.getElementById('mobile-stat-patience');
                const mobileStatStrength = document.getElementById('mobile-stat-strength');

                if (mobilePlayerName) mobilePlayerName.textContent = this.player.name;
                if (mobilePlayerLevel) mobilePlayerLevel.textContent = this.player.level;
                if (mobilePlayerMoney) mobilePlayerMoney.textContent = this.player.money;
                if (mobilePlayerExp) mobilePlayerExp.textContent = this.player.experience;
                if (mobileNextExp) mobileNextExp.textContent = expNeeded;
                if (mobileFishCount) mobileFishCount.textContent = this.player.totalCaught;
                if (mobileTotalWeight) mobileTotalWeight.textContent = this.player.totalWeight.toFixed(1);
                if (mobileStatAccuracy) mobileStatAccuracy.textContent = this.player.stats.accuracy;
                if (mobileStatLuck) mobileStatLuck.textContent = this.player.stats.luck;
                if (mobileStatPatience) mobileStatPatience.textContent = this.player.stats.patience;
                if (mobileStatStrength) mobileStatStrength.textContent = this.player.stats.strength;
                
                // Update mobile sound button icon
                const mobileSoundBtn = document.getElementById('mobile-sound-btn');
                if (mobileSoundBtn) {
                    mobileSoundBtn.textContent = this.soundEnabled ? 'üîä' : 'üîá';
                }
                
                // Update character display (image) - don't show robohash, use 3D cats instead
                const mobileCharacterDisplayImg = document.getElementById('mobile-character-display-img');
                if (mobileCharacterDisplayImg) {
                    // Always hide image when using cat-rig system or if character is robohash URL
                    if (this.player.character === 'cat-rig' || 
                        this.player.avatarOptions?.type === 'cat' ||
                        (this.player.character && (this.player.character.includes('robohash') || this.player.character.includes('robohash.org')))) {
                        mobileCharacterDisplayImg.style.display = 'none';
                    } else if (this.player.character && !this.player.character.includes('robohash') && !this.player.character.includes('robohash.org')) {
                        mobileCharacterDisplayImg.src = this.player.character;
                        mobileCharacterDisplayImg.style.display = 'block';
                    } else {
                        mobileCharacterDisplayImg.style.display = 'none'; // Hide robohash or unknown
                    }
                }
                
                // Update mobile inventory
                this.updateMobileInventory();

                // Update location dropdown (both desktop and mobile)
                this.updateLocationButtons();

                this.updateOnlinePlayers();
                this.updateTournamentDisplay();
            }

            updateMobileInventory() {
                // Update mobile equipped gear
                const mobileEquippedGear = document.getElementById('mobile-equipped-gear');
                if (mobileEquippedGear) {
                    // Get actual equipped gear - check both singular and plural keys for compatibility
                    const rod = this.player.gear?.rods || this.player.gear?.rod || 'None';
                    const reel = this.player.gear?.reels || this.player.gear?.reel || 'None';
                    const line = this.player.gear?.lines || this.player.gear?.line || 'None';
                    const hook = this.player.gear?.hooks || this.player.gear?.hook || 'None';
                    const bait = this.player.gear?.baits || this.player.gear?.bait || 'None';
                    
                    mobileEquippedGear.innerHTML = `
                        <div style="margin-bottom: 8px;"><strong>üé£ Rod:</strong> ${rod}</div>
                        <div style="margin-bottom: 8px;"><strong>üé£ Reel:</strong> ${reel}</div>
                        <div style="margin-bottom: 8px;"><strong>ü™ù Line:</strong> ${line}</div>
                        <div style="margin-bottom: 8px;"><strong>ü™ù Hook:</strong> ${hook}</div>
                        <div><strong>üêõ Bait:</strong> ${bait}</div>
                    `;
                }
                
                // Update mobile recent catches (last 5)
                const mobileRecentCatches = document.getElementById('mobile-recent-catches');
                if (mobileRecentCatches) {
                    if (this.player.recentCatches.length === 0) {
                        mobileRecentCatches.innerHTML = '<div style="color: #888; padding: 10px;">No fish caught yet!</div>';
                    } else {
                        const recentCatches = this.player.recentCatches.slice(-5).reverse();
                        mobileRecentCatches.innerHTML = recentCatches.map(catchData => `
                            <div style="padding: 8px; margin-bottom: 5px; background: rgba(20, 30, 50, 0.6); border-radius: 6px; border-left: 3px solid rgba(100, 200, 255, 0.5);">
                                <div style="font-weight: bold; color: #64b5f6;">${catchData.fish.name}</div>
                                <div style="font-size: 9px; color: #aaa; margin-top: 3px;">
                                    ${catchData.weight.toFixed(1)} lbs ‚Ä¢ $${catchData.value} ‚Ä¢ ${catchData.location}
                                </div>
                            </div>
                        `).join('');
                    }
                }
            }

            updateLocationButtons() {
                const select = document.getElementById('location-select');
                const mobileSelect = document.getElementById('mobile-location-select');
                
                if (select) {
                    select.innerHTML = '';
                    
                    this.locations.forEach((location, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = location.name;
                        
                        // Check if location is unlocked
                        if (!this.player.locationUnlocks.includes(index)) {
                            option.disabled = true;
                            option.textContent += ` (Locked - Level ${location.unlockLevel})`;
                        }
                        
                        // Check if it's the current location
                        if (index === this.currentLocation) {
                            option.selected = true;
                        }
                        
                        select.appendChild(option);
                    });
                }

                // Update mobile location dropdown
                if (mobileSelect) {
                    mobileSelect.innerHTML = '';
                    
                    this.locations.forEach((location, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = location.name;
                        
                        // Check if location is unlocked
                        if (!this.player.locationUnlocks.includes(index)) {
                            option.disabled = true;
                            option.textContent += ` (Locked - Level ${location.unlockLevel})`;
                        }
                        
                        // Check if it's the current location
                        if (index === this.currentLocation) {
                            option.selected = true;
                        }
                        
                        mobileSelect.appendChild(option);
                    });
                }
            }

            saveGameData() {
                const gameData = {
                    player: this.player,
                    currentLocation: this.currentLocation,
                    timestamp: Date.now(),
                    version: '1.0' // For future compatibility
                };
                
                try {
                    const dataString = JSON.stringify(gameData);
                    const dataSize = Math.round(dataString.length / 1024 * 100) / 100; // KB
                    
                    // Save main game data
                    localStorage.setItem('fishingHoleGame', dataString);
                    
                    // Create a backup save
                    localStorage.setItem('fishingHoleGame_backup', dataString);
                    
                    // Update status display
                    this.updateGameStatus(dataSize);
                    
                    console.log('Game data saved successfully');
                    
                    // Save to server if connected
                    if (this.socket && this.connected) {
                        this.socket.emit('save-game', this.player);
                    }
                    
                    // Show save confirmation occasionally
                    if (Math.random() < 0.1) { // 10% chance
                        this.addChatMessage('system', 'Progress saved!');
                    }
                } catch (error) {
                    console.error('Failed to save game data:', error);
                    this.addChatMessage('system', 'Warning: Could not save progress!');
                    this.updateGameStatus(0, 'Error');
                }
            }

            updateGameStatus(dataSize, status = 'Active') {
                // Game Status section was removed, so just log if needed
                // No-op since status display is no longer shown
            }

            generateSimulatedCatches(count) {
                const catches = [];
                for (let i = 0; i < count; i++) {
                    const randomFish = this.fishTypes[Math.floor(Math.random() * this.fishTypes.length)];
                    const weight = randomFish.minWeight + Math.random() * (randomFish.maxWeight - randomFish.minWeight);
                    const value = Math.floor(randomFish.value * (1 + weight / randomFish.maxWeight));
                    
                    catches.push({
                        fish: randomFish,
                        weight: weight,
                        value: value,
                        experience: Math.floor(randomFish.experience * (1 + weight / randomFish.maxWeight)),
                        location: this.locations[Math.floor(Math.random() * this.locations.length)].name,
                        timestamp: Date.now() - Math.random() * 86400000 // Random time in last 24 hours
                    });
                }
                return catches.sort((a, b) => b.timestamp - a.timestamp); // Sort by newest first
            }

            updateLeaderboard() {
                // Update biggest fish leaderboard
                this.updateBiggestFishLeaderboard();
                
                // Update biggest bags leaderboard
                this.updateBiggestBagsLeaderboard();
            }

            async updateBiggestFishLeaderboard() {
                // Fetch leaderboard from server
                let serverPlayers = [];
                try {
                    const response = await fetch(`${this.serverUrl}/api/leaderboard`);
                    serverPlayers = await response.json();
                } catch (error) {
                    console.error('Failed to fetch leaderboard:', error);
                }

                // Combine with local player
                const realPlayers = [
                    {
                        name: this.player.name,
                        biggestFish: this.player.biggestCatch,
                        recentCatches: this.player.recentCatches
                    },
                    ...serverPlayers.map(p => ({
                        name: p.name,
                        biggestFish: Number(p.biggest_catch) || 0,
                        recentCatches: []
                    }))
                ].filter((p, index, self) => 
                    index === self.findIndex(pl => pl.name === p.name)
                );

                // Sort by biggest fish
                const biggestFishLeaders = realPlayers
                    .filter(player => player.biggestFish > 0)
                    .sort((a, b) => b.biggestFish - a.biggestFish)
                    .slice(0, 3);

                // Update display
                const container = document.getElementById('biggest-fish-leaderboard');
                const mobileContainer = document.getElementById('mobile-biggest-fish-leaderboard');
                
                const leaderboardHTML = biggestFishLeaders.length === 0 
                    ? '<div class="leaderboard-item">No fish caught yet</div>'
                    : biggestFishLeaders.map((player, index) => {
                        const weight = Number(player.biggestFish) || 0;
                        return `
                        <div class="leaderboard-item">
                            <span class="rank">#${index + 1}</span>
                            <span class="player-name">${player.name}</span>
                            <span class="weight">${weight.toFixed(1)} lbs</span>
                        </div>
                    `;
                    }).join('');

                if (container) container.innerHTML = leaderboardHTML;
                if (mobileContainer) mobileContainer.innerHTML = leaderboardHTML;
            }

            updateTop10BiggestFish(catchData) {
                // Initialize if needed
                if (!this.player.top10BiggestFish) {
                    this.player.top10BiggestFish = [];
                }

                // Add the new catch
                this.player.top10BiggestFish.push(catchData);

                // Sort by weight (biggest first) and keep only top 10
                this.player.top10BiggestFish.sort((a, b) => b.weight - a.weight);
                this.player.top10BiggestFish = this.player.top10BiggestFish.slice(0, 10);
            }

            async updateBiggestBagsLeaderboard() {
                // Fetch leaderboard from server
                let serverPlayers = [];
                try {
                    const response = await fetch(`${this.serverUrl}/api/leaderboard`);
                    serverPlayers = await response.json();
                } catch (error) {
                    console.error('Failed to fetch leaderboard:', error);
                }

                // Combine with local player
                const realPlayers = [
                    {
                        name: this.player.name,
                        top10BiggestFish: this.player.top10BiggestFish || []
                    },
                    ...serverPlayers.map(p => ({
                        name: p.name,
                        top10BiggestFish: p.top10_biggest_fish || []
                    }))
                ].filter((p, index, self) => 
                    index === self.findIndex(pl => pl.name === p.name)
                );

                // Calculate top 10 BIGGEST fish weight for each player
                const playersWithBags = realPlayers.map(player => {
                    // Use the persistent top10BiggestFish array (never goes down)
                    const top10Fish = player.top10BiggestFish || [];
                    
                    const bagWeight = top10Fish.reduce((total, catchData) => total + (catchData.weight || 0), 0);
                    
                    return {
                        name: player.name,
                        bagWeight: bagWeight,
                        fishCount: top10Fish.length,
                        top10Fish: top10Fish // Store for display
                    };
                }).filter(player => player.bagWeight > 0 && player.fishCount >= 1);

                // Sort by bag weight (total of top 10 biggest fish)
                const biggestBagsLeaders = playersWithBags
                    .sort((a, b) => b.bagWeight - a.bagWeight)
                    .slice(0, 3);

                // Update display
                const container = document.getElementById('biggest-bags-leaderboard');
                const mobileContainer = document.getElementById('mobile-biggest-bags-leaderboard');
                
                const leaderboardHTML = biggestBagsLeaders.length === 0
                    ? '<div class="leaderboard-item">No fish caught yet</div>'
                    : biggestBagsLeaders.map((player, index) => `
                        <div class="leaderboard-item">
                            <span class="rank">#${index + 1}</span>
                            <span class="player-name">${player.name}</span>
                            <span class="weight">${player.bagWeight.toFixed(1)} lbs</span>
                        </div>
                    `).join('');

                if (container) container.innerHTML = leaderboardHTML;
                if (mobileContainer) mobileContainer.innerHTML = leaderboardHTML;
            }

            // Auto-save every 30 seconds
            startAutoSave() {
                setInterval(() => {
                    this.saveGameData();
                }, 30000); // 30 seconds
            }

            manualSave() {
                this.saveGameData();
                this.showMessage('Game saved successfully!', '#00ff00');
                this.addChatMessage('system', 'Game progress saved!');
            }

            exportGameData() {
                const gameData = {
                    player: this.player,
                    currentLocation: this.currentLocation,
                    timestamp: Date.now(),
                    version: '1.0'
                };
                
                const dataStr = JSON.stringify(gameData, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `fishing-hole-save-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                
                this.addChatMessage('system', 'Game data exported!');
            }

            importGameData(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const gameData = JSON.parse(e.target.result);
                        
                        if (gameData.player && gameData.version) {
                            this.player = { ...this.player, ...gameData.player };
                            this.currentLocation = gameData.currentLocation || 0;
                            
                            this.updateDisplay();
                            this.updateAchievementsDisplay();
                            this.saveGameData();
                            
                            this.showMessage('Game data imported successfully!', '#00ff00');
                            this.addChatMessage('system', 'Game data imported!');
                        } else {
                            this.showMessage('Invalid game data file!', '#ff0000');
                        }
                    } catch (error) {
                        this.showMessage('Error importing game data!', '#ff0000');
                        console.error('Import error:', error);
                    }
                };
                reader.readAsText(file);
            }

            loadGameData() {
                try {
                    const savedData = localStorage.getItem('fishingHoleGame');
                    if (savedData) {
                        const gameData = JSON.parse(savedData);
                        
                        // Load player data with proper defaults for new features
                        if (gameData.player) {
                            // Merge saved data with defaults to ensure new features are initialized
                            this.player = {
                                ...this.player,
                                ...gameData.player,
                                // Ensure character is preserved
                                character: gameData.player.character || 'üë®',
                                // CRITICAL: Preserve gear from saved data
                                gear: {
                                    rod: 'Basic Rod',
                                    reel: 'Basic Reel',
                                    line: 'Monofilament',
                                    hook: 'Basic Hook',
                                    bait: 'Basic Bait',
                                    ...gameData.player.gear // Saved gear takes precedence
                                },
                                // Ensure new features have defaults if not in saved data
                                stats: {
                                    accuracy: 50,
                                    luck: 50,
                                    patience: 50,
                                    strength: 50,
                                    ...gameData.player.stats
                                },
                                achievements: gameData.player.achievements || [],
                                recentCatches: gameData.player.recentCatches || [],
                                top10BiggestFish: gameData.player.top10BiggestFish || [],
                                caughtFish: gameData.player.caughtFish || {},
                                seasonalCatches: {
                                    spring: { caught: 0, biggest: 0 },
                                    summer: { caught: 0, biggest: 0 },
                                    fall: { caught: 0, biggest: 0 },
                                    winter: { caught: 0, biggest: 0 },
                                    ...gameData.player.seasonalCatches
                                },
                                tournamentStats: {
                                    tournamentsPlayed: 0,
                                    tournamentsWon: 0,
                                    biggestTournamentFish: 0,
                                    biggestTournamentBag: 0,
                                    totalTournamentWeight: 0,
                                    totalTournamentFish: 0,
                                    ...gameData.player.tournamentStats
                                }
                            };
                            
                            // Debug: Log loaded gear
                            console.log('Loaded gear from save:', this.player.gear);
                        }
                        
                        // Load current location
                        if (gameData.currentLocation !== undefined) {
                            this.currentLocation = gameData.currentLocation;
                        }
                        
                        console.log('Game data loaded successfully');
                        this.addChatMessage('system', `Welcome back, ${this.player.name}! Your progress has been loaded.`);
                        
                        // Show loaded stats
                        this.addChatMessage('system', `Level ${this.player.level} | ${this.player.totalCaught} fish caught | $${this.player.money} earned`);
                        
                        // Initialize top10BiggestFish if empty (migrate from recentCatches)
                        if (!this.player.top10BiggestFish || this.player.top10BiggestFish.length === 0) {
                            this.player.top10BiggestFish = [];
                            // Migrate existing catches to top10BiggestFish
                            if (this.player.recentCatches && this.player.recentCatches.length > 0) {
                                this.player.recentCatches.forEach(catchData => {
                                    this.updateTop10BiggestFish(catchData);
                                });
                            }
                        } else {
                            // Ensure it's sorted correctly
                            this.player.top10BiggestFish.sort((a, b) => b.weight - a.weight);
                            this.player.top10BiggestFish = this.player.top10BiggestFish.slice(0, 10);
                        }
                        
                        // Check for any unlocks that should have happened
                        this.checkLocationUnlocks();
                        this.checkTackleUnlocks();
                        this.updateLocationButtons();
                    } else {
                        console.log('No saved game data found, starting fresh');
                        this.addChatMessage('system', 'Welcome to Kitty Creek Fishing Club! üê±üé£ Start your purrfect fishing adventure!');
                    }
                } catch (error) {
                    console.error('Failed to load game data:', error);
                    this.addChatMessage('system', 'Welcome to Kitty Creek Fishing Club! üê±üé£ Start your purrfect fishing adventure!');
                }
            }

            resetCharacter() {
                if (!confirm('Are you sure you want to reset your character? This will delete all your progress, stats, catches, and achievements. This cannot be undone!')) {
                    return;
                }

                // Clear saved data
                localStorage.removeItem('fishingHoleGame');
                
                // Reset player to defaults (keeping name and character)
                const savedName = this.player.name;
                const savedCharacter = this.player.character;
                
                this.player = {
                    name: savedName,
                    character: savedCharacter,
                    level: 1,
                    money: 100,
                    experience: 0,
                    totalCaught: 0,
                    totalWeight: 0,
                    biggestCatch: 0,
                    locationUnlocks: [0, 1],
                    tackleUnlocks: {
                        rods: [0],
                        reels: [0],
                        lines: [0],
                        hooks: [0],
                        baits: [0]
                    },
                    gear: {
                        rod: 'Basic Rod',
                        reel: 'Basic Reel',
                        line: 'Monofilament',
                        hook: 'Basic Hook',
                        bait: 'Basic Bait'
                    },
                    stats: {
                        accuracy: 50,
                        luck: 50,
                        patience: 50,
                        strength: 50
                    },
                    achievements: [],
                    recentCatches: [],
                    top10BiggestFish: [],
                    seasonalCatches: {
                        spring: { caught: 0, biggest: 0 },
                        summer: { caught: 0, biggest: 0 },
                        fall: { caught: 0, biggest: 0 },
                        winter: { caught: 0, biggest: 0 }
                    },
                    tournamentStats: {
                        tournamentsPlayed: 0,
                        tournamentsWon: 0,
                        biggestTournamentFish: 0,
                        biggestTournamentBag: 0,
                        totalTournamentWeight: 0,
                        totalTournamentFish: 0
                    }
                };
                
                this.currentLocation = 0;
                this.updateDisplay();
                this.updateLocationButtons();
                this.updateAchievementsDisplay();
                this.updateLeaderboard();
                this.positionPlayers();
                this.addChatMessage('system', 'Character reset! Starting fresh...');
                this.saveGameData();
            }

            changeCharacter() {
                // Show character selector modal/overlay
                const loginScreen = document.getElementById('login-screen');
                if (loginScreen) {
                    // Hide the login button and show character selector only
                    const loginBtn = document.getElementById('login-btn');
                    const nameInput = document.getElementById('player-name-input');
                    if (loginBtn) loginBtn.style.display = 'none';
                    if (nameInput) nameInput.style.display = 'none';
                    
                    // Show login screen as character selector
                    loginScreen.classList.remove('hidden');
                    
                    // Update button to say "SELECT CHARACTER" instead of login
                    const charSelectBtn = document.createElement('button');
                    charSelectBtn.className = 'login-btn';
                    charSelectBtn.id = 'char-select-btn';
                    charSelectBtn.textContent = 'SELECT CHARACTER';
                    charSelectBtn.onclick = () => {
                        const selectedCatUrl = window.selectedCat || this.player.character;
                        this.player.character = selectedCatUrl;
                        this.player.avatarOptions = { type: 'cat', url: selectedCatUrl };
                        this.saveGameData();
                        loginScreen.classList.add('hidden');
                        this.positionPlayers();
                        this.updateDisplay();
                        this.addChatMessage('system', 'Character updated!');
                        
                        // Restore login button
                        if (loginBtn) loginBtn.style.display = 'block';
                        if (nameInput) nameInput.style.display = 'block';
                        charSelectBtn.remove();
                    };
                    
                    // Replace or add the button
                    const existingBtn = document.getElementById('char-select-btn');
                    if (existingBtn) {
                        existingBtn.replaceWith(charSelectBtn);
                    } else {
                        loginScreen.appendChild(charSelectBtn);
                    }
                }
            }

            #fallbackTo2D(fisherElement) {
                // Fallback to 2D cat rig
                const cat3dEl = fisherElement.querySelector('.cat3d');
                const catRigEl = fisherElement.querySelector('.cat-rig');
                if (cat3dEl) cat3dEl.style.display = 'none';
                if (catRigEl) catRigEl.style.display = 'block';
                
                // Ensure avatarOptions has proper structure
                const avatarOptions = this.player?.avatarOptions || {};
                const opts = {
                    colors: {
                        fur: avatarOptions?.colors?.fur || '#f2a65a',
                        pattern: avatarOptions?.colors?.pattern || '#d77f3f',
                        ear: avatarOptions?.colors?.ear || '#c76b2a',
                        eye: avatarOptions?.colors?.eye || '#1e2a3a',
                        belly: avatarOptions?.colors?.belly || '#f8d7b1'
                    },
                    gear: {
                        hat: avatarOptions?.gear?.hat || false,
                        glasses: avatarOptions?.gear?.glasses || false,
                        vest: avatarOptions?.gear?.vest || false
                    }
                };
                
                const rigContainer = fisherElement.querySelector('.cat-rig');
                if (window.renderCatRig && rigContainer) {
                    console.log('Rendering 2D cat rig');
                    window.renderCatRig(rigContainer, opts);
                } else {
                    console.log('2D cat rig not available, showing placeholder');
                    // Show a simple placeholder
                    rigContainer.innerHTML = '<div style="width: 100%; height: 100%; background: #f2a65a; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: #1e2a3a; font-size: 12px;">üê±</div>';
                }
            }
        }

        // Safe 2D fallback renderer
        window.renderCatRig ||= function(el, options={}){
            el.style.display = 'block';
            el.innerHTML = '<div style="width:100%;height:100%;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:14px;background:#1c2740;color:#9fd1ff;">üê±</div>';
        };
        
        // Define safeKey in non-module script so it's available immediately
        // This is also defined in the module script, but we need it here for positionPlayers
        window.safeKey = window.safeKey || function(name) {
            return String(name).trim().toLowerCase().replace(/[^a-z0-9_-]+/g, '-');
        };

        // Start the game
        const game = new FishingHoleMultiplayer();
    </script>

    <!-- Three.js 3D Cat System -->
    <script type="module">
        import * as THREE from 'https://esm.sh/three@0.160.0';
        import { GLTFLoader } from 'https://esm.sh/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
        import { RGBELoader } from 'https://esm.sh/three@0.160.0/examples/jsm/loaders/RGBELoader.js';
        
        // Make THREE available globally for non-module scripts
        window.THREE = THREE;

        // Utility functions for bulletproof player container matching
        window.safeKey = function(name) {
            return String(name).trim().toLowerCase().replace(/[^a-z0-9_-]+/g, '-');
        };

        window.getCatContainerForPlayer = function(name) {
            const key = window.safeKey(name);
            // Try the most reliable first: data-cat3d=safeKey
            let el =
                document.querySelector(`.cat3d[data-cat3d="${key}"]`) ||
                document.querySelector(`.cat3d[data-player-id="${key}"]`) ||
                document.querySelector(`.cat3d[data-player-id="${name}"]`) ||
                document.getElementById(`cat3d-${key}`);
            if (!el) {
                // Last-ditch: current player bucket
                el = document.querySelector('#player-fisher .cat3d')
                    || document.querySelector('.fisherman.you .cat3d')
                    || document.querySelector('#mobile-player-fisher .cat3d');
            }
            if (!el) {
                console.warn('mountPlayerCat3D: No container found for', name, { key });
            }
            return el || null;
        };

        // Limit active 3D renderers to prevent context exhaustion
        // Set to 6 to allow more AIs to use 3D (player + 5 bots max)
        window.MAX_3D_RENDERERS = 1; // Only player, no AI/other players
        window.ACTIVE_3D_PLAYERS = new Set();

        window.choose3DPlayers = function(allPlayers, you) {
            // Only return the player - no AI or other players
            const chosen = new Set([window.safeKey(you)]);
            return chosen;
        };
        
        // Deterministic RNG for multiplayer sync (seed per cast from server)
        window.makeRNG = function(seed) {
            return function() { // xorshift32-ish
                seed |= 0; seed = seed + 0x6D2B79F5 | 0;
                let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
                t ^= t + Math.imul(t ^ t >>> 7, 61 | t);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            };
        };
        
        // Get a random point on the lake surface
        window.randomLakeTarget = function({ lakeBounds, lakeMesh, raycaster, rng, padding = 2.0 }) {
            const cx = lakeBounds.center.x;
            const cz = lakeBounds.center.z;
            const halfW = Math.max(0, lakeBounds.halfW - padding);
            const halfH = Math.max(0, lakeBounds.halfH - padding);

            // Sample in a disk inside the rectangle so casts aren't always at corners
            const u = rng(), v = rng();
            const r = Math.sqrt(u);          // bias toward center a bit
            const theta = 2 * Math.PI * v;
            const x = cx + r * halfW * Math.cos(theta);
            const z = cz + r * halfH * Math.sin(theta);

            if (lakeMesh) {
                // Raycast from above to the mesh for precise surface Y
                const start = new THREE.Vector3(x, lakeBounds.y + 100, z);
                const dir   = new THREE.Vector3(0, -1, 0);
                raycaster.set(start, dir);
                const hit = raycaster.intersectObject(lakeMesh, true)[0];
                if (hit) return hit.point.clone();
            }
            // Fallback to flat water plane Y
            return new THREE.Vector3(x, lakeBounds.y, z);
        };
        
        // Face model toward target (Y rotation only)
        window.faceModelYawToward = function(modelRoot, target, lerpSpeed = 0.4) {
            if (!modelRoot || !target) return;
            const currentPos = new THREE.Vector3();
            modelRoot.getWorldPosition(currentPos);
            const direction = new THREE.Vector3().subVectors(target, currentPos);
            direction.y = 0; // Only rotate on Y axis
            if (direction.length() > 0.01) {
                direction.normalize();
                let desiredYaw = Math.atan2(direction.x, direction.z);
                
                // Yaw offset: if cat model faces -Z (common), add 180¬∞
                // Adjust this based on your model's forward direction
                const yawOffset = Math.PI; // 180¬∞ if model faces -Z; try 0, PI/2, -PI/2, etc.
                desiredYaw += yawOffset;
                
                const currentRotation = modelRoot.rotation.y;
                
                // Normalize angle difference to [-PI, PI] range
                let diff = desiredYaw - currentRotation;
                while (diff > Math.PI) diff -= 2 * Math.PI;
                while (diff < -Math.PI) diff += 2 * Math.PI;
                
                modelRoot.rotation.y = currentRotation + diff * lerpSpeed;
            }
        };

        class Cat3D {
            constructor(container, opts={}){
                this.container = container;
                this.modelUrl = opts.modelUrl || '/assets/glb/PZSNQ3IH66OXPUSBTYNAMD6EC.glb'; // Real cat model
                this.envUrl   = opts.envUrl   || null; // '/assets/env/lake.hdr'
                this.tint     = new THREE.Color(opts.furColor || '#c8a079');
                this.scale    = opts.scale || 0.9;
                
                // Guard against double-mounts
                if (container.__renderer || container.__mounted) {
                    console.warn('Cat3D: Container already has a renderer, reusing or disposing existing');
                    if (container.__renderer && container.__renderer.dispose) {
                        container.__renderer.dispose();
                    }
                }

                // Check WebGL context limit before creating renderer
                if (window.activeWebGLContexts >= 8) {
                    console.warn('WebGL context limit reached, falling back to 2D');
                    this.container.dispatchEvent(new CustomEvent('cat3d-failed'));
                    return;
                }

                // Check if container is visible before mounting
                const rect = container.getBoundingClientRect();
                if (rect.width === 0 || rect.height === 0 || container.offsetParent === null) {
                    console.warn('Cat3D: Container not visible, deferring mount');
                    // Container might become visible later, but skip for now
                    this.container.dispatchEvent(new CustomEvent('cat3d-failed'));
                    return;
                }

                // renderer
                this.renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'high-performance' });
                const dpr = Math.min(window.devicePixelRatio || 1, 2);
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(container.clientWidth, container.clientHeight, false);
                this.renderer.outputColorSpace = THREE.SRGBColorSpace;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.1;
                // Transparent canvas so you can see debug/underlay and avoid "big dark rectangle"
                this.renderer.setClearAlpha(0); // transparent canvas
                // Optional: keep a slight tint while debugging:
                // this.renderer.setClearColor(0x101820, 0.15);
                
                container.innerHTML = '';
                container.appendChild(this.renderer.domElement);
                
                // Cache renderer on container to prevent duplicates
                container.__renderer = this.renderer;
                container.__scene = null; // will be set below
                container.__camera = null; // will be set below
                container.__mounted = true;

                // Track active contexts
                window.activeWebGLContexts = (window.activeWebGLContexts || 0) + 1;

                // Handle context lost/restored events
                const canvas = this.renderer.domElement;
                canvas.addEventListener('webglcontextlost', (e) => {
                    e.preventDefault();
                    console.warn('WebGL context lost for cat:', container.dataset.playerId);
                    this.running = false;
                    cancelAnimationFrame(this.raf);
                });
                
                canvas.addEventListener('webglcontextrestored', () => {
                    console.log('WebGL context restored for cat:', container.dataset.playerId);
                    // Rebuild materials/programs/textures as needed
                    this.#load().then(() => {
                        this.running = true;
                        this.#loop();
                    });
                });

                // scene/camera
                this.scene = new THREE.Scene();
                container.__scene = this.scene;
                // AxesHelper removed - cats are now visible and rendering correctly
                this.camera = new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight || 1, 0.1, 50);
                container.__camera = this.camera;
                // Camera positioned to show full cat model nicely framed in 96x96px container
                this.camera.position.set(0, 0.6, 2.0); // Close enough to see cat clearly
                this.camera.lookAt(0, 0, 0); // Look at origin where model is centered
                console.log('Cat3D: Camera initialized at', this.camera.position, 'looking at origin');

                // lights (work even without HDRI)
                const hemi = new THREE.HemisphereLight(0xffffff, 0x446688, 0.7);
                const key  = new THREE.DirectionalLight(0xffffff, 0.7); key.position.set(1.5, 2, 1.2);
                const rim  = new THREE.DirectionalLight(0x88ccff, 0.25); rim.position.set(-2, 1.2, -1.5);
                this.scene.add(hemi, key, rim);

                // state
                this.clock = new THREE.Clock();
                this.running = true;
                this._firstRender = true; // Flag to log first render
                this._sphereRadius = null; // Store bounding sphere radius for resize
                this._cameraDistance = null; // Store camera distance for reference
                this.mixer = null;
                this.clips = {};
                this.blinkMorph = null;
                this.earMorphL = null;
                this.earMorphR = null;
                this.tailBone = null;
                this.model = null;

                // load everything
                this.#load().then(()=>{
                    if (this.running) this.#loop();
                });

                // resize
                new ResizeObserver(()=>this.#resize()).observe(container);
            }

            async #load(){
                try {
                    // environment (optional HDR for better reflections)
                    if (this.envUrl){
                        const rgbe = new RGBELoader();
                        rgbe.load(this.envUrl, (tex) => {
                            tex.mapping = THREE.EquirectangularReflectionMapping;
                            this.scene.environment = tex;
                            this.scene.background = null; // keep canvas transparent
                        });
                    }

                    // model - use load with error callback for better error handling
                    const loader = new GLTFLoader();
                    let gltf;
                    try {
                        gltf = await new Promise((resolve, reject) => {
                            loader.load(
                                this.modelUrl,
                                (gltf) => resolve(gltf),
                                undefined,
                                (err) => {
                                    console.error('Cat3D GLTF failed:', this.modelUrl, err);
                                    // Put a simple visible placeholder in the scene
                                    const geo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
                                    const mat = new THREE.MeshStandardMaterial({ 
                                        color: this.tint,
                                        metalness: 0.2, 
                                        roughness: 0.8 
                                    });
                                    const cube = new THREE.Mesh(geo, mat);
                                    cube.name = '__cat_placeholder__'; // Named so we can remove it on success
                                    cube.position.set(0, -0.5, 0);
                                    this.scene.add(cube);
                                    this.model = cube;
                                    
                                    // Also notify DOM so your page can 2D-fallback if desired
                                    this.container.dispatchEvent(new CustomEvent('cat3d-failed'));
                                    reject(err);
                                }
                            );
                        });
                        this.model = gltf.scene;
                        console.log('Cat3D: GLTF loaded successfully:', this.modelUrl, this.model);
                        
                        // HARDENING PATCH: Ensure real cat shows, not placeholder boxes
                        
                        // 1) If we ever added a placeholder cube earlier, remove it now
                        const oldPlaceholder = this.scene.getObjectByName('__cat_placeholder__');
                        if (oldPlaceholder) {
                            this.scene.remove(oldPlaceholder);
                            console.log('Cat3D: Removed old placeholder cube');
                        }
                        
                        // 2) Apply any base scale first (if provided)
                        if (this.scale !== 1.0) {
                            this.model.scale.setScalar(this.scale);
                        }
                        
                        // 3) Make sure everything in the model is visible and lit; swap unlit mats
                        this.model.traverse((o) => {
                            if (o.isMesh) {
                                // Ensure it renders with lights
                                if (!(o.material && (o.material.isMeshStandardMaterial || o.material.isMeshPhysicalMaterial))) {
                                    const color = (o.material && o.material.color) ? o.material.color.clone() : new THREE.Color(0xcccccc);
                                    const map = (o.material && o.material.map) ? o.material.map : null;
                                    const rough = (o.material && o.material.roughness !== undefined) ? o.material.roughness : 0.7;
                                    const metal = (o.material && o.material.metalness !== undefined) ? o.material.metalness : 0.0;
                                    o.material = new THREE.MeshStandardMaterial({ color, map, roughness: rough, metalness: metal });
                                    console.log('Cat3D: Converted unlit material to MeshStandardMaterial for', o.name || 'mesh');
                                }
                                o.castShadow = true;
                                o.receiveShadow = true;
                                o.visible = true;
                                o.frustumCulled = true;
                                
                                // Ensure materials are visible
                                const mats = Array.isArray(o.material) ? o.material : [o.material];
                                mats.forEach((mat) => {
                                    if (mat) {
                                        mat.transparent = false;
                                        mat.opacity = 1.0;
                                        if (!mat.color || mat.color.getHex() === 0x000000) {
                                            mat.color = new THREE.Color(0xcccccc);
                                        }
                                        mat.needsUpdate = true;
                                    }
                                });
                            }
                        });
                        
                        // 4) QUICK ASSERTS: log what we actually got
                        let meshCount = 0, boxGeoCount = 0;
                        let totalVerts = 0;
                        this.model.traverse((o) => {
                            if (o.isMesh) {
                                meshCount++;
                                const g = o.geometry;
                                const type = g ? g.type : 'Unknown';
                                if (type && type.toLowerCase().includes('box')) boxGeoCount++;
                                const vertCount = g?.attributes?.position?.count || 0;
                                totalVerts += vertCount;
                                console.log('Cat3D: mesh', o.name || '(unnamed)', 'geom:', type, 'verts:', vertCount);
                            }
                        });
                        if (meshCount === 0) {
                            console.error('Cat3D ERROR: GLB has no meshes ‚Äî check model URL:', this.modelUrl);
                        } else if (totalVerts <= 8) {
                            console.error('Cat3D ERROR: Model has only', totalVerts, 'vertices ‚Äî this is a CUBE, not a cat!');
                            console.error('Cat3D ERROR: The file', this.modelUrl, 'appears to be a placeholder cube.');
                            console.error('Cat3D ERROR: Please replace with a real cat GLB file that has proper cat geometry.');
                            console.error('Cat3D ERROR: Expected hundreds or thousands of vertices, got', totalVerts);
                        } else {
                            console.log(`Cat3D: Model has ${meshCount} meshes, ${boxGeoCount} box geometries, ${totalVerts} total vertices`);
                        }
                        
                        // 5) Normalize model scale first (models can be exported at any scale)
                        this.model.updateWorldMatrix(true, true);
                        let box = new THREE.Box3().setFromObject(this.model);
                        let sphere = new THREE.Sphere();
                        box.getBoundingSphere(sphere);
                        console.log('Cat3D: Model raw bounding sphere - radius:', sphere.radius, 'center:', sphere.center);
                        
                        // If model is way too large (>10 units radius), scale it down
                        if (sphere.radius > 10) {
                            const normalizeScale = 1.0 / sphere.radius; // Normalize to ~1 unit radius
                            console.log('Cat3D: Model too large, normalizing scale by', normalizeScale);
                            this.model.scale.multiplyScalar(normalizeScale);
                            this.model.updateWorldMatrix(true, true);
                            // Recompute after scaling
                            box = new THREE.Box3().setFromObject(this.model);
                            box.getBoundingSphere(sphere);
                            console.log('Cat3D: Model normalized bounding sphere - radius:', sphere.radius, 'center:', sphere.center);
                        }
                        
                        // Store sphere radius for resize handler
                        this._sphereRadius = sphere.radius;
                        
                        // Center model at the origin so camera math is stable
                        this.model.position.sub(sphere.center);
                        
                        // Frame camera to host (reusable for resize)
                        this.#frameCameraToHost();
                        
                        // 6) Add or refresh "good" lights so the cat doesn't read like a flat box
                        let hemi = this.scene.getObjectByName('__cat_hemi__');
                        let key = this.scene.getObjectByName('__cat_key__');
                        if (!hemi) {
                            hemi = new THREE.HemisphereLight(0xffffff, 0x334455, 0.8);
                            hemi.name = '__cat_hemi__';
                            this.scene.add(hemi);
                            console.log('Cat3D: Added hemisphere light');
                        }
                        if (!key) {
                            key = new THREE.DirectionalLight(0xffffff, 0.85);
                            key.name = '__cat_key__';
                            key.position.set(2.5, 3, 2.5);
                            key.castShadow = false;
                            this.scene.add(key);
                            console.log('Cat3D: Added directional key light');
                        }
                        
                        // 7) Make sure renderer is set up for sane color/lighting
                        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
                        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                        this.renderer.toneMappingExposure = 1.0;
                        
                        // 8) Finally add model to scene and render
                        this.scene.add(this.model);
                        this.model.visible = true;
                        
                        console.log('Cat3D: Camera auto-framed (bounding-sphere) - position:', this.camera.position, 'distance:', this._cameraDistance, 'sphere radius:', sphere.radius);
                    } catch (loadError) {
                        // Error handler already added placeholder, just rethrow to outer catch
                        if (!this.model) {
                            throw loadError;
                        }
                        // Model was set in error handler, continue
                    }
                    
                    // improve materials with tone mapping and environment intensity
                    this.scene.traverse((obj) => {
                        if (obj.isMesh && obj.material) {
                            const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
                            mats.forEach((m) => {
                                if (m.map) m.map.colorSpace = THREE.SRGBColorSpace;
                                if (m.emissiveMap) m.emissiveMap.colorSpace = THREE.SRGBColorSpace;
                                m.envMapIntensity = 0.6;
                                m.roughness = Math.min(0.9, (m.roughness ?? 0.6));
                                m.metalness = Math.max(0.0, (m.metalness ?? 0.1));
                                m.needsUpdate = true;
                            });
                        }
                    });

                    // animation mixer & clip map
                    if (gltf.animations?.length){
                        this.mixer = new THREE.AnimationMixer(this.model);
                        gltf.animations.forEach(clip => { this.clips[clip.name.toLowerCase()] = clip; });
                        // prefer provided idle; else we'll procedural-breathe
                        const idle = this.clips['idle'] || this.clips['breath'] || this.clips['breathing'];
                        if (idle) this.mixer.clipAction(idle).play();
                    }
                } catch (error) {
                    console.error('Cat GLB load failed:', this.modelUrl, error);
                    // Expose a hook so game code can fallback
                    this.container.dispatchEvent(new CustomEvent('cat3d-failed'));
                    // Create placeholder if model failed
                    if (!this.model) {
                        this.#createPlaceholder();
                    }
                }

                // tint fur (supports both MeshStandardMaterial and MultiMat)
                if (this.model) {
                    this.model.traverse(o=>{
                        if (o.isMesh && o.material){
                            // if there's a "fur" or "body" material name, tint that; else tint all slightly
                            const mats = Array.isArray(o.material)? o.material : [o.material];
                            mats.forEach(m=>{
                                if (m.color) {
                                    // Ensure material is visible
                                    m.transparent = false;
                                    m.opacity = 1.0;
                                    
                                    // Use copy and brighten rather than multiply to avoid darkening
                                    const materialName = (m.name || '').toLowerCase();
                                    if (materialName.includes('fur') || materialName.includes('body')) {
                                        // For fur/body, use the tint color directly but brightened
                                        m.color.copy(this.tint);
                                        // Ensure minimum brightness - brighten significantly
                                        const brightness = m.color.r + m.color.g + m.color.b;
                                        if (brightness < 1.0) {
                                            m.color.multiplyScalar(1.5 / Math.max(brightness, 0.3)); // Brighten to ensure visibility
                                        }
                                        // Ensure color is bright enough to be seen - make much brighter
                                        m.color.r = Math.max(0.6, m.color.r); // Minimum 60% brightness
                                        m.color.g = Math.max(0.6, m.color.g);
                                        m.color.b = Math.max(0.6, m.color.b);
                                    } else {
                                        // For other parts, use light color
                                        m.color.copy(new THREE.Color(0xf0f0f0)); // Light gray
                                    }
                                    m.roughness = Math.min(0.9, (m.roughness ?? 0.6) + 0.1);
                                    m.metalness = Math.max(0.0, (m.metalness ?? 0.1) - 0.05);
                                    m.needsUpdate = true;
                                }
                            });
                        }
                    });


                    // morph targets (blink/ears) if present
                    this.model.traverse(o=>{
                        if (o.isMesh && o.morphTargetDictionary){
                            const d = o.morphTargetDictionary;
                            if (d.EyesClosed   !== undefined) this.blinkMorph = { mesh:o, idx:d.EyesClosed };
                            if (d.Blink        !== undefined) this.blinkMorph = { mesh:o, idx:d.Blink };
                            if (d.EarTwitch_L  !== undefined) this.earMorphL  = { mesh:o, idx:d.EarTwitch_L };
                            if (d.EarTwitch_R  !== undefined) this.earMorphR  = { mesh:o, idx:d.EarTwitch_R };
                        }
                        if (o.isBone && /tail/i.test(o.name)) this.tailBone = o;
                        // Find rod tip bone or create attachment point
                        if (o.isBone && (/rod|tip|hand/i.test(o.name))) {
                            if (/tip|end/i.test(o.name)) this.rodTipBone = o;
                            else if (!this.rodTipBone) this.rodTipBone = o; // fallback to first rod/hand bone
                        }
                    });
                    
                    // Load and attach fishing rod model
                    this.rodModel = null;
                    // Note: rodTipBone may already be found above, don't reset it
                    
                    // Find hand/grip bone for rod attachment (try common names)
                    let handBone = null;
                    this.model.traverse(o => {
                        if (o.isBone) {
                            const name = (o.name || '').toLowerCase();
                            // Try common hand bone names
                            if (name === 'mixamorigrighthand' || name === 'mixamorig:righthand' || 
                                name === 'righthand' || name === 'handr' ||
                                name.includes('hand_r') || name.includes('right_hand')) {
                                handBone = o;
                            }
                            // Also check for hand in general
                            if (!handBone && (name.includes('hand') || name.includes('grip')) && 
                                (name.includes('r') || name.includes('right') || !name.includes('left'))) {
                                handBone = o;
                            }
                            // Find rod tip bone in cat model (if it has one)
                            if ((/rod|tip|end/i.test(name)) && !this.rodTipBone) {
                                if (/tip|end/i.test(name)) this.rodTipBone = o;
                            }
                        }
                    });
                    // Fallback: try direct name lookup
                    if (!handBone) {
                        handBone = this.model.getObjectByName('mixamorigRightHand') ||
                                   this.model.getObjectByName('RightHand') ||
                                   this.model.getObjectByName('handr');
                    }
                    
                    // Load fishing rod GLB
                    const rodLoader = new GLTFLoader();
                    rodLoader.load(
                        '/assets/glb/fishing_rod_rigged_and_animated.glb',
                        (rodGltf) => {
                            console.log('Cat3D: Fishing rod loaded successfully');
                            this.rodModel = rodGltf.scene;
                            
                            // Scale and orient rod properly - make it bigger and visible
                            this.rodModel.scale.setScalar(1.5); // Make rod bigger (was 1.0)
                            this.rodModel.rotation.set(0, Math.PI, 0); // Often needed if rod faces backward
                            this.rodModel.position.set(0, -0.02, 0.06); // Small offset in the hand - tweak as needed
                            
                            // Ensure rod is visible
                            this.rodModel.visible = true;
                            this.rodModel.traverse(o => {
                                o.visible = true; // Make sure all parts are visible
                                if (o.isMesh && o.material) {
                                    const mats = Array.isArray(o.material) ? o.material : [o.material];
                                    mats.forEach((m, idx) => {
                                        // Convert to visible material
                                        if (!m.isMeshStandardMaterial && !m.isMeshPhysicalMaterial) {
                                            const newMat = new THREE.MeshStandardMaterial({
                                                color: (m.color && m.color.r > 0) ? m.color : new THREE.Color(0xcccccc),
                                                map: m.map,
                                                roughness: 0.7,
                                                metalness: 0.1
                                            });
                                            if (Array.isArray(o.material)) {
                                                o.material[idx] = newMat;
                                            } else {
                                                o.material = newMat;
                                            }
                                            m = newMat;
                                        }
                                        // Ensure material is bright and visible
                                        m.color = m.color || new THREE.Color(0xcccccc);
                                        if (m.color.r === 0 && m.color.g === 0 && m.color.b === 0) {
                                            m.color.setHex(0xcccccc); // Default gray if black
                                        }
                                        m.transparent = false;
                                        m.opacity = 1.0;
                                        m.visible = true;
                                        m.needsUpdate = true;
                                    });
                                }
                            });
                            
                            console.log('Cat3D: Rod model scaled to 1.5x, materials updated for visibility');
                            
                            // Find rod tip bone in rod model first
                            let rodTipBoneFromRod = null;
                            this.rodModel.traverse(o => {
                                if (o.isBone) {
                                    const name = (o.name || '').toLowerCase();
                                    if (name.includes('tip') || name.includes('end') || name.includes('rod_tip')) {
                                        rodTipBoneFromRod = o;
                                        console.log('Cat3D: Found rod tip bone in rod model:', o.name);
                                    }
                                }
                            });
                            
                            // Create rod tip locator at rod end
                            if (!rodTipBoneFromRod) {
                                // Calculate rod bounding box to find actual rod tip position
                                const rodBox = new THREE.Box3().setFromObject(this.rodModel);
                                const rodSize = rodBox.getSize(new THREE.Vector3());
                                const rodCenter = rodBox.getCenter(new THREE.Vector3());
                                const rodMaxZ = rodBox.max.z;
                                
                                this.rodTipBone = new THREE.Object3D();
                                this.rodTipBone.name = 'RodTip';
                                // Position at actual rod tip (furthest point in +Z or -Z depending on orientation)
                                // Try -Z first (common rod orientation), if that doesn't work visually, try +Z
                                this.rodTipBone.position.set(0, 0, rodMaxZ - rodCenter.z); // Local position at rod tip
                                this.rodModel.add(this.rodTipBone);
                                console.log('Cat3D: Rod bounding box:', {
                                    size: { x: rodSize.x.toFixed(3), y: rodSize.y.toFixed(3), z: rodSize.z.toFixed(3) },
                                    center: { x: rodCenter.x.toFixed(3), y: rodCenter.y.toFixed(3), z: rodCenter.z.toFixed(3) },
                                    tipLocalPos: { x: this.rodTipBone.position.x.toFixed(3), y: this.rodTipBone.position.y.toFixed(3), z: this.rodTipBone.position.z.toFixed(3) }
                                });
                            } else {
                                this.rodTipBone = rodTipBoneFromRod;
                            }
                            
                            // Attach rod to hand bone or fallback
                            const attachBone = handBone || this.model; // fallback to model root
                            attachBone.add(this.rodModel);
                            console.log('Cat3D: Attached rod to', handBone ? `hand bone: ${handBone.name}` : 'model root');
                        },
                        (progress) => {
                            // Progress callback - not an error, just log progress
                            if (progress.total > 0) {
                                const percent = (progress.loaded / progress.total * 100).toFixed(1);
                                // Only log every 25% to avoid spam
                                if (percent % 25 < 1) {
                                    console.log(`Cat3D: Fishing rod loading: ${percent}%`);
                                }
                            }
                        },
                        (error) => {
                            // Only log actual errors (not progress events)
                            if (error && error.type !== 'progress') {
                                console.warn('Cat3D: Failed to load fishing rod, using helper object:', error);
                            }
                            // Fallback: create rod tip helper if no rod loaded
                            if (!this.rodTipBone) {
                                this.rodTipBone = new THREE.Object3D();
                                this.rodTipBone.name = '__rod_tip__';
                                this.rodTipBone.position.set(0.3, 0.5, 0.8); // Approximate hand/rod position
                                this.model.add(this.rodTipBone);
                            }
                        }
                    );
                    
                    // Create rod tip reference point (helper object if no bone found yet - will be replaced if rod loads)
                    if (!this.rodTipBone) {
                        this.rodTipBone = new THREE.Object3D();
                        this.rodTipBone.name = '__rod_tip__';
                        this.rodTipBone.position.set(0.3, 0.5, 0.8); // Approximate hand/rod position
                        this.model.add(this.rodTipBone);
                    }
                    
                    // Create bobber - make it clearly visible
                    const bobberGeom = new THREE.SphereGeometry(0.025, 24, 16); // 2.5cm, high resolution
                    const bobberMat = new THREE.MeshStandardMaterial({ 
                        color: 0xff3333,
                        roughness: 0.5,
                        metalness: 0.1
                    });
                    this.bobber = new THREE.Mesh(bobberGeom, bobberMat);
                    this.bobber.name = 'Bobber';
                    this.bobber.visible = false; // Hidden until cast
                    this.bobber.castShadow = true;
                    this.bobber.receiveShadow = false;
                    this.bobber.renderOrder = 2; // Ensure above water (set water to 1)
                    this.bobber.material.depthWrite = true;
                    this.bobber.material.depthTest = true;
                    this.bobber.userData.bobbing = false;
                    this.scene.add(this.bobber);
                    console.log('Cat3D: Bobber created (0.025 radius, renderOrder 2)');
                    
                    // Create fishing line using world positions
                    const lineGeo = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(),
                        new THREE.Vector3()
                    ]);
                    const lineMat = new THREE.LineBasicMaterial({ 
                        color: 0xcccccc,
                        linewidth: 2 // May not work on all GPUs, but fine
                    });
                    this.fishingLine = new THREE.Line(lineGeo, lineMat);
                    this.fishingLine.name = 'FishingLine';
                    this.fishingLine.visible = false;
                    this.fishingLine.renderOrder = 3; // Above water and bobber
                    this.scene.add(this.fishingLine);
                    console.log('Cat3D: Fishing line created (using world positions)');
                    
                    // Reusable world position vectors for line updates
                    this._worldPosA = new THREE.Vector3();
                    this._worldPosB = new THREE.Vector3();
                }
            }

            #createPlaceholder(){
                // Create a simple cat-like placeholder using basic geometry
                const geometry = new THREE.SphereGeometry(0.5, 16, 12);
                const material = new THREE.MeshStandardMaterial({ 
                    color: this.tint,
                    roughness: 0.8,
                    metalness: 0.1
                });
                
                this.model = new THREE.Mesh(geometry, material);
                this.model.position.set(0, -0.5, 0);
                this.scene.add(this.model);
                
                // Add simple breathing animation
                this.breathingScale = 1.0;
            }

            // realtime loop
            #loop = ()=>{
                if (!this.running) return;
                const dt = this.clock.getDelta();
                if (this.mixer) this.mixer.update(dt);

                // procedural blink if no morphs/clip running
                this.#updateProcedurals();
                
                // Update fishing line to connect rod tip to bobber every frame
                this.#updateFishingLine();
                
                // Update bobber idle bobbing if active (buoyancy jiggle)
                if (this.bobber?.userData?.bobbing) {
                    const baseY = this.bobber.userData.baseY || this.bobber.position.y;
                    this.bobber.userData.bobPhase = (this.bobber.userData.bobPhase || 0) + dt;
                    // More visible bobbing motion
                    this.bobber.position.y = baseY + Math.sin(this.bobber.userData.bobPhase * 2.2) * 0.006;
                }

                // Log first frame to verify scene has content
                if (this._firstRender) {
                    console.log('Cat3D: First render - scene children:', this.scene.children.length, 'model:', !!this.model);
                    if (this.model) {
                        const box = new THREE.Box3().setFromObject(this.model);
                        const size = box.getSize(new THREE.Vector3());
                        console.log('Cat3D: Model actual size after scale:', size);
                        console.log('Cat3D: Camera position:', this.camera.position, 'FOV:', this.camera.fov);
                    }
                    this._firstRender = false;
                }
                
                // Update 2D fishing line overlay every frame
                this.#updateFishingLine();

                this.renderer.render(this.scene, this.camera);
                this.raf = requestAnimationFrame(this.#loop);
            }
            
            // Update fishing line to snap from rod tip to bobber
            // Project 3D position to 2D screen coordinates (page coordinates)
            #projectToScreen(worldPos) {
                const v = worldPos.clone();
                v.project(this.camera);
                
                // Use the actual WebGL canvas bounds on the page
                const rect = this.renderer.domElement.getBoundingClientRect();
                const x = rect.left + (v.x * 0.5 + 0.5) * rect.width;
                const y = rect.top + (v.y * -0.5 + 0.5) * rect.height;
                return { x, y };
            }
            
            // Update 2D overlay line connecting rod tip to bobber
            #update2DFishingLine(){
                if (!this.bobber || !this.rodTipBone || !this.container) {
                    if (!this.rodTipBone) console.warn('Cat3D: No rodTipBone found');
                    return;
                }
                if (!this.bobber.visible) {
                    // Hide overlay if bobber is hidden
                    if (this._overlayLine) this._overlayLine.style.display = 'none';
                    if (this._overlayBobber) this._overlayBobber.style.display = 'none';
                    return;
                }
                
                // Get rod tip world position and project to screen
                this.rodTipBone.updateWorldMatrix(true, false);
                const tipWorld = new THREE.Vector3();
                this.rodTipBone.getWorldPosition(tipWorld);
                const tipScreen = this.#projectToScreen(tipWorld);
                
                // Get bobber world position and project to screen
                this.bobber.updateWorldMatrix(true, false);
                const bobWorld = new THREE.Vector3();
                this.bobber.getWorldPosition(bobWorld);
                const bobScreen = this.#projectToScreen(bobWorld);
                
                // Find lake container and clamp bobber to lake bounds if needed
                const isMobile = window.innerWidth <= 768;
                const lake = document.getElementById(isMobile ? 'mobile-fishing-lake' : 'fishing-lake');
                if (!lake) return;
                
                const lakeRect = lake.getBoundingClientRect();
                
                // Debug first few frames - show actual numeric values (readable format)
                if (!this._debugCount) this._debugCount = 0;
                if (this._debugCount < 5) {
                    console.group(`Cat3D Overlay Debug Frame ${this._debugCount}`);
                    console.log('Rod Tip World:', `${tipWorld.x.toFixed(3)}, ${tipWorld.y.toFixed(3)}, ${tipWorld.z.toFixed(3)}`);
                    console.log('Rod Tip Screen:', `${tipScreen.x.toFixed(1)}, ${tipScreen.y.toFixed(1)}`);
                    console.log('Bobber World:', `${bobWorld.x.toFixed(3)}, ${bobWorld.y.toFixed(3)}, ${bobWorld.z.toFixed(3)}`);
                    console.log('Bobber Screen:', `${bobScreen.x.toFixed(1)}, ${bobScreen.y.toFixed(1)}`);
                    console.log('Distance (screen):', Math.hypot(bobScreen.x - tipScreen.x, bobScreen.y - tipScreen.y).toFixed(1), 'px');
                    const containerRect = this.container.getBoundingClientRect();
                    console.log('Cat Container:', `left:${containerRect.left.toFixed(1)} top:${containerRect.top.toFixed(1)} w:${containerRect.width.toFixed(1)} h:${containerRect.height.toFixed(1)}`);
                    console.log('Lake Container:', `left:${lakeRect.left.toFixed(1)} top:${lakeRect.top.toFixed(1)} w:${lakeRect.width.toFixed(1)} h:${lakeRect.height.toFixed(1)}`);
                    console.log('Bobber visible:', this.bobber.visible);
                    console.log('Rod tip bone:', this.rodTipBone.name);
                    console.groupEnd();
                    this._debugCount++;
                }
                
                // Use exact projected positions - no clamping during cast
                // This ensures line connects properly from rod tip to bobber
                let bobX = bobScreen.x;
                let bobY = bobScreen.y;
                
                // Only clamp when bobber has landed (is bobbing on water)
                if (this.bobber.userData?.bobbing) {
                    // Bobber is floating - keep it visually in lake
                    bobX = Math.min(Math.max(bobScreen.x, lakeRect.left + 10), lakeRect.right - 10);
                    bobY = Math.min(Math.max(bobScreen.y, lakeRect.top + lakeRect.height * 0.4), lakeRect.bottom - 20);
                }
                // During cast animation, use exact projection so line follows bobber correctly
                
                // Create or update overlay line
                if (!this._overlayLine) {
                    this._overlayLine = document.createElement('div');
                    this._overlayLine.className = 'cat3d-fishing-line';
                    this._overlayLine.style.cssText = `
                        position: fixed;
                        pointer-events: none;
                        z-index: 1000;
                        border-left: 2px solid #cccccc;
                        transform-origin: top;
                    `;
                    document.body.appendChild(this._overlayLine);
                }
                
                // Create or update overlay bobber
                if (!this._overlayBobber) {
                    this._overlayBobber = document.createElement('div');
                    this._overlayBobber.className = 'cat3d-bobber';
                    this._overlayBobber.style.cssText = `
                        position: fixed;
                        pointer-events: none;
                        z-index: 1001;
                        width: 12px;
                        height: 12px;
                        border-radius: 50%;
                        background: #ff4444;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                    `;
                    document.body.appendChild(this._overlayBobber);
                }
                
                // Only draw line if both points are valid and visible
                if (!isNaN(tipScreen.x) && !isNaN(tipScreen.y) && 
                    !isNaN(bobX) && !isNaN(bobY) &&
                    tipScreen.x > -1000 && tipScreen.x < 10000 &&
                    tipScreen.y > -1000 && tipScreen.y < 10000) {
                    
                    // Draw line from tipScreen -> bobX/bobY
                    const dx = bobX - tipScreen.x;
                    const dy = bobY - tipScreen.y;
                    const distance = Math.hypot(dx, dy);
                    
                    if (distance > 1) { // Only draw if line has meaningful length
                        const angleDeg = Math.atan2(dy, dx) * 180 / Math.PI;
                        
                        // Position and style the line
                        this._overlayLine.style.display = 'block';
                        this._overlayLine.style.left = tipScreen.x + 'px';
                        this._overlayLine.style.top = tipScreen.y + 'px';
                        this._overlayLine.style.width = '2px';
                        this._overlayLine.style.height = distance + 'px';
                        this._overlayLine.style.transform = `rotate(${angleDeg}deg)`;
                        
                        // Position the bobber
                        this._overlayBobber.style.display = 'block';
                        this._overlayBobber.style.left = (bobX - 6) + 'px';
                        this._overlayBobber.style.top = (bobY - 6) + 'px';
                    } else {
                        // Line too short or points overlap - hide
                        if (this._overlayLine) this._overlayLine.style.display = 'none';
                        if (this._overlayBobber) this._overlayBobber.style.display = 'none';
                    }
                } else {
                    // Invalid coordinates - hide overlay
                    if (this._overlayLine) this._overlayLine.style.display = 'none';
                    if (this._overlayBobber) this._overlayBobber.style.display = 'none';
                }
            }
            
            #updateFishingLine(){
                // Update 3D line using world positions
                if (this.fishingLine && this.bobber && this.rodTipBone && 
                    this.bobber.visible && this.fishingLine.visible) {
                    
                    // Get world positions
                    this.rodTipBone.getWorldPosition(this._worldPosA);
                    this.bobber.getWorldPosition(this._worldPosB);
                    
                    // Update line geometry
                    const pos = this.fishingLine.geometry.attributes.position;
                    pos.setXYZ(0, this._worldPosA.x, this._worldPosA.y, this._worldPosA.z);
                    pos.setXYZ(1, this._worldPosB.x, this._worldPosB.y, this._worldPosB.z);
                    pos.needsUpdate = true;
                }
                
                // Also update 2D overlay for cross-container visibility
                this.#update2DFishingLine();
            }

            // Animate cast: ballistic arc to random target
            animateCast({ rngSeed, lakeBounds, lakeMesh, raycaster, splashSystem }){
                if (!this.bobber || !this.fishingLine || !this.rodTipBone) {
                    console.warn('Cat3D: Cannot animate cast - missing bobber, line, or rodTipBone');
                    return;
                }
                
                console.log('Cat3D: Starting cast animation');
                
                const rng = window.makeRNG ? window.makeRNG(rngSeed || Date.now()) : () => Math.random();
                
                // Convert lakeBounds center and wind to Vector3/Vector2 if needed
                const bounds = {
                    ...lakeBounds,
                    center: lakeBounds.center instanceof THREE.Vector3 
                        ? lakeBounds.center 
                        : new THREE.Vector3(lakeBounds.center.x || 0, lakeBounds.center.y || 0, lakeBounds.center.z || 0),
                    wind: lakeBounds.wind instanceof THREE.Vector2
                        ? lakeBounds.wind
                        : new THREE.Vector2(lakeBounds.wind?.x || 0, lakeBounds.wind?.y || 0)
                };
                
                // Choose a spot on the lake (scale to match model coordinate space)
                // Lake bounds should be relative to model scale
                let target = window.randomLakeTarget ? window.randomLakeTarget({
                    lakeBounds: bounds,
                    lakeMesh: lakeMesh || null,
                    raycaster: raycaster || new THREE.Raycaster(),
                    rng, padding: 2.0
                }) : new THREE.Vector3();
                
                // Optional wind/skill tweaks
                const skill = 0.7; // Could use this.player.stats.patience or similar
                target.x += bounds.wind.x * (1 - skill) * (0.5 + rng() * 0.5);
                target.z += bounds.wind.y * (1 - skill) * (0.5 + rng() * 0.5);
                
                // Face cat toward target
                if (window.faceModelYawToward && this.model) {
                    window.faceModelYawToward(this.model, target, 0.4);
                }
                
                // Get rod tip world position
                this.rodTipBone.updateWorldMatrix(true, false);
                const startTip = new THREE.Vector3();
                this.rodTipBone.getWorldPosition(startTip);
                
                console.log('Cat3D: Cast start tip:', startTip, 'target:', target);
                
                const end = target.clone();
                const travel = startTip.distanceTo(end);
                const duration = THREE.MathUtils.clamp(travel * 0.18, 0.45, 0.9);
                const hop = THREE.MathUtils.clamp(travel * 0.18, 0.8, 2.8);
                
                // Show bobber (overlay line will show automatically)
                this.bobber.visible = true;
                // Keep 3D line hidden - we use 2D overlay instead
                if (this.fishingLine) {
                    this.fishingLine.visible = false; // Hide 3D line, use overlay
                }
                this.bobber.position.copy(startTip); // Start at rod tip
                
                console.log('Cat3D: Bobber visible:', this.bobber.visible, 'Using 2D overlay line');
                
                const t0 = performance.now() / 1000;
                const step = () => {
                    const t = performance.now() / 1000 - t0;
                    const u = THREE.MathUtils.clamp(t / duration, 0, 1);
                    const ease = u * u * (3 - 2 * u); // smoothstep
                    
                    // Position along ground
                    const p = new THREE.Vector3().lerpVectors(startTip, end, ease);
                    // Add vertical arc
                    p.y = startTip.y + Math.sin(Math.PI * ease) * hop;
                    
                    // Move bobber
                    this.bobber.position.copy(p);
                    
                    // Force update world matrix for overlay projection
                    this.bobber.updateWorldMatrix(true, false);
                    
                    // 2D overlay line will update automatically in #updateFishingLine()
                    
                    if (u < 1) {
                        requestAnimationFrame(step);
                    } else {
                        // Snap to water surface
                        const waterSurfaceY = lakeBounds.y || 0;
                        if (lakeMesh && raycaster) {
                            const start = new THREE.Vector3(end.x, end.y + 100, end.z);
                            const dir = new THREE.Vector3(0, -1, 0);
                            raycaster.set(start, dir);
                            const hit = raycaster.intersectObject(lakeMesh, true)[0];
                            if (hit) {
                                this.bobber.position.copy(hit.point);
                                this.bobber.position.y += 0.01; // Lift slightly above water
                            } else {
                                this.bobber.position.y = waterSurfaceY + 0.01;
                            }
                        } else {
                            this.bobber.position.y = waterSurfaceY + 0.01;
                        }
                        
                        // Overlay line stays visible automatically via #update2DFishingLine()
                        // 3D line stays hidden - we use overlay
                        
                        // Splash effect
                        if (splashSystem?.spawnAt) {
                            splashSystem.spawnAt(this.bobber.position);
                        }
                        
                        // Start idle bobbing
                        this.bobber.userData.bobbing = true;
                        this.bobber.userData.bobPhase = 0;
                        this.bobber.userData.baseY = this.bobber.position.y;
                    }
                };
                
                // Start the animation loop
                requestAnimationFrame(step);
            }
            
            #updateProcedurals(){
                const t = performance.now()*0.001;

                // Simple breathing animation for placeholder
                if (this.breathingScale !== undefined && this.model) {
                    this.breathingScale = 1.0 + Math.sin(t * 2.3) * 0.02;
                    this.model.scale.setScalar(this.scale * this.breathingScale);
                }

                // blink (morph or fake by moving eyelids if you add them later)
                if (this.blinkMorph){
                    // random sparse blink
                    const phase = (Math.sin(t*0.25)+1)/2; // slow wave 0..1
                    const rand  = (Math.sin(t*7.733)+1)/2; // pseudo-rand 0..1
                    let blink = 0.0;
                    if (rand > 0.985) blink = 1.0; // quick full blink
                    else if (rand > 0.96) blink = 0.35;
                    this.blinkMorph.mesh.morphTargetInfluences[this.blinkMorph.idx] = THREE.MathUtils.damp(
                        this.blinkMorph.mesh.morphTargetInfluences[this.blinkMorph.idx] || 0, blink, 12, this.clock.getDelta()
                    );
                }

                // tail sway if we found a tail bone (small, natural)
                if (this.tailBone){
                    this.tailBone.rotation.z = Math.sin(t*1.8) * THREE.MathUtils.degToRad(7);
                }
            }

            // === reactions you can call from game ===
            bite(){
                // ear flick + quick look
                if (this.earMorphL) this.#pulseMorph(this.earMorphL, 0.6, 120);
                if (this.earMorphR) this.#pulseMorph(this.earMorphR, 0.6, 180);
                this.#cameraNod(0.02, 180);
            }
            catch(){
                // happy bounce (play "Celebrate" clip if present, else nudge model)
                const clip = this.clips['celebrate'] || this.clips['cheer'];
                if (clip && this.mixer){
                    this.mixer.stopAllAction();
                    const act = this.mixer.clipAction(clip);
                    act.reset().play();
                } else {
                    this.#bounce(0.06, 280);
                }
            }
            sad(){
                // subtle head dip
                this.#cameraNod(-0.03, 260);
            }

            // helpers
            #pulseMorph(target, amount=0.6, ms=150){
                const inf = target.mesh.morphTargetInfluences;
                const i = target.idx;
                let t0; const tick = (ts)=>{
                    if (!t0) t0 = ts;
                    const a = (ts - t0)/ms;
                    if (a < 0.5) inf[i] = amount * (a/0.5); else inf[i] = amount * (1 - (a-0.5)/0.5);
                    if (a<1) requestAnimationFrame(tick); else inf[i]=0;
                };
                requestAnimationFrame(tick);
            }
            #bounce(height=0.05, ms=220){
                const y0 = this.model.position.y; let t0;
                const tick=(ts)=>{ if(!t0) t0=ts; const a=(ts-t0)/ms;
                    const y = Math.sin(Math.min(a,1)*Math.PI)*height;
                    this.model.position.y = y0 + y;
                    if (a<1) requestAnimationFrame(tick); else this.model.position.y=y0;
                }; requestAnimationFrame(tick);
            }
            #cameraNod(amount=0.02, ms=180){
                const x0 = this.camera.rotation.x; let t0;
                const tick=(ts)=>{ if(!t0) t0=ts; const a=(ts-t0)/ms;
                    const k = Math.sin(Math.min(a,1)*Math.PI);
                    this.camera.rotation.x = x0 + k*amount;
                    if (a<1) requestAnimationFrame(tick); else this.camera.rotation.x=x0;
                }; requestAnimationFrame(tick);
            }

            dispose(){
                // Clean up 2D overlay elements
                if (this._overlayLine) {
                    this._overlayLine.remove();
                    this._overlayLine = null;
                }
                if (this._overlayBobber) {
                    this._overlayBobber.remove();
                    this._overlayBobber = null;
                }
                
                cancelAnimationFrame(this.raf);
                if (this.renderer) {
                    const gl = this.renderer.getContext?.();
                    this.renderer.dispose();
                    
                    // Dispose geometries and materials
                    if (this.scene) {
                        this.scene.traverse(obj => {
                            if (obj.geometry) {
                                obj.geometry.dispose();
                            }
                            if (obj.material) {
                                const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
                                mats.forEach(m => {
                                    if (m.dispose) m.dispose();
                                    if (m.map && m.map.dispose) m.map.dispose();
                                    if (m.envMap && m.envMap.dispose) m.envMap.dispose();
                                    if (m.normalMap && m.normalMap.dispose) m.normalMap.dispose();
                                    if (m.emissiveMap && m.emissiveMap.dispose) m.emissiveMap.dispose();
                                });
                            }
                        });
                    }
                    
                    // Force context loss if possible
                    if (gl?.getExtension) {
                        const ext = gl.getExtension('WEBGL_lose_context');
                        if (ext) ext.loseContext();
                    }
                    
                    // Remove canvas from DOM
                    if (this.renderer.domElement) {
                        this.renderer.domElement.remove();
                    }
                    
                    // Clear container references
                    if (this.container) {
                        this.container.__renderer = null;
                        this.container.__scene = null;
                        this.container.__camera = null;
                        this.container.__mounted = false;
                        this.container.__mounting = false;
                        this.container.innerHTML = '';
                    }
                    
                    // Decrement active context count and remove from active set
                    window.activeWebGLContexts = Math.max(0, (window.activeWebGLContexts || 1) - 1);
                    if (this.container) {
                        const playerKey = this.container.dataset.cat3d || this.container.dataset.playerId;
                        if (playerKey && window.ACTIVE_3D_PLAYERS) {
                            window.ACTIVE_3D_PLAYERS.delete(window.safeKey(playerKey));
                        }
                    }
                }
            }

            // Frame camera to host based on model bounding sphere (reusable for resize)
            #frameCameraToHost(){
                if (!this.container || !this.camera || !this.model) return;
                
                const w = this.container.clientWidth || 96;
                const h = this.container.clientHeight || 96;
                const aspect = w / h;
                
                // Use stored sphere radius or recompute if needed
                let sphereRadius = this._sphereRadius;
                if (!sphereRadius && this.model) {
                    const box = new THREE.Box3().setFromObject(this.model);
                    const sphere = new THREE.Sphere();
                    box.getBoundingSphere(sphere);
                    sphereRadius = sphere.radius;
                    this._sphereRadius = sphereRadius;
                }
                
                if (!sphereRadius) return;
                
                // FOV in radians (vertical FOV)
                const halfFov = (this.camera.fov * Math.PI / 180) * 0.5;
                
                // Distance to fit HEIGHT uses **radius** (not diameter):
                const fitHeightDist = sphereRadius / Math.tan(halfFov);
                
                // Distance to fit WIDTH accounts for aspect:
                const fitWidthDist = sphereRadius / (Math.tan(halfFov) * aspect);
                
                        // Pick the larger, then add moderate padding (tune 1.0‚Äì1.35 for size)
                        // Smaller multiplier = bigger cat appearance
                        const dist = Math.max(fitHeightDist, fitWidthDist) * 0.95; // Reduced from 1.25 to make cat bigger
                this._cameraDistance = dist;
                
                // Slightly above center so the face isn't dead-center
                this.camera.position.set(0, sphereRadius * 0.35, dist);
                this.camera.near = Math.max(0.01, dist / 100);
                this.camera.far = dist * 100;
                this.camera.lookAt(0, 0, 0);
                this.camera.updateProjectionMatrix();
            }

            // Resize renderer and camera to match host dimensions
            #resize(){
                if (!this.container || !this.renderer || !this.camera) return;
                const w = this.container.clientWidth || 96;
                const h = this.container.clientHeight || 96;
                if (w === 0 || h === 0) return;
                
                // Match render surface to host with proper DPR
                const dpr = Math.min(window.devicePixelRatio || 1, 2);
                this.renderer.setPixelRatio(dpr);
                this.renderer.setSize(w, h, false);
                
                // Recompute camera framing when aspect changes
                this.camera.aspect = w / h || 1;
                this.#frameCameraToHost();
            }
        }

        // Simple manager so your game can access cats by player name/id
        window.CatRigs = {
            map: new Map(),
            mount(selectorOrEl, opts){
                const el = (typeof selectorOrEl === 'string') ? document.querySelector(selectorOrEl) : selectorOrEl;
                if (!el) return null;
                
                // Use safeKey for consistent mapping
                const key = el.dataset.cat3d || el.dataset.playerId 
                    ? window.safeKey(el.dataset.cat3d || el.dataset.playerId)
                    : ('player-'+Math.random().toString(36).slice(2));
                
                // Idempotent: Check for existing renderer on container
                if (el.__renderer && el.__mounted) {
                    console.log('Cat3D: Reusing existing renderer for', key);
                    const existing = this.map.get(key);
                    if (existing) return existing;
                }
                
                // Only dispose if it's actually different (not just a remount)
                const existing = this.map.get(key);
                if (existing && existing.container !== el) {
                    console.log('Cat3D: Disposing existing rig for different container');
                    existing.dispose();
                } else if (existing && existing.container === el && el.__mounted) {
                    // Same container, already mounted - reuse
                    console.log('Cat3D: Container already mounted, reusing');
                    return existing;
                }
                
                // Ensure container is visible before mounting
                const rect = el.getBoundingClientRect();
                if (rect.width === 0 || rect.height === 0 || el.offsetParent === null) {
                    console.warn('Cat3D: Container not visible, cannot mount');
                    return null;
                }
                
                // Check WebGL context limit
                if (window.activeWebGLContexts >= 8) {
                    console.warn('WebGL context limit reached, cannot mount new cat');
                    el.dispatchEvent(new CustomEvent('cat3d-failed'));
                    return null;
                }
                
                const rig = new Cat3D(el, opts);
                if (rig.renderer) {
                    this.map.set(key, rig);
                    return rig;
                }
                return null;
            },
            get(key){ return this.map.get(key); },
            bite(key){ this.map.get(key)?.bite(); },
            catch(key){ this.map.get(key)?.catch(); },
            sad(key){ this.map.get(key)?.sad(); },
            disposeAll(){
                this.map.forEach(rig => rig.dispose());
                this.map.clear();
            }
        };
        
        // Global resize handler for all cat containers
        window.addEventListener('resize', () => {
            document.querySelectorAll('.cat3d').forEach(container => {
                if (container.__renderer && container.__camera) {
                    const w = container.clientWidth;
                    const h = container.clientHeight;
                    if (w === 0 || h === 0) return;
                    
                    const dpr = Math.min(window.devicePixelRatio || 1, 2);
                    container.__renderer.setPixelRatio(dpr);
                    container.__renderer.setSize(w, h, false);
                    container.__camera.aspect = w / h || 1;
                    container.__camera.updateProjectionMatrix();
                }
            });
        });

        // CSS.escape polyfill for older browsers
        if (!window.CSS || !CSS.escape) { 
            CSS = CSS || {}; 
            CSS.escape = s => String(s).replace(/[^a-z0-9_\-]/gi, '\\$&'); 
        }

        // Internal mount function that does the actual work
        window._reallyMountPlayerCat3D = function(playerName, options={}){
            // Use bulletproof container finder
            const host = window.getCatContainerForPlayer(playerName);
            
            if (!host) {
                console.warn('mountPlayerCat3D: No container found for player', playerName);
                return null;
            }
            
            // Idempotent: if already mounted, return existing rig
            if (host.__renderer && host.__mounted) {
                const playerKey = window.safeKey(playerName);
                const existing = window.CatRigs?.map?.get(playerKey);
                if (existing) {
                    console.log('mountPlayerCat3D: Reusing existing renderer for', playerName);
                    return existing;
                }
            }
            
            // Prevent re-entry during mount
            if (host.__mounting) {
                console.log('mountPlayerCat3D: Mount already in progress for', playerName);
                return null;
            }
            host.__mounting = true;
            
            // Check context limit before attempting mount
            if (window.activeWebGLContexts >= window.MAX_3D_RENDERERS) {
                console.warn('WebGL context limit reached, skipping 3D mount for', playerName);
                host.__mounting = false;
                host.dispatchEvent(new CustomEvent('cat3d-failed'));
                return null;
            }
            
            // Ensure container is visible
            const rect = host.getBoundingClientRect();
            if (rect.width === 0 || rect.height === 0 || host.offsetParent === null) {
                // For preview, this is expected when the character selection panel isn't visible yet
                if (playerName === 'preview') {
                    // Silently skip preview mount if not visible - it will mount when visible
                    host.__mounting = false;
                    return null;
                }
                console.warn('mountPlayerCat3D: Container not visible for', playerName);
                host.__mounting = false;
                host.dispatchEvent(new CustomEvent('cat3d-failed'));
                return null;
            }
            
            const playerKey = window.safeKey(playerName);
            const rig = window.CatRigs.mount(host, {
                modelUrl: options.modelUrl || '/assets/glb/PZSNQ3IH66OXPUSBTYNAMD6EC.glb', // Real cat model
                envUrl:   options.envUrl   || null,
                furColor: options.furColor || '#c8a079',
                scale:    options.scale    || 0.9
            });
            
            host.__mounting = false;
            
            if (rig) {
                window.ACTIVE_3D_PLAYERS.add(playerKey);
            }
            
            return rig;
        };

        // Public mount function with race condition protection
        window.mountPlayerCat3D = function(playerName, options={}){
            // De-race the first mount (ensure the host actually has a size)
            requestAnimationFrame(() => {
                const host = window.getCatContainerForPlayer(playerName);
                if (!host) {
                    // Try one more frame later if host doesn't exist yet
                    return requestAnimationFrame(() => {
                        if (window.getCatContainerForPlayer(playerName)) {
                            window._reallyMountPlayerCat3D(playerName, options);
                        }
                    });
                }
                const r = host.getBoundingClientRect();
                if (r.width === 0 || r.height === 0 || host.offsetParent === null) {
                    // try one more frame later (layout just changed)
                    return requestAnimationFrame(() => window._reallyMountPlayerCat3D(playerName, options));
                }
                window._reallyMountPlayerCat3D(playerName, options);
            });
        };
        
        // Signal that 3D module is ready
        window.Cat3DReady = true;
        window.dispatchEvent(new Event('cat3d-ready'));

        // Cleanup WebGL contexts on page unload
        window.addEventListener('beforeunload', () => {
            if (window.CatRigs) {
                window.CatRigs.disposeAll();
            }
        });
    </script>
</body>
</html>